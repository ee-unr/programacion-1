---
number-sections: false
---

```{=latex}
\thispagestyle{primerapagina}
```

# Soluciones de la Práctica de la Unidad 5

## Vectores

### Ejercicio 1

```{r}
#' Suma de los elementos de un vector
#'
#' Calcula la suma de todos los elementos de un vector numérico.
#'
#' @param v Un vector numérico.
#' @return La suma de los elementos del vector.
#' @examples
#' suma(c(1, 2, 3))  # Devuelve 6
suma <- function(v) {
  resultado <- 0
  for (i in 1:length(v)) {
    resultado <- resultado + v[i]
  }
  return(resultado)
}
```

### Ejercicio 2

```{r}
#' Suma componente a componente de dos vectores
#'
#' Suma dos vectores numéricos de igual longitud, elemento a elemento.
#' Si las longitudes no coinciden, se detiene con error.
#'
#' @param u Un vector numérico.
#' @param v Un vector numérico.
#'
#' @return Un vector numérico con la suma componente a componente.
#'
#' @examples
#' sumar_vectores(c(1, 2, 3), c(4, 5, 6))  # Devuelve c(5, 7, 9)
sumar_vectores <- function(u, v) {
  nu <- length(u)
  nv <- length(v)
  if (nu != nv) {
    stop("Las dimensiones de los vectores no coinciden.")
  }
  suma <- numeric(nu)
  for (i in 1:nu) { 
    suma[i] <- u[i] + v[i]
  }
  return(suma)
}
```

### Ejercicio 3

```{r}
#' Ordenar un vector numérico de forma ascendente
#'
#' Ordena los elementos de un vector numérico en orden ascendente usando un 
#' algoritmo de comparación simple.
#'
#' @param v Un vector numérico.
#'
#' @return Un vector numérico con los elementos ordenados de menor a mayor.
#'
#' @examples
#' ordenar_asc(c(3, 1, 4, 2))  # Devuelve c(1, 2, 3, 4)
ordenar_asc <- function(v) {
  n <- length(v)
  for (i in 1:n) {
    for (j in i:n) {
      if (v[i] > v[j]) {
        tmp <- v[i]
        v[i] <- v[j]
        v[j] <- tmp 
      }
    }
  }
  return(v)
}
```

### Ejercicio 4

```{r}
#' Máximo de un vector numérico
#'
#' Encuentra el valor máximo en un vector numérico y su posición.
#'
#' @param v Un vector numérico.
#'
#' @return Un vector numérico de longitud 2. El primer elemento es el valor 
#' máximo, y el segundo, la posición donde se encuentra (primera aparición).
#'
#' @examples
#' maximo(c(4, 2, 7, 1))  # Devuelve c(7, 3)
#' maximo(c(10))          # Devuelve c(10, 1)
maximo <- function(v) {
  n <- length(v)
  mayor <- v[1]
  posicion <- 1
  for (i in 1:n) {
    # Desde i = 1 para que también funcione si n = 1
    if (v[i] > mayor) {
      mayor <- v[i]
      posicion <- i
    }
  }
  resultado <- c("mayor" = mayor, "posicion" = posicion)
  return(resultado)
}
```

### Ejercicio 5

a.  Producto escalar de dos vectores.
    
    ```{r}
    #' Producto escalar de dos vectores
    #'
    #' Calcula el producto escalar entre dos vectores numéricos de igual 
    #' longitud.
    #'
    #' @param u Un vector numérico.
    #' @param v Un vector numérico.
    #'
    #' @return Un número que representa el producto escalar entre u y v.
    #' @details Se detiene con error si las longitudes no coinciden.
    #'
    #' @examples
    #' prod_escalar(c(1, 2, 3), c(4, 5, 6))  # Devuelve 32
    #' prod_escalar(c(1, 2), c(1, 2, 3))     # Error
    prod_escalar <- function(u, v) {
      nu <- length(u)
      nv <- length(v)
      if (nu != nv) {
        stop("Las dimensiones de los vectores no coinciden.")
      }
      suma <- 0
      for (i in 1:nu) {
        suma <- suma + u[i] * v[i]
      }
      return(suma)
    }
    ```

b.  Producto vectorial de dos vectores de dimensión 3
    
    ```{r}
    #' Producto vectorial de dos vectores de dimensión 3
    #'
    #' Calcula el producto vectorial entre dos vectores numéricos de dimensión 
    #' 3.
    #'
    #' @param u Un vector numérico de longitud 3.
    #' @param v Un vector numérico de longitud 3.
    #'
    #' @return Un vector numérico de longitud 3 que representa el producto 
    #' vectorial u × v
    #' 
    #' @details Se detiene con error si alguno de los vectores no tiene 
    #' dimensión 3.
    #'
    #' @examples
    #' prod_vectorial(c(1, 0, 0), c(0, 1, 0))  # Devuelve c(0, 0, 1)
    #' prod_vectorial(c(1, 2), c(3, 4))        # Error
    prod_vectorial <- function(u, v) {
      nu <- length(u)
      nv <- length(v)
      if (nu != 3 || nv != 3) {
        stop("Los vectores no son de dimensión 3.")
      }
      resultado <- c(u[2] * v[3] - u[3] * v[2], 
                     u[3] * v[1] - u[1] * v[3], 
                     u[1] * v[2] - u[2] * v[1])
      return(resultado)
    }
    ```

c.  Producto mixto de tres vectores de dimensión 3
    
    ```{r}
    #' Producto mixto de tres vectores de dimensión 3
    #'
    #' Calcula el producto mixto de tres vectores u, v y w  de dimensión 3,
    #' definido como el producto escalar de w con el producto vectorial de u y v
    #'
    #' @param u Un vector numérico de longitud 3.
    #' @param v Un vector numérico de longitud 3.
    #' @param w Un vector numérico de longitud 3.
    #'
    #' @return Un número que representa el producto mixto.
    #' @details Se detiene con error si alguno de los vectores no tiene 
    #' dimensión 3.
    #'
    #' @examples
    #' prod_mixto(c(1, 0, 0), c(0, 1, 0), c(0, 0, 1)) # Devuelve 1
    #' prod_mixto(c(1, 2), c(3, 4, 5), c(6, 7, 8))    # Error
    prod_mixto <- function(u, v, w) {
      resultado1 <- prod_vectorial(u, v)
      resultado2 <- prod_escalar(resultado1, w)
      return(resultado2)
    }
    ```

d.  Mostrar productos vectoriales y escalares entre tres vectores
    
    ```{r}
    #' Mostrar productos vectoriales y escalares entre tres vectores
    #'
    #' Calcula y muestra por consola el producto escalar entre v y w, 
    #' el producto vectorial entre u y w, y el producto mixto entre v, w y u.
    #'
    #' @param u Un vector numérico de longitud 3.
    #' @param v Un vector numérico de longitud 3.
    #' @param w Un vector numérico de longitud 3.
    #'
    #' @return No devuelve un valor, solo imprime los resultados por consola.
    #'
    #' @examples
    #' mostrar_productos(c(5, 8, 2), c(2, 3, -1), c(1, 2, 3))
    mostrar_productos <- function(u, v, w) {
      prod_esc <- prod_escalar(v, w)
      prod_mix <- prod_mixto(v, w, u)
      cat("El producto escalar entre v y w es:", prod_esc, "\n")
      cat("El producto mixto entre v, w y u es:", prod_mix, "\n")
      resultado <- c("prod_escalar" = prod_esc, "prod_mixto" = prod_mix)
      return(resultado)
    }
    ```

### Ejercicio 6

```{r}
#' Mostrar números primos hasta n usando distintos enfoques de la Criba de 
#' Eratóstenes
#'
#' Esta función muestra los números primos hasta n utilizando distintos enfoques
#' de la criba de Eratóstenes.
#' El argumento enfoque permite elegir entre varias implementaciones:
#' "asumir_primos", "tachar", o "encerrado".
#'
#' @param n Un número entero positivo que indica el límite superior para 
#' la búsqueda de primos.
#' @param enfoque Un string que indica el enfoque a usar: "asumir_primos",
#' "tachar" o "encerrado".
#'
#' @details
#' Los enfoques disponibles son:
#' 
#' - "asumir_primos"
#' Parte de un vector lógico donde todos los números son considerados primos 
#' inicialmente (excepto el 1). Luego, se descartan los múltiplos de cada 
#' número que aún es considerado primo.
#'
#' - "tachar"
#' Utiliza un vector "tachado" para marcar con TRUE los números que no son 
#' primos (es decir, los tachados). Comienza tachando el 1, y luego los 
#' múltiplos de cada número no tachado. Los primos son los que quedan sin
#' tachar al final.
#'
#' - "encerrado"
#' Usa un vector lógico llamado "encerrado" donde todos los números empiezan 
#' como TRUE. Cada vez que se encuentra un primo, se marcan (ponen en FALSE) 
#' todos sus múltiplos, indicando que ya no están "encerrados".
#' 
#' @return Ninguno. La función imprime en consola los números primos encontrados.
#'
#' @examples
#' mostrar_primos(30, enfoque = "asumir_primos")
#' mostrar_primos(30, enfoque = "tachar")
#' mostrar_primos(30, enfoque = "encerrado")
mostrar_primos <- function(n, enfoque = c("asumir_primos", "tachar", "encerrado")) {
  if (enfoque == "asumir_primos") {
    es_primo <- rep(TRUE, n)
    es_primo[1] <- FALSE
    for (i in 2:n) {
      if (es_primo[i]) {
        print(i)
        j <- 2 * i
        while (j <= n) {
          es_primo[j] <- FALSE
          j <- j + i
        }
      }
    }
  } else if (enfoque == "tachar") {
    tachado <- logical(n)
    tachado[1] <- TRUE
    for (i in 2:n) {
      if (!tachado[i]) {
        print(i)
        j <- 2 * i
        while (j <= n) {
          tachado[j] <- TRUE
          j <- j + i
        }
      }
    }
  } else if (enfoque == "encerrado") {
    encerrado <- rep(TRUE, n)
    for (i in 2:n) {
      if (encerrado[i]) {
        print(i)
        for (j in seq(i, n, i)) {
          encerrado[j] <- FALSE
        }
      }
    }
  }
}
```

## Matrices

### Ejercicio 7

```{r}
#' Suma de dos matrices
#'
#' Esta función toma dos matrices del mismo tamaño y devuelve una nueva matriz 
#' que representa la suma elemento a elemento de ambas. Si las dimensiones 
#' no coinciden, imprime un mensaje de error y devuelve NULL
#'
#' @param A Una matriz numérica.
#' @param B Una matriz numérica del mismo tamaño que A.
#'
#' @return Una matriz con la suma de A y B
#' @details Produce error si las dimensiones no coinciden.
#'
#' @examples
#' A <- matrix(1:4, nrow = 2)
#' B <- matrix(5:8, nrow = 2)
#' sumar_matrices(A, B)
sumar_matrices <- function(A, B) {
  if (nrow(A) != nrow(B) || ncol(A) != ncol(B)) {
    stop("Las dimensiones de las matrices no coinciden.")
  }
  suma <- matrix(NA, nrow(A), ncol(A))
  for (i in 1:nrow(A)) {
    for (j in 1:ncol(A)) {
      suma[i, j] <- A[i, j] + B[i, j]
    }
  }
  return(suma)
}
```

### Ejercicio 8

a.  Mínimo de una matriz y su posición.
    
    ```{r}
    #' Mínimo de una matriz y su posición
    #'
    #' Esta función recorre una matriz y devuelve un vector con el valor mínimo 
    #' y su posición (fila y columna) dentro de la matriz.
    #'
    #' @param m Una matriz numérica.
    #'
    #' @return Un vector numérico de longitud 3 con los siguientes valores: 
    #' - Posición 1: El valor mínimo encontrado en la matriz.
    #' - Posición 2: La fila donde se encuentra el valor mínimo.
    #' - Posición 3: La columna donde se encuentra el valor mínimo.
    #'
    #' @examples
    #' matriz <- matrix(c(3, 2, 5, 1, 4, 6), nrow = 2)
    #' minimo_matriz(matriz)
    minimo_matriz <- function(m) {
      min <- m[1, 1]
      fila <- 1
      col <- 1
      for (i in 1:nrow(m)) {
        for (j in 1:ncol(m)) {
          if (m[i, j] < min) {
            min <- m[i, j]
            fila <- i
            col <- j
          }
        }
      }
      resultado <- c(minimo = min, fila = fila, columna = col)
      return(resultado)
    }
    ```

b.  Encontrar el valor mínimo en una fila específica de una matriz.
    
    ```{r}
    #' Encontrar el valor mínimo en una fila específica de una matriz
    #'
    #' Esta función busca el valor mínimo dentro de una fila específica de una 
    #' matriz y devuelve el valor junto con el número de columna donde se 
    #' encuentra.
    #'
    #' @param m Una matriz numérica.
    #' @param fila Un entero que indica el número de fila en la que se desea 
    #' buscar el valor mínimo.
    #'
    #' @return Un vector numérico de longitud 2con los siguientes valores: 
    #' - Posición 1: El valor mínimo en la fila especificada.
    #' - Posición 2: El número de columna donde se encuentra ese valor mínimo.
    #'
    #' @examples
    #' matriz <- matrix(c(3, 2, 5, 1, 4, 6), nrow = 2)
    #' minimo_matriz_fila(matriz, 1)
    minimo_matriz_fila <- function(m, fila = 1) {
      min <- m[fila, 1]
      col <- 1
      for (j in 1:ncol(m)) {
        if (m[fila, j] < min) {
          min <- m[fila, j]
          col <- j
        }
      }
      return(c(minimo = min, columna = col))
    }
    ```

### Ejercicio 9

a.  Ordenar matriz por columna en orden descendente.
    
    ```{r}
    #' Ordenar matriz por columna en orden descendente
    #'
    #' Esta función ordena las filas de una matriz numérica según los valores
    #' de una columna específica, en orden descendente.
    #'
    #' @param m Una matriz
    #' @param col Un entero que indica el índice de la columna por la que se 
    #' desea ordenar.
    #'
    #' @return La matriz ordenada por la columna especificada en orden 
    #' descendente.
    #' 
    #' @examples
    #' m <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2, byrow = TRUE)
    #' ordenar_desc_col(m, 1)
    ordenar_desc_col <- function(m, col) {
      if (nrow(m) > 1) {
        for (i in 1:(nrow(m)-1)) {
          for (j in (i+1):nrow(m)) {
            if (m[i, col] < m[j, col]) {
              for (k in 1:ncol(m)) {
                tmp <- m[i, k]
                m[i, k] <- m[j, k]
                m[j, k] <- tmp
              }
            }
          }
        }
      }
      return(m)
    }
    ```
    
    *Observaciones*
    
    - En lugar de chequear si tiene más de una fila, podríamos directamente poner `for (i in 1:nrow(m))` y `for (j in i:nrow(m))`. Esto funciona también cuando la matriz provista tiene una sola fila, pero en cualquier otro caso implica a hacer comparaciones lógicas de más, tantas como número de filastenga la matriz.
    - Se puede mejorar la función agregando un control para que el argumento `col` provisto por el usuario esté siempre entre 1 y `ncol(m)`.

b.  Ordenar matriz por fila en orden ascendente.
    
    ```{r}
    #' Ordenar matriz por fila en orden ascendente
    #'
    #' Esta función ordena las columnas de una matriz numérica según los valores
    #' de una fila específica, en orden ascendente.
    #'
    #' @param m Una matriz numérica.
    #' @param fila Un entero que indica el índice de la fila por la que se desea 
    #' ordenar.
    #'
    #' @return La matriz ordenada por la fila especificada en orden ascendente.
    #' 
    #' @examples
    #' m <- matrix(c(3, 1, 4, 2, 6, 5), nrow = 2, byrow = TRUE)
    #' ordenar_asc_fila(m, 1)
    ordenar_asc_fila <- function(m, fila) {
      if (ncol(m) > 1) {
        for (i in 1:(ncol(m) - 1)) {
          for (j in (i + 1):ncol(m)) {
            if (m[fila, i] > m[fila, j]) { # Solo cambia el signo
              for (k in 1:nrow(m)) {
                tmp      <- m[k, i]
                m[k, i]  <- m[k, j]
                m[k, j]  <- tmp
              }
            }
          }
        }
      }
      return(m)
    }
    ```

### Ejercicio 10

```{r}
#' Verificar si una matriz es un cuadrado mágico
#'
#' Esta función verifica si una matriz cuadrada numérica es un cuadrado mágico.
#' Un cuadrado mágico es una matriz en la que la suma de los elementos en cada 
#' fila, en cada columna y en las dos diagonales principales es igual.
#'
#' @param cuadrado Una matriz cuadrada numérica.
#'
#' @return `TRUE` si la matriz es un cuadrado mágico, `FALSE` en caso contrario.
#' 
#' @examples
#' m <- matrix(c(2, 7, 6, 9, 5, 1, 4, 3, 8), nrow=3, byrow=TRUE)
#' cuadrado_magico(m)
cuadrado_magico <- function(cuadrado) {
  n <- nrow(cuadrado)
  
  # Calcular el primer total fila para tener de control
  control <- 0
  for (j in 1:n) {
    control <- control + cuadrado[1, j]
  }
  
  # Calcular los restantes totales filas y chequearlos
  for (i in 2:n) {
    total <- 0
    for (j in 1:n) {
      total <- total + cuadrado[i, j]
    }
    if (total != control) {
      return(FALSE)
    }
  }
  
  # Chequear totales columnas si lo anterior estuvo bien
  for (j in 1:n) {
    total <- 0
    for (i in 1:n) {
      total <- total + cuadrado[i, j]
    }
    if (total != control) {
      return(FALSE)
    }
  }
  
  # Chequear diagonales si lo anterior estuvo bien
  diag1 <- 0
  diag2 <- 0
  for (i in 1:n) {
    diag1 <- diag1 + cuadrado[i, i]
    diag2 <- diag2 + cuadrado[n - i + 1, i]
  }
  if (diag1 != control || diag2 != control) {
    return(FALSE)
  }
  
  # Si llegamos hasta acá es porque todos los controles dieron bien
  return(TRUE)
}
```

## Operaciones Vectorizadas

### Ejercicio 11

a.  La función es `sum()`. Se puede usar tanto con vectores como con matrices.
  
    ```{r}
    mi_vector <- c(60, -5, 0, 12, 1)
    # Nuestra función
    suma(mi_vector)
    # La función de R Base
    sum(mi_vector)
    ```

b.  Basta con hacer:
  
    ```{r}
    u <- c(5, 8, 2)
    v <- c(2, 3, -1)
    u + v
    A <- matrix(c(5, 8, 2, 2, 3, 1), nrow = 3)
    B <- matrix(c(0, -1, 3, 1, 2, 4), nrow = 3)
    A + B
    ```

c.  La función es `sort()`
  
    ```{r}
    mi_vector <- c(60, -5, 0, 12, 1)
    # Por defecto, sort() ordena de forma ascendente
    sort(mi_vector)
    # Podemos definir decreasing = TRUE para ordenar en forma descendente
    sort(mi_vector, decreasing = TRUE)
    ```
    
    Si se aplica en vectores de tipo carácter, ordena alfabéticamente:
    
    ```{r}
    mi_vector <- c("introducción", "a", "la", "programación")
    sort(mi_vector)
    sort(mi_vector, decreasing = TRUE)
    ```

d.  Usamos `min()` y `max()`:
    
    ```{r}
    # Vectores
    mi_vector <- c(60, -5, 0, -5, 12, 1)
    min(mi_vector)
    max(mi_vector)
    # Ubicación del mínimo o máximo (sólo primera ocurrencia)
    which.min(mi_vector)
    which.max(mi_vector)
    # Ubicación del mínimo o máximo (todas las ocurrencias)
    which(mi_vector == min(mi_vector))
    which(mi_vector == max(mi_vector))
    # También sirve para vectores de tipo carácter
    mi_vector <- c("introducción", "a", "la", "programación")
    min(mi_vector)
    
    # Matrices
    A <- matrix(c(5, 8, 2, 7, 3, 1), nrow = 3)
    A
    min(A)
    max(A)
    # Posición (arr.ind = TRUE para que nos indique fila y columna)
    which(A == min(A), arr.ind = TRUE)
    which(A == max(A), arr.ind = TRUE)
    ```

e.  Se puede hacer:
    
    ```{r}
    u <- c(5, 8, 2)
    v <- c(2, 3, -1)
    sum(u * v)
    # Usando la function del Ejercicio 5a:
    prod_escalar(u, v)
    ```

f.  De la siguiente forma:
    
    ```{r}
    A
    # Evaluamos min() sólo en la fila 3
    min(A[3, ])
    # Para saber en qué columna de la fila 3 se encuentra su mínimo:
    which.min(A[3, ])
    # Para obtener el mínimo en cada fila:
    apply(A, 1, min)
    # Para saber en qué columna se encuentra el mínimo de cada fila:
    apply(A, 1, which.min)
    ```

g.  Una posibilidad es:
    
    ```{r}
    cuadrado_magico <- function(cuadrado) {
    	# Calcular el primer total fila para tener de control
      control <- sum(cuadrado[1, ])
      
      # Todos las sumas
      sumas_filas <- rowSums(cuadrado)
      sumas_col <- colSums(cuadrado)
      suma_diag1 <- sum(diag(cuadrado))
      suma_diag2 <- sum(diag(cuadrado[nrow(cuadrado):1, ]))
      
      # Junto las sumas en un vector (arbitrariamente dejo afuera a suma_diag2)
      sumas <- c(sumas_filas, sumas_col, suma_diag1)
      
      # ¿Dieron igual todas las sumas?
      return(all(sumas == suma_diag1))
    }
    
    cuadrado <- matrix(c(16,  3,  2, 13,
                          5, 10, 11,  8,
                          9,  6,  7, 12,
                          4, 15, 14,  1), nrow = 4, byrow = TRUE)
    cuadrado_magico(cuadrado)
    
    cuadrado <- matrix(c( 0,  3,  2, 13,
                          5, 10, 11,  8,
                          9,  6,  7, 12,
                          4, 15, 14,  1), nrow = 4, byrow = TRUE)
    cuadrado_magico(cuadrado)
    ```
  
### Ejercicio 12

a.

  ```{r}
  # Crear vector para guardar los promedios
  promedios <- numeric(ncol(m))
  # Calcular iterando a través de las filas
  for (j in 1:ncol(m)) {
    promedios[j] <- mean(m[, j])
  }
  promedios
  ```

b. 

    ```{r}
    apply(m, 2, mean)
    ```

