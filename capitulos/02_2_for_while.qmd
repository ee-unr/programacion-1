```{=latex}
\thispagestyle{primerapagina}
```

# Estructuras de control iterativas

::: {.presentacion-capitulo data-latex=""}
Las estructuras de control iterativas son útiles cuando la solución de un problema requiere que se ejecute repetidamente un determinado conjunto de acciones. El número de veces que se debe repetir dicha secuencia de acciones puede ser fijo o puede variar dependiendo de algún dato o condición a evaluar en el programa. Dependiendo de esto, podemos hacer uso de diferentes estructuras de control iterativas, como las de tipo **for** o las de tipo **while**, que presentamos en este capítulo.
:::

## Estructuras de control iterativas con un número fijo de iteraciones: **for**

Una estructura **for** se aplican cuando se conoce de antemano el número exacto de veces que se debe repetir una secuencia de instrucciones dentro de un programa. También se conoce como *bucle o loop for*. La sintaxis es:

```r
for (variable in conjunto) {
  hacer esto
}
```

En lo anterior, `conjunto` representa un conjunto de elementos, usualmente números o cadenas de texto. El bloque de instrucciones encerrados entre las llaves (que puede contener una o muchas líneas) se ejecutará tantas veces como elementos haya en `conjunto`. Por ejemplo:

```{r}
for (variable in c("Hola", "cómo", "estás")) {
  print("Esto es una repetición.")
}
```

En el ejemplo, con la expresión `c("Hola", "cómo", "estás")` se define un conjunto de tres cadenas de texto. Dado que hay tres elementos en ese conjunto, la acción indicada entre las llaves se realiza exactamente tres veces. Dicha acción consiste en imprimir en la consola el mensaje "Esto es una repetición" y se realiza gracias al uso de la función `print()`.

¿Y para qué está `variable` en esa estructura? Se trata de un objeto que recibe el nombre de **variable o índice de iteración**. En cada repetición y respetando el orden, el objeto `variable` va a recibir el valor de uno de los elementos del conjunto. En este caso, durante la primera iteración, `variable` almacena el valor `"Hola"`. En la segunda repetición, el valor `"cómo"` y en la tercera, `"estás"`. De hecho, si queremos podemos usar este objeto, cuyo valor va cambiando iteración tras iteración, en las acciones que se implementan dentro de las llaves:

```{r}
for (variable in c("Hola", "cómo", "estás")) {
  print("-------------------------")
  print("Esto es una repetición:")
  print(variable)
}
```


La variable de iteración, que en el ejemplo se llamó `variable`, en realidad puede llevar cualquier nombre que queramos. Es común usar sencillamente el nombre `i`. También es usual que el conjunto de elementos contenga números:

```{r}
for (i in c(1, 2, 3, 4, 5)) {
  print("-------------------------")
  print("En esta iteración i vale:")
  print(i)
}
```

En los elementos del conjunto son números enteros ordenados, se puede usar un atajo con la forma `inicio:fin`:

```{r}
for (i in 1:5) {
  print("-------------------------")
  print("En esta iteración i vale:")
  print(i)
}
```

::: {.ejemplo data-latex=""}
El siguiente bloque de código calcula y muestra la **tabla de multiplicar del ocho**:

```{r}
for (i in 0:10) {
  resultado <- 8 * i
  cat("8 x", i, "=", resultado, "\n")
}
```
:::

::: {.info data-latex=""}
Para emitir mensajes, podemos usar `print()` o `cat()`:

- `print()` tiene la ventaja de que al terminar de emitir el mensaje, agrega un salto de línea: lo próximo que se escriba, aparecerá en un nuevo renglón de la consola. No obstante, no nos permite de forma sencilla concatenar varias piezas de información para armar frases complejas.
- `cat()` nos permite unir cadenas de texto y valores guardados en variables para armar cualquier frase que queramos, separando entre comas cada una de las partes. Sin embargo, no incluye automáticamente un salto de línea: lo próximo que se escriba queda pegado a lo anterior en el mismo renglón. Para evitar esto, incluimos el carácter especial `\n` que representa un salto de línea. Si no lo agreamos, el resultado se ve así:

```{r}
for (i in 0:10) {
  resultado <- 8 * i
  cat("8 x", i, "=", resultado)
}
```
:::

::: {.ejemplo data-latex=""}
Imaginemos que queremos escribir un programa que permita calcular la quinta potencia de cualquier número, por ejemplo, $2^5$. Para esto, se debe tomar el número $2$ y multiplicarlo por sí mismo $5$ veces. Por lo tanto, una posible solución es:

```{r}
x <- 2
resultado <- 1
resultado <- resultado * x
resultado <- resultado * x
resultado <- resultado * x
resultado <- resultado * x
resultado <- resultado * x
cat(x, "a la quinta es igual a", resultado)
```

Ya que sabemos que la multiplicación se debe repetir 5 veces, podemos resumir lo anterior con la siguiente estructura:

```{r}
x <- 2
resultado <- 1
for (i in 1:5) {
	resultado <- resultado * x
}
cat(x, "a la quinta es igual a", resultado)
```
:::


::: {.ejercicio data-latex=""}
¿Cuál será el valor final de `salida` después de ejecutar el siguiente código en R?

```r
salida <- 30
for (i in 1:4) {
  salida <- salida - i
}
```

`salida` es igual a: `r webexercises::fitb(20)`.
:::

## Estructuras de control iterativas con un número indeterminado de iteraciones

En otras circunstancias se puede necesitar repetir un bloque de acciones sin conocer con exactitud cuántas veces, si no que esto depende de algún otro aspecto del programa. Las iteraciones pueden continuar *mientras que* o *hasta que* se verifique alguna condición, dando lugar a dos tipos de estructuras. Estos casos también se conocen como *bucles o loops controlados por una condición*.

### Estructura **while** (mientras)

El conjunto de instrucciones se repite mientras que se siga evaluando como `TRUE` una condición declarada al inicio del bloque. Cuando la condición ya no se cumple, el proceso deja de ejecutarse. La sintaxis es:

```r
while (condición) {
	hacer esto
}
```

Observaciones:

- La evaluación de la condición se lleva a cabo antes de cada iteración, incluso antes de ejecutar el código dentro del bloque por primera vez. Si la condición es `FALSO` inicialmente, entonces las acciones en el cuerpo de la estructura no se ejecutan nunca.
- La evaluación de la condición **sólo** se lleva a cabo al inicio de cada iteración. Si la condición se vuelve `FALSO` en algún punto durante la ejecución de un bloque, el programa no lo nota hasta que se termine de ejecutar el bloque y la condición sea evaluada antes de comenzar la próxima iteración.

Veamos un ejemplo:

```
ALGORITMO: "Dividir un número por 2 hasta encontrar un valor menor que 0.01"
COMENZAR
	VARIABLE numérica x
	LEER x
	MIENTRAS QUE x >= 0.01 HACER
		x <- x / 2
		ESCRIBIR x
	FIN MIENTRAS
FIN
```

```{r}
x <- 100
while (x >= 0.01) {
	x <- x / 2
	cat(x, "\n")
}
```

### Hasta que

A diferencia de la estructura *MIENTRAS QUE*, la estructura *HASTA QUE* repite el bloque de acciones hasta que se cumpla una condición, es decir, se ejecuta mientras que dicha condición sea evaluada como `FALSA`. La sintaxis es:

```{r, tidy=FALSE, eval=FALSE, highlight=FALSE, echo=T}
REPETIR
   Acción/es
HASTA QUE <condición>
```

Observación: con la estructura *MIENTRAS QUE* podría ser que el conjunto de sentencias nunca llegue a ejecutarse si desde partida la condición evaluada ya es falsa. Por el contrario, en la estructura *HASTA QUE* el proceso se realiza al menos una vez, dado que la condición se evalúa al final.

El ejemplo anterior empleando este tipo de estructura:

```
ALGORITMO: "Dividir un número por 2 hasta encontrar un valor menor que 0.01"
COMENZAR
	VARIABLE numérica x
	LEER x
	REPETIR
		x <- x / 2
		ESCRIBIR x
	HASTA QUE x < 0.01
FIN
```

En R este tipo de estructura se implementa con la sentencia `repeat {}`. Si bien a continuación se muestra el correspondiente ejemplo, no vamos a utilizar esta estructura, debido a que su escritura es más compleja y a que generalmente es posible obtener el mismo resultado con un `while () {}`.

```{r}
x <- 100
repeat {
	x <- x / 2
	cat(x, "\n")
	if (x < 0.01) break
}
```

### Loops infinitos

Con las sentencias de tipo `MIENTRAS QUE` se debe tener mucha precaución, puesto que si la evaluación lógica no está bien especificada o nunca deja de ser evaluada como `TRUE`, se incurre en un *loop* infinito: el programa nunca deja de repetir el bloque (al menos hasta que la máquina se tilde o se produzca un error por desbordamiento de memoria, por ejemplo). 

La siguiente situación ilustra esto:

```
var <- 9
while (var < 10) {
	var <- var - 1
	cat("var =", var, "No puedo parar!!!\n")
}

var = 8 No puedo parar!!!
var = 7 No puedo parar!!!
var = 6 No puedo parar!!!
var = 5 No puedo parar!!!
var = 4 No puedo parar!!!
var = 3 No puedo parar!!!
var = 2 No puedo parar!!!
var = 1 No puedo parar!!!
var = 0 No puedo parar!!!
var = -1 No puedo parar!!!
...
```

En R se puede usar la instrucción `break` para forzar la detención del proceso iterativo si se presenta alguna condición en particular^[También podemos usar `break` dentro de una estructura `for`]:

```{r}
var <- 9
while (var < 10) {
	var <- var - 1
	cat("var =", var, "No puedo parar!!!\n")
	if (var == -3) break
}
```


### Ejemplos

A continuación se presentan algunos otros ejemplos

- No necesariamente tiene que ser `i` la variable iteradora, podemos darle cualquier nombre:

	```{r}
	for (guau in 1:5) {
		print(guau)
	}
	```

	La sentencia `print()` también sirve para mostrar resultados. La ventaja con respecto a `cat()` es que no necesitamos agregar `\n` para que el siguiente mensaje se escriba en un nuevo renglón, ya que lo agrega por sí sola sin que lo pidamos. La desventaja es que no nos permite crear un mensaje combinando elementos separados entre comas, tal como se puede hacer con `cat()` (por ejemplo, `cat("El valor de x es igual a", x)`).

- Acá tenemos un ejemplo de dos estructuras `for` anidadas. En primer lugar, `i` toma el valor 1, y entonces `j` varía de 1 a 2, generando las combinaciones `i = 1, j = 1; i = 1, j = 2`. Luego de que el *loop* de `j` finalice habiendo recorrido todo su campo de variación, comienza la segunda iteración del *loop* de `i`, actualizándose su valor a 2 y comenzando otra vez el *loop* de `j`, que varía de 1 a 2. Así, se generan las combinaciones `i = 2, j = 1; i = 2, j = 2`. Finalmente, se actualiza `i` y pasa a valer 3, generando las combinaciones `i = 3, j = 1; i = 3, j = 2`. Para cada combinación, se muestra el valor de la suma:

	```{r}
	for (i in 1:3) {
		for (j in 1:2) {
			suma <- i + j
			cat("i vale", i, "y j vale", j, ". La suma es igual a", suma, "\n")	
		}
	}
	```

- Sumar los números naturales del 1 al 5:

	```{r}
	suma <- 0
	for (i in 1:5) {
		suma <- suma + i
	}
	suma
	```

- Sumar números naturales hasta que la suma pase el valor 100 y detenerse:

	```{r}
	suma <- 0
	i <- 1
	while (suma < 100) {
		suma <-  suma + i
		i <- i + 1
	}
	suma
	```

- Escribir todos los múltiplos de 8 menores que 150:

	```
	ALGORITMO: "Múltiplos de 8 menores a 150"
	COMENZAR
		VARIABLE numérica multiplo
		multiplo <- 8
		MIENTRAS QUE multiplo < 150 HACER
			ESCRIBIR multiplo
			multiplo <- multiplo + 8
		FIN MIENTRAS
	FIN
	```
	
	```{r}
	# Programa: "Múltiplos de 8 menores a 150" ------------------------
	multiplo <- 8
	while (multiplo < 150) {
		print(multiplo)
		multiplo <- multiplo + 8
	}
	```
