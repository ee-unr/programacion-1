```{=latex}
\thispagestyle{primerapagina}
```

# completar

::: {.presentacion-capitulo data-latex=""}
COMPLETAR
:::

## El objeto `NULL`

Generalmente los lenguajes de programación poseen un elemento conocido como NULO, para representar un objeto vacío, sin información. En R, `NULL` representa la **ausencia total de un objeto** o valor. Es un objeto en sí mismo y no pertenece a ningún tipo de objeto básico (como numérico, lógico o carácter). Se usa para indicar que una variable o un elemento de una estructura de datos no existe. Suele ser usado como el objeto devuelto por funciones cuando no hay un resultado válido para retornar.

::: {.ejemplo data-latex=""}
Definimos una función para calcular el perímetro de un cuadrado en base a la longitud de uno de sus lados. Este cálculo sólo tiene sentido si el argumento `lado` es un valor positivo. Si no lo es, la función devuelve `NULL`.

```{r}
perimetro_cuadrado <- function(lado) {
  if (lado > 0) {
    return(lado * 4)
  } else {
    return(NULL)
  }
}

perimetro_cuadrado(10)
perimetro_cuadrado(-2)

# podemos guardar el resultado en una nueva variable
x <- perimetro_cuadrado(-2)
typeof(x)
is.numeric(x)
is.null(x)
```
:::

Hay funciones que devuelven el objeto `NULL` de forma invisible. Esto quiere decir que, si bien lo devuelven, no se imprime en la consola. Este es el caso de la función `cat()` que usamos para construir mensajes:

```{r}
nombre <- "Andrea"
# Esribe un mensaje, aparentemente no devuelve nada...
cat("Hola,", nombre)

# Asignamos su resultado a una variable:
resultado <- cat("Hola,", nombre)

# Imprimimos en la consola y nos encontramos que cat() devuelve NULL, 
# pero de forma invisible
resultado
```

Esto quiere decir que si definimos una función con el objetivo de generar un mensaje, podemos prescindir del uso de `return()` y la función devolverá de forma invisible el objeto `NULL`, aunque no lo notemos ni nos interese usarlo:

```{r}
saludar <- function(nombre) {
  cat("Hola,", nombre)
}

saludar("Andrea")
saludar("Gonzalo")
saludar("Lucía")
```

La mayoría de las funciones devuelven valores de forma **visible**: si se ejecutan en un entorno interactivo como la consola de R, el resultado se muestra automáticamente en pantalla. Este es el comportamiento por defecto de las funciones que escribimos. Recordemos la función `f`:

```{r}
f <- function(x, y) {
	resultado <- x^2 + 3 * y
	return(resultado)
}

f(4, 5)
```

Podemos "invisibilizar" el resultado devuelto por una función, así:

```{r}
f_invisible <- function(x, y) {
	resultado <- x^2 + 3 * y
	return(invisible(resultado))
}

f_invisible(4, 5)
```

La función devuelve un resultado, sólo que no se ve en la consola. Para usarlo, debemos guardarlo en una nueva variable:

```{r}
resultado <- f_invisible(4, 5)
resultado
```


```r
j03 <- function() 1
j03()
```

Sin embargo, se puede evitar la impresión automática aplicando `invisible()` al valor de retorno:  

```r
j04 <- function() invisible(1)
j04()
```
En R, existen otros valores especiales que representan diferentes tipos de información ausente, indefinida o nula. Aunque parezcan similares, tienen diferencias fundamentales en cuanto a su significado, uso y comportamiento en operaciones y no deben confundirse con el objeto `NULL`:

- `NA` son las siglas de *Not Available* y es un tipo especial valor de lógico que generalmente representa datos faltantes o desconocidos. No es un objeto en sí mismo. Propaga su presencia en operaciones matemáticas y lógicas, ya que cualquier operación con `NA` generalmente devuelve `NA`.
  
  ```{r}
  y <- 100
  z <- NA
  y + z
  ```
  
- `NaN` son las siglas de *Not a Number* y es un valor numérico que generalmente surge como resultado de operaciones aritméticas imposibles de calcular, como indeterminaciones, raíces negativas, etc.

  ```{r}
  0 / 0
  log(-1)
  sqrt(-1)
  ```


## Manejo de errores  


Si una función no puede completar su tarea, debe lanzar un error utilizando `stop()`, lo que interrumpe inmediatamente su ejecución:  

```r
j05 <- function() {
  stop("Soy un error")
  return(10)
}
j05()
```

Un error indica que algo salió mal y obliga al usuario a manejar la situación. En algunos lenguajes (como C, Go o Rust), los errores se indican mediante valores de retorno especiales, pero en R **siempre** se debe lanzar un error. Aprenderás más sobre los errores y cómo manejarlos en el capítulo \@ref(conditions).

## otros temas nombrados en IDEAS

## Modificar una variable global desde el cuerpo de una función en R (opcional)

Hemos dicho que una función recibe información desde el programa principal a través de sus parámetros, y envía información al mismo mediante el valor que devuelve. Sin embargo, es posible alterar el comportamiento para que sea capaz de producir efectos secundarios, por ejemplo, modificando el valor de una variable global, violando así el principio de transparencia referencial.

Los siguientes ejemplos definen dos funciones con un único argumento, `x`, pero que en su cuerpo hacen uso de una variable global, `y`, definida el algoritmo principal (estos casos violan el principio de transparencia referencial, su práctica no es recomendable). La diferencia entre ellas es que `g1()` modifica el valor de `y` dentro de la función, pero el valor de `y` en el ambiente global no es alterado; mientras que `g2()` cambia el valor de `y` no sólo localmente, sino también en el ambiente global. Esto se logra mediante el uso del operador `<<-`^[En realidad, el operador `<<-` trabaja de forma más compleja que lo mencionado en esta guía. En programas más elaborados de R, pueden haber ambientes anidados y este operador iniciará una búsqueda desde el ambiente actual hacia los superiores hasta encontrar una variable que se llame `y` para asignarle un valor. En este caso sencillo, sólo hay dos ambientes, el de la función `g2` y el global. Por lo tanto el operador `<<-` hace que se le asigne un valor a la variable `y` en el global.].

```{r}
# ---------------------------------------------------------------
# DEFINICIÓN DE FUNCIONES
# ---------------------------------------------------------------

g1 <- function(x) {
	y <- y + 100
	return(x / y)
}

g2 <- function(x) {
	y <<- y + 100
	return(x / y)
}

# ---------------------------------------------------------------
# PROGRAMA PRINCIPAL
# ---------------------------------------------------------------

# Caso 1: el valor de y en el ambiente global no es modificado por g1
x <- 500
y <- 50
z <- g1(x)
cat(x, y, z)

# Caso 2: el valor de y en el ambiente global es modificado por g2
x <- 500
y <- 50
z <- g2(x)
cat(x, y, z)
```

Nuevamente, esta forma de trabajo no es aconsejable porque estamos produciendo *efectos secundarios* desde la función en el ambiente global que pueden pasar desapercibidos si no estamos muy atentos. Así como la mejor práctica es pasar toda la información desde el programa principal hacia la función a través de sus parámetros, también es recomendable que toda comunicación desde la función hacia el programa principal se realice a través del valor (u objeto) que la función devuelve, sin producir efectos secundarios (transparencia referencial).


