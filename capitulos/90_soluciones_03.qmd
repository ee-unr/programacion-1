---
number-sections: false
---

```{=latex}
\thispagestyle{primerapagina}
```

# Soluciones de la Práctica de la Unidad 3

## Solución Ejercicio 1

En el script `funciones.R` se implementa la función `combinatorio(m,n)` y se guarda junto con `fact()`:

```{r}
#| results: hold

# ---------------------------------------------------------------
# DEFINICIÓN DE FUNCIONES (funciones.R)
# ---------------------------------------------------------------

#-----------------------------------------------------
# Función fact
# Calcula el factorial de números enteros no negativos
# Entrada:
#		- n, entero no negativo
# Salida:
#		- el factorial de n
#-----------------------------------------------------
fact <- function(n) {
	resultado <- 1
	if (n > 0) {
		for (i in 1:n) {
			resultado <- resultado * i
		}
	}
	return(resultado)
}

#-----------------------------------------------------
# Función combinatorio
# Calcula el número combinatorio m en n
# Entrada:
#		- m, n, números naturales
# Salida:
#		- el número combinatorio m en n
#-----------------------------------------------------
combinatorio <- function(m, n) {
	return(fact(m) / (fact(m - n) * fact(n)))
}
```

En un script aparte se cargan las funciones y se ejemplifican las propiedades de los números combinatorios:

```{r}
#| eval: false

# ---------------------------------------------------------------
# PROGRAMA PRINCIPAL: "Ejemplificar propiedades de los nros combinatorios"
# ---------------------------------------------------------------
source("funciones.R")

cat("Propiedad 1: C(m, 0) = 1. Ejemplo:\n")
res1 <- combinatorio(5, 0)
cat("C(5, 0) =", res1, "\n\n")

cat("Propiedad 2: C(m, m) = 1. Ejemplo:\n")
res1 <- combinatorio(5, 5)
cat("C(5, 5) =", res1, "\n\n")

cat("Propiedad 3: C(m, 1) = m. Ejemplo:\n")
res1 <- combinatorio(5, 1)
cat("C(5, 1) =", res1, "\n\n")

cat("Propiedad 4: C(m, n) = C(m, m-n). Ejemplo:\n")
res1 <- combinatorio(5, 2)
res2 <- combinatorio(5, 3)
cat("C(5, 2) =", res1, "\n")
cat("C(5, 3) =", res2, "\n\n")

cat("Propiedad 5: C(m, n) = C(m-1, n-1) + C(m-1, n). Ejemplo:\n")
res1 <- combinatorio(5, 2)
res2 <- combinatorio(4, 1) + combinatorio(4, 2)
cat("C(5, 2) =", res1, "\n")
cat("C(4, 1) + C(4, 2) =", res2)
```

```{r}
#| results: hold
#| echo: false

cat("Propiedad 1: C(m, 0) = 1. Ejemplo:\n")
res1 <- combinatorio(5, 0)
cat("C(5, 0) =", res1, "\n\n")

cat("Propiedad 2: C(m, m) = 1. Ejemplo:\n")
res1 <- combinatorio(5, 5)
cat("C(5, 5) =", res1, "\n\n")

cat("Propiedad 3: C(m, 1) = m. Ejemplo:\n")
res1 <- combinatorio(5, 1)
cat("C(5, 1) =", res1, "\n\n")

cat("Propiedad 4: C(m, n) = C(m, m-n). Ejemplo:\n")
res1 <- combinatorio(5, 2)
res2 <- combinatorio(5, 3)
cat("C(5, 2) =", res1, "\n")
cat("C(5, 3) =", res2, "\n\n")

cat("Propiedad 5: C(m, n) = C(m-1, n-1) + C(m-1, n). Ejemplo:\n")
res1 <- combinatorio(5, 2)
res2 <- combinatorio(4, 1) + combinatorio(4, 2)
cat("C(5, 2) =", res1, "\n")
cat("C(4, 1) + C(4, 2) =", res2)
```

A continuación, se prueba pasando un valor de `n` mayor que `m`:

```{r}
combinatorio(4, 5)
```

Como se observa, la función no falla pero devuelve un valor que no tiene sentido. Esto ocurre porque ninguna de las dos funciones tiene un criterio de parada, y `fact()` devuelve 1 siempre que `n <= 0`.

De forma ingenua, se podría pensar que es bueno que la función no devuelva un error. Sin embargo, esto es muy peligroso porque favorece a que el error pase desapercibido y se propague en un cálculo más extenso, conduciendo a resultados incorrectos. Al ser silenciosa (no emitir ningún mensaje), se puede perder mucho tiempo buscando el error hasta dar con la función que causa el problema.


## Solución Ejercicio 2

Se generaliza la función `combinatorio(m, n)` para calcular números combinatorios con y sin reposición. Para esto se incluye el argumento `r`, que toma el valor lógico `TRUE` si el cálculo es con reposición o `FALSE` en caso contrario.

```{r}
#| results: hold

#-----------------------------------------------------
# Función combinatorio2
# Calcula el número combinatorio m en n, con o sin reposición según r
# Entrada:
#   - m, n, números naturales
#   - r, valor lógico (FALSE, por defecto)
# Salida:
#   - el número combinatorio m en n, con o sin reposición
#-----------------------------------------------------
combinatorio2 <- function(m, n, r = FALSE) {
  if (r) {
    combinatorio(m + n - 1, n)
  } else {
    combinatorio(m, n)
  }
}

# ---------------------------------------------------------------
# PROGRAMA PRINCIPAL: "Números combinatorios con y sin reposición"
# ---------------------------------------------------------------
m <- 5
n <- 2
cat(m, "tomados de a", n, "sin resposición:", combinatorio2(m, n), "\n")
cat(m, "tomados de a", n, "con resposición:", combinatorio2(m, n, TRUE))
```

La cantidad de combinaciones con reposición siempre es mayor, salvo para `n = 1` donde ambas coinciden.

## Solución Ejercicio 3

```{r}
#-----------------------------------------------------
# Función triangulos
# Clasifica un triángulo según la longitud de sus lados
# Entrada:
#		- a, b, c, números reales positivos
# Salida:
#		- valor carácter que indica el tipo de triángulo
#-----------------------------------------------------
triangulos <- function(a, b, c) {
	if (a > b + c || b > a + c || c > a + b) {
		return("no es triángulo")
	} else if (a == b & a == c) {
		return("equilátero")
	} else if (a == b || a == c || b == c) {
		return("isósceles")
	} else {
		return("escaleno")
	}
}
```

Alternativamente, podemos prescindir de las estructuras anidadas, gracias a la existencia de las sentencias `return` en cada camino posible. Si alguna condición es `TRUE`, enseguida se devuelve el valor que corresponda y se detiene la ejecución de la función. El resto no se evalúa, lo cual hace innecesario usar `else if` o estructuras anidadas:

```{r}
#-----------------------------------------------------
# Función triangulos
# Clasifica un triángulo según la longitud de sus lados
# Entrada:
#		- a, b, c, números reales positivos
# Salida:
#		- valor carácter que indica el tipo de triángulo
#-----------------------------------------------------
triangulos <- function(a, b, c) {
	if (a > b + c || b > a + c || c > a + b) return("no es triángulo")
	if (a == b & a == c) return("equilátero")
	if (a == b || a == c || b == c) return("isósceles")
	return("escaleno")
}
```

Notar que cuando el bloque de acciones luego de un `if` está compuesto por una única acción, se pueden omitir las llaves `{}` y escribir la acción en la misma línea.

Ejemplos de uso:

```{r}
triangulos(2, 3, 4)
triangulos(2, 3, 10)
```


## Solución Ejercicio 4

```{r}
#-----------------------------------------------------
# Función elipse
# Determina si un punto está contenido dentro de la elipse definida por la
# fórmula (x - 6)^2 / 36 + (y + 4)^2 / 16 = 1
# Entrada:
#		- x, y, coordenadas del punto
# Salida:
#		- Valor lógico TRUE o FALSE
#-----------------------------------------------------
elipse <- function(x, y) {
	return((x - 6)^2 / 36 + (y + 4)^2 / 16 <= 1)
}
```

Ejemplos de uso:

```{r}
elipse(3, 7)
elipse(6, -4)
```


## Solución Ejercicio 5

a. Paso a paso:

    1. En el ambiente global primero se definen las funciones `f` y `g` y las variables globales `a` y `b`, con los valores 6 y 1, respectivamente.
    2. Se invoca `g(a, b)`, resultando en que en el ambiente local de `g`, `x` recibe el valor 6 e `y` el valor 1.
    3. En el ambiente local de `g` se crea la variable local `b`, con valor `6 - 2 * 1 = 4`.
    4. Desde el ambiente local de `g` se invoca `f(b)`, donde `b` vale `4`.
    5. En el ambiente local de `f`, `a` recibe el valor 4, el cual es actualizado por `(4-10)*(4+10)=-84` para finalmente devolver `-84`.
    6. De regreso en el ambiente local de `g`, la variable `c` recibe el valor `b*f(b)=4*f(4)=4*(-84)=-336` y se devuelve `-336`.
    7. Para definir la variable `d` se vuelve a invocar `f` esta vez sin argumentos explícitos, por lo que en el ambiente local de `f`, `a` recibe el valor 10 y `f() = 0`. El valor final de `d` es `f() - c = 0 - (-336) = 336`.
    8. En el programa principal entonces el resultado de `g(a, b)` es `336`.

b. En este ejemplo, el identificador `a` representa dos variables distintas: una de ellas definida en el ámbito global del algoritmo y la otra en el ámbito local de la función `f1`. Lo mismo ocurre con `x`: representa a una variable en el ambiente global del algoritmo, a otra en el ambiente de la función `f1` y a una tercera en el ambiente de la función `f2`. Al ejecutar el algoritmo se obtendrían los siguientes resultados:

    1. En el ambiente global, se definen las funciones `f1` y `f2` y las variables `x` e `y` con valores: `x = 3` e `y = 5`.
    2. Desde el algoritmo, se invoca a la función `f1`, donde el parámetro formal `a` recibe el valor del parámetro real `x` (`a = 3`), mientras que el parámetro formal `b` recibe el valor del parámetro real `y` (`b = 5`). Dentro de la función `f1`:
        a. Se crea una nueva variable `x` que recibe el valor `x = a + b = 8`. Esta `x` no tiene nada que ver con la del ambiente global.
        b. Se crea una nueva variable `y` que recibe el valor `y = x + 2 = 8 + 2 = 10`. Esta `y` no tiene nada que ver con la del ambiente global.
        c. La función devuelve el valor `y = 10`.
    4. En el ambiente global, se le asigna a la variable `a` el valor recién devuelto: `a = 10`. Esta `a` no tiene nada que ver con la variable local de la función `f1`.
    5. Desde el algoritmo, se llama a la función `f2`, donde el parámetro formal `x` recibe el valor del parámetro real `a` (`x = 10`). Esta `x` no tiene nada que ver con las anteriores. Dentro de la función `f2`:
        a. Se calcula el cuadrado de `x`: $10^2$ = 100
        b. Se devuelve el valor `100`.
    7. En el ambiente global, se suma `x + f2(a) = 3 + 100 = 103` y se asigna este valor a `z`.
    8. El algoritmo escribe el valor de `z`, 103.
    9. El algoritmo intenta escribir `a + b = 10 + ?`, pero produce error, puesto que `b` no está definida en el algoritmo principal, no tiene asignado ningún valor. La única variable `b` que existe está en el ámbito de la función `f1`, no del algoritmmo.
	
   En R, el ejemplo anterior se traduce en:


   ```{r}
   #| error: true 
   
   # ---------------------------------------------------------------
   # DEFINICIÓN DE FUNCIONES
   # ---------------------------------------------------------------
   
   f1 <- function(a, b) {
   	x <- a + b
   	y <- x + 2
   	return(y)
   }
   
   f2 <- function(x) {
   	return(x^2)
   }
   
   # ---------------------------------------------------------------
   # PROGRAMA PRINCIPAL
   # ---------------------------------------------------------------
   
   x <- 3
   y <- 5
   a <- f1(x, y)
   z <- x + f2(a)
   z
   a + b
   ```
	 
c. Primero, en el ambiente global se define la función `f` con tres argumentos: `x` (sin valor por defecto), `y` y `z` (opcionales). La función devuelve una combinación lineal de estas tres cantidades. En segundo lugar, se invoca sucesivamente la función `f` para definir cuatro variables globales en el siguiente orden:
    1. `a = f(10) = f(10, 5, 10 + 5) = (10+5) - 10 - 5 = 0`
    2. `b = f(10, 10) = f(10, 10, 10 + 10) = (10+10) - 10 - 10 = 0`
    3. `c = f(10, 10, 10) = 10 - 10 - 10 = -10`
    4. `d = f(10, z = 10) = f(10, 5, 10) = 10 - 10 - 5 = -5`
    
   Finalmente, se imprime el resultado de sumar las cuatro cantidades: `0 + 0 - 10 - 5 = -15`


## Solución Ejercicio 6

Hemos definido a las funciones como subalgoritmos que devuelven un objeto. En este caso no nos interesa devolver nada, por eso podemos incluir `return(NULL)` para cumplir con la definición y marcar la finalización de la ejecución de la función. Sin embargo, si obviamos esta instrucción, lo último que hace la función será emitir uno de los mensajes con `cat()`^[Y aunque no se note, la función igualmente devuelve un objeto. Además de escribir un mensaje, `cat()` devuelve `NULL` de forma invisible. Como lo último que se hace es un llamado a `cat()`, la función cumple con devolver un objeto (`NULL`). Esto puede parecer raro ahora y no importa si no lo llegamos a apreciar.]:

```{r}
#-----------------------------------------------------
# Función resolvente
# Resuelve una ecuación de segundo grado
# Entrada:
#		- a, b, c, coeficientes reales de la ecuación de segundo grado
# Salida:
#		- mensajes en pantalla
#-----------------------------------------------------
resolvente <- function(a, b, c) {
  if (a == 0) {
    stop("(a) debe ser distinto de cero")
  }
	discriminante <- b^2 - 4 * a * c
	if (discriminante > 0) {
		x1 <- (-b - sqrt(discriminante)) / (2 * a)
		x2 <- (-b + sqrt(discriminante)) / (2 * a)
		cat("Hay dos soluciones reales", x1, "y", x2, "\n")
	} else if (discriminante == 0) {
		x1 <- -b / (2 * a)
		cat("Hay una solución real doble:", x1, "\n")
	} else {
		cat("Las soluciones son complejas\n")
	}
}
```

Ejemplo de uso:

```{r}
#| error: true

resolvente(1, -1, -2)
resolvente(1, 2, 1)
resolvente(1, 1, 1)
resolvente(0, 1, 1)
```

Sería interesante en esta función que pueda devolver las respuestas. Hasta acá sabemos que las funciones pueden devolver un único valor. Esto puede ser un inconveniente para este problema, ya que nos puede interesar devolver dos valores (dos soluciones reales), un valor (una solución real doble) o ningún valor (ninguna solución real). Más adelante veremos cómo hacer para poder devolver distinta cantidad de respuestas.


## Solución Ejercicio 7

**Parte a)**

La solución propone devolver `TRUE` si el número analizado es 2 o 3, ya que sabemos que estos primeros naturales son primos. Para el resto de los números, divide a `n` por todos los naturales desde el 2 hasta `n - 1`. Si al hacer esta división, encuentra un resto igual a cero, significa que `n` es compuesto. Si ninguna división produce resto cero, entonces `n` es primo. 

Por ejemplo, para `n = 7`, se hace:

- 7 MOD 2 = 1, sigue.
- 7 MOD 3 = 1, sigue.
- 7 MOD 4 = 3, sigue.
- 7 MOD 5 = 2, sigue.
- 7 MOD 6 = 1, termina la iteración.
- Dado que no se encontraron divisores para 7, es un número primo, se devuelve VERDADERO.

Para `n = 9`, se hace:

- 9 MOD 2 = 1, sigue.
- 9 MOD 3 = 0, devuelve FALSO.
- Dado que se encontró que 9 es múltiplo de 3, no es un número primo y se devolvió FALSO.

Notar que no hace falta usar `else if` o `else` después de evaluar si `n` es igual a 2, porque si lo es, se termina allí la ejecución de la función.

```{r}
#-----------------------------------------------------
# Función es_primo
# Determina si un número natural es primo o no
# Entrada:
#		- n, número natural mayor que 1
# Salida:
#		- Valor lógico TRUE si n es primo o FALSE si es compuesto
#-----------------------------------------------------
es_primo <- function(n) {
	if (n > 3) {
		for (i in 2:(n - 1)) {
			if (n %% i == 0) {
				return(FALSE)
			}
		}
	}
	return(TRUE)
}
```

Ejemplos de uso:

```{r}
es_primo(47)
es_primo(253)
es_primo(2)
```

**Observación**: se puede plantear un algoritmo más eficiente, que realice menos iteraciones. No es necesario iterar hasta `n - 1`, si no hasta el entero inmediato menor a $\sqrt{n}$. Si no se encontró que `n` sea múltiplo de ningún valor menor a $\sqrt{n}$, tampoco lo será con los que siguen. Por otro lado, sería suficiente hacer las divisiones con respecto a los números primos de `n`.

**Parte b)**

Se vuelve a implementar la función `es_primo(n)`, pero esta vez verificando el argumento de entrada y devolviendo el resultado correcto para cualquier `n`:

```{r}
#-----------------------------------------------------
# Función es_primo
# Determina si un número es primo
# Entrada:
#		- n, número real
# Salida:
#		- Valor lógico TRUE si n es primo o FALSE si es compuesto
#-----------------------------------------------------
es_primo <- function(n) {
  if (n %% 1 != 0) {
    warning("(n) no es entero")
    return(FALSE)
  }
  
  if (n <= 1) {
    warning("(n) no es mayor a 1")
    return(FALSE)
  }
  
	if (n > 3) {
		for (i in 2:(n - 1)) {
			if (n %% i == 0) {
				return(FALSE)
			}
		}
	}
	return(TRUE)
}
```

Ejemplos de uso:

```{r}
es_primo(7.18)
es_primo(0)
```


## Solución Ejercicio 8

Para poder resolver una división usando solamente sumas y restas, tenemos que pensar que, por ejemplo, hacer 14 dividido 3 nos da cociente 4 y resto 2, porque el 3 "entra" 4 veces en el 14 y todavía sobran 2. Es decir, a 14 le podemos restar el 3 cuatro veces hasta que ya no se lo podamos restar más, quedando un resto de 2. Entonces la idea es empezar diciendo que el *resto* es el dividendo (al principio, nos *resta* todo el dividendo) y restarle iterativamente el valor del divisor hasta que el resto se haga menor que el divisor. Mientras tanto, tenemos que ir contando cuántas restas se hacen, puesto que eso será el valor del cociente. Ejemplo:

- dividendo = 14, divisor = 3, resto = 14
- 14 - 3 = 11, digo que el resto es 11 y cuento que ya hice una resta con cociente = 1.
- 11 - 3 = 8, digo que el resto es 8 y cuento que ya hice dos restas con cociente = 2.
- 8 - 3 = 5, digo que el resto es 5 y cuento que ya hice tres restas con cociente = 3.
- 5 - 3 = 2, digo que el resto es 2, cuento que ya hice cuatro restas con cociente = 4.
- Como ya obtuve un resto menor que el divisor, me detengo, con este resultado: cociente = 4 y resto = 2.

Como a priori no sabemos cuántas iteraciones de este proceso tenemos que hacer, empleamos un `while`.

```{r}
#-----------------------------------------------------
# Función cociente
# Obtiene cociente entero y resto en la división de dos números naturales
# Entrada:
#		- dividendo, divisor, números naturales
# Salida:
#		- Escribe en pantalla dividendo, divisor, cociente y resto
#		- Devuelve el valor del cociente
#-----------------------------------------------------
cociente <- function(dividendo, divisor) {
	resto <- dividendo
	cociente <- 0
	while (resto >= divisor) {
		cociente <- cociente + 1
		resto <- resto - divisor
	}
	cat("Dividendo:", dividendo, "\n")
	cat("Divisor:", divisor, "\n")
	cat("Cociente:", cociente, "\n")
	cat("Resto:", resto, "\n")
	return(cociente)
}
```

Ejemplos de uso:

```{r}
cociente(1253, 4)
cociente(3, 4)
```

## Solución Ejercicio 9

```{r}
#-----------------------------------------------------
# Función max_com_div
# Calcula el máximo común divisor de dos números naturales
# Entrada:
#		- a, b, números naturales
# Salida:
#		- El máximo común divisor de a y b
#-----------------------------------------------------
max_com_div <- function(a, b) {
	# Establecer como dividendo al mayor y como divisor al menor
	if (a > b) {
		dividendo <- a
		divisor <- b
	} else {
		dividendo <- b
		divisor <- a
	}
	# Iniciar al resto como igual al dividendo
	resto <- dividendo
	# Aplicar algortimo de Euclides
	while (resto != 0) {
		resto <- dividendo %% divisor
		mcd <- divisor
		dividendo <- divisor
		divisor <- resto
	}
	return(mcd)
}
```

Ejemplos de uso:

```{r}
max_com_div(100, 24)
max_com_div(25, 100)
max_com_div(24, 24)
```

Otra forma:

```{r}
max_com_div <- function(a, b) {
	# Establecer como dividendo al mayor y como divisor al menor
	if (a > b) {
		dividendo <- a
		divisor <- b
	} else {
		dividendo <- b
		divisor <- a
	}
	# Iniciar al resto como igual al dividendo
	resto <- dividendo
	# Aplicar algortimo de Euclides
	while (resto > 0) {
		resto <- dividendo %% divisor
		if (resto == 0) return(divisor)
		dividendo <- divisor
		divisor <- resto
	}
}
```
