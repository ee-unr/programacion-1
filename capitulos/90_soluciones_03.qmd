---
number-sections: false
---

```{=latex}
\thispagestyle{primerapagina}
```

# Soluciones de la Práctica de la Unidad 3

## Solución Ejercicio 1

```{r}
#| results: hold

# ---------------------------------------------------------------
# DEFINICIÓN DE FUNCIONES
# ---------------------------------------------------------------

#-----------------------------------------------------
# Función fact
# Calcula el factorial de números enteros no negativos
# Entrada:
#		- n, entero no negativo
# Salida:
#		- el factorial de n
#-----------------------------------------------------
fact <- function(n) {
	resultado <- 1
	if (n > 0) {
		for (i in 1:n) {
			resultado <- resultado * i
		}
	}
	return(resultado)
}

#-----------------------------------------------------
# Función combinatorio
# Calcula el número combinatorio m en n
# Entrada:
#		- m, n, números naturales
# Salida:
#		- el número combinatorio m en n
#-----------------------------------------------------
combinatorio <- function(m, n) {
	if (n > m) {
		cat("m debe ser mayor o igual a n\n")
		return(NULL)
	} else {
		return(fact(m) / (fact(m - n) * fact(n)))
	}
}

# ---------------------------------------------------------------
# PROGRAMA PRINCIPAL: "Ejemplificar propiedades de los nros combinatorios"
# ---------------------------------------------------------------

cat("Propiedad 1: C(m, 0) = 1. Ejemplo:\n")
res1 <- combinatorio(5, 0)
cat("C(5, 0) =", res1, "\n\n")

cat("Propiedad 2: C(m, m) = 1. Ejemplo:\n")
res1 <- combinatorio(5, 5)
cat("C(5, 5) =", res1, "\n\n")

cat("Propiedad 3: C(m, 1) = m. Ejemplo:\n")
res1 <- combinatorio(5, 1)
cat("C(5, 1) =", res1, "\n\n")

cat("Propiedad 4: C(m, n) = C(m, m-n). Ejemplo:\n")
res1 <- combinatorio(5, 2)
res2 <- combinatorio(5, 3)
cat("C(5, 2) =", res1, "\n")
cat("C(5, 3) =", res2, "\n\n")

cat("Propiedad 5: C(m, n) = C(m-1, n-1) + C(m-1, n). Ejemplo:\n")
res1 <- combinatorio(5, 2)
res2 <- combinatorio(4, 1) + combinatorio(4, 2)
cat("C(5, 2) =", res1, "\n")
cat("C(4, 1) + C(4, 2) =", res2)
```


**Observación 1**. La siguiente formulación es equivalente, ya que la ejecución de una sentencia `return` termina inmediatamente la evaluación de la función:

```{r, eval=FALSE}
combinatorio <- function(m, n) {
	if (n > m) {
		cat("m debe ser mayor o igual a n\n")
		return(NULL)
	}
	return(fact(m) / (fact(m - n) * fact(n)))
}
```

**Observación 2**. R ya trae una función para el cálculo de factoriales: `factorial()`. Se puede comparar el resultado obtenido con la función que creamos nosotros y la que ya está implementada en R. Como ya mencionamos, para practicar y aprender en algunos casos estamos creando nuestras propias versiones de funciones que ya existen en R.

## Solución Ejercicio 2

Generalizamos la función `combinatorio()` para que se adapte a los dos posibles casos, con reposición y sin reposición. Para esto debemos agregar un argumento `r`, que indique si el cálculo del combinatorio debe ser con (`TRUE`) o sin (`FALSE`) repetición. Su valor por defecto será `FALSE`. 

Utilizaremos la versión anterior para simplificar cálculos

```{r}
#-----------------------------------------------------
# Función combinatorio2
# Calcula el número combinatorio m en n, con o sin reposición dependiendo 
# del valor del argumento r 
# Entrada:
#		- m, n, números naturales
#   - r, valor lógico
# Salida:
#		- el número combinatorio m en n, con o sin reposición
#-----------------------------------------------------
combinatorio2 <- function(m, n, r = FALSE) {
  if (r) {
    combinatorio(m+n-1, n)
  } else {
    combinatorio(m, n)
  }
}

# ---------------------------------------------------------------
# PROGRAMA PRINCIPAL: "Ejemplos de combinatorio2, con y sin reposición"
# ---------------------------------------------------------------
combinatorio2(5, 2)
combinatorio2(5, 2, T)
combinatorio2(5, 2, F)

```


## Solución Ejercicio 3

```{r}
#-----------------------------------------------------
# Función triangulos
# Clasifica un triángulo según la longitud de sus lados
# Entrada:
#		- a, b, c, números reales positivos
# Salida:
#		- valor carácter que indica el tipo de triángulo
#-----------------------------------------------------
triangulos <- function(a, b, c) {
	if (a > b + c || b > a + c || c > a + b) {
		return("no es triángulo")
	} else if (a == b & a == c) {
		return("equilátero")
	} else if (a == b || a == c || b == c) {
		return("isósceles")
	} else {
		return("escaleno")
	}
}
```

Alternativamente, podemos prescindir de las estructuras anidadas, gracias a la existencia de las sentencias `return` en cada camino posible. Si alguna condición es `TRUE`, enseguida se devuelve el valor que corresponda y se detiene la ejecución de la función. El resto no se evalúa, lo cual hace innecesario usar `else if` o estructuras anidadas:

```{r}
#-----------------------------------------------------
# Función triangulos
# Clasifica un triángulo según la longitud de sus lados
# Entrada:
#		- a, b, c, números reales positivos
# Salida:
#		- valor carácter que indica el tipo de triángulo
#-----------------------------------------------------
triangulos <- function(a, b, c) {
	if (a > b + c || b > a + c || c > a + b) return("no es triángulo")
	if (a == b & a == c) return("equilátero")
	if (a == b || a == c || b == c) return("isósceles")
	return("escaleno")
}
```

Notar que cuando el bloque de acciones luego de un `if` está compuesto por una única acción, se pueden omitir las llaves `{}` y escribir la acción en la misma línea.

Ejemplos de uso:

```{r}
triangulos(2, 3, 4)
triangulos(2, 3, 10)
```

## Solución Ejercicio 4

Hemos definido a las funciones como subalgoritmos que devuelven un objeto. En este caso no nos interesa devolver nada, por eso podemos incluir `return(NULL)` para cumplir con la definición y marcar la finalización de la ejecución de la función. Sin embargo, si obviamos esta instrucción, lo último que hace la función será emitir uno de los mensajes con `cat()`^[Y aunque no se note, la función igualmente devuelve un objeto. Además de escribir un mensaje, `cat()` devuelve `NULL` de forma invisible. Como lo último que se hace es un llamado a `cat()`, la función cumple con devolver un objeto (`NULL`). Esto puede parecer raro ahora y no importa si no lo llegamos a apreciar.]:

```{r}
#-----------------------------------------------------
# Función resolvente
# Resuelve una ecuación de segundo grado
# Entrada:
#		- a, b, c, coeficientes reales de la ecuación de segundo grado
# Salida:
#		- mensajes en pantalla
#-----------------------------------------------------
resolvente <- function(a, b, c) {
	discriminante <- b^2 - 4 * a * c
	if (discriminante > 0) {
		x1 <- (-b - sqrt(discriminante)) / (2 * a)
		x2 <- (-b + sqrt(discriminante)) / (2 * a)
		cat("Hay dos soluciones reales", x1, "y", x2, "\n")
	} else if (discriminante == 0) {
		x1 <- -b / (2 * a)
		cat("Hay una solución real doble:", x1, "\n")
	} else {
		cat("Las soluciones son complejas\n")
	}
}
```

Ejemplo de uso:

```{r}
resolvente(1, -1, -2)
resolvente(1, 2, 1)
resolvente(1, 1, 1)
```

Sería interesante en esta función que pueda devolver las respuestas. Hasta acá sabemos que las funciones pueden devolver un único valor. Esto puede ser un inconveniente para este problema, ya que nos puede interesar devolver dos valores (dos soluciones reales), un valor (una solución real doble) o ningún valor (ninguna solución real). Más adelante veremos cómo hacer para poder devolver distinta cantidad de respuestas.

## Solución Ejercicio 5

```{r}
#-----------------------------------------------------
# Función elipse
# Determina si un punto está contenido dentro de la elipse definida por la
# fórmula (x - 6)^2 / 36 + (y + 4)^2 / 16 = 1
# Entrada:
#		- x, y, coordenadas del punto
# Salida:
#		- Valor lógico TRUE o FALSE
#-----------------------------------------------------
elipse <- function(x, y) {
	return((x - 6)^2 / 36 + (y + 4)^2 / 16 <= 1)
}
```

Ejemplos de uso:

```{r}
elipse(3, 7)
elipse(6, -4)
```

## Solución Ejercicio 6

a. Paso a paso:

    1. En el ambiente global primero se definen las funciones `f` y `g` y las variables globales `a` y `b`, con los valores 6 y 1, respectivamente.
    2. Se invoca `g(a, b)`, resultando en que en el ambiente local de `g`, `x` recibe el valor 6 e `y` el valor 1.
    3. En el ambiente local de `g` se crea la variable local `b`, con valor `6 - 2 * 1=4`.
    4. Desde el ambiente local de `g` se invoca `f(b)`, donde `b` vale `4`.
    5. En el ambiente local de `f`, `a` recibe el valor 4, el cual es actualizado por `(4-10)*(4+10)=-84` para finalmente devolver `-84`.
    6. De regreso en el ambiente local de `g`, la variable `c` recibe el valor `b*f(b)=4*f(4)=4*(-84)=-336` y se devuelve `-336`.
    7. En el programa principal entonces el resultado de `g(a, b)` es `-336`.

b. En este ejemplo, el identificador `a` representa dos variables distintas: una de ellas definida en el ámbito global del algoritmo y la otra en el ámbito local de la función `f1`. Lo mismo ocurre con `x`: representa a una variable en el ambiente global del algoritmo, a otra en el ambiente de la función `f1` y a una tercera en el ambiente de la función `f2`. Al ejecutar el algoritmo se obtendrían los siguientes resultados:

    1. En el ambiente global, se definen las funciones `f1` y `f2` y las variables `x` e `y` con valores: `x = 3` e `y = 5`.
    2. Desde el algoritmo, se invoca a la función `f1`, donde el parámetro formal `a` recibe el valor del parámetro real `x` (`a = 3`), mientras que el parámetro formal `b` recibe el valor del parámetro real `y` (`b = 5`). Dentro de la función `f1`:
        a. Se crea una nueva variable `x` que recibe el valor `x = a + b = 8`. Esta `x` no tiene nada que ver con la del ambiente global.
        b. Se crea una nueva variable `y` que recibe el valor `y = x + 2 = 8 + 2 = 10`. Esta `y` no tiene nada que ver con la del ambiente global.
        c. La función devuelve el valor `y = 10`.
    4. En el ambiente global, se le asigna a la variable `a` el valor recién devuelto: `a = 10`. Esta `a` no tiene nada que ver con la variable local de la función `f1`.
    5. Desde el algoritmo, se llama a la función `f2`, donde el parámetro formal `x` recibe el valor del parámetro real `a` (`x = 10`). Esta `x` no tiene nada que ver con las anteriores. Dentro de la función `f2`:
        a. Se calcula el cuadrado de `x`: $10^2$ = 100
        b. Se devuelve el valor `100`.
    7. En el ambiente global, se suma `x + f2(a) = 3 + 100 = 103` y se asigna este valor a `z`.
    8. El algoritmo escribe el valor de `z`, 103.
    9. El algoritmo intenta escribir `a + b = 10 + ?`, pero produce error, puesto que `b` no está definida en el algoritmo principal, no tiene asignado ningún valor. La única variable `b` que existe está en el ámbito de la función `f1`, no del algoritmmo.
	
   En R, el ejemplo anterior se traduce en:


   ```{r}
   #| error: true 
   
   # ---------------------------------------------------------------
   # DEFINICIÓN DE FUNCIONES
   # ---------------------------------------------------------------
   
   f1 <- function(a, b) {
   	x <- a + b
   	y <- x + 2
   	return(y)
   }
   
   f2 <- function(x) {
   	return(x^2)
   }
   
   # ---------------------------------------------------------------
   # PROGRAMA PRINCIPAL
   # ---------------------------------------------------------------
   
   x <- 3
   y <- 5
   a <- f1(x, y)
   z <- x + f2(a)
   z
   a + b
   ```
	 
c. Primero, en el ambiente global se define la función `f` con tres argumentos: `x` (sin valor por defecto), `y` y `z` (opcionales). La función devuelve una combinación lineal de estas tres variables locales. En segundo lugar, se invoca la función sucesivamente para definir variables globales en el siguiente order:
    1. `a = f(10) = f(10, 5, 10 + 5) = (10+5) - 10 - 5 = 0`
    2. `b = f(10, 10) = f(10, 10, 10 + 10) = (10+10) - 10 - 10 = 0`
    3. `c = f(10, 10, 10) = 10 - 10 - 10 = -10`
    4. `d = f(10, z = 10) = f(10, 5, 10) = 10 - 10 - 5 = -5`
    
   Finalmente, se imprime el resultado de sumar las cuatro cantidades: `0 + 0 - 10 - 5 = -15`


## Solución Ejercicio 7

La solución propone devolver `TRUE` si el número analizado es 2 o 3, ya que sabemos que estos primeros naturales son primos. Para el resto de los números, divide a `n` por todos los naturales desde el 2 hasta `n - 1`. Si al hacer esta división, encuentra un resto igual a cero, significa que `n` es compuesto. Si ninguna división produce resto cero, entonces `n` es primo. 

Por ejemplo, para `n = 7`, se hace:

- 7 MOD 2 = 1, sigue.
- 7 MOD 3 = 1, sigue.
- 7 MOD 4 = 3, sigue.
- 7 MOD 5 = 2, sigue.
- 7 MOD 6 = 1, termina la iteración.
- Dado que no se encontraron divisores para 7, es un número primo, se devuelve VERDADERO.

Para `n = 9`, se hace:

- 9 MOD 2 = 1, sigue.
- 9 MOD 3 = 0, devuelve FALSO.
- Dado que se encontró que 9 es múltiplo de 3, no es un número primo y se devolvió FALSO.

Notar que no hace falta usar `else if` o `else` después de evaluar si `n` es igual a 2, porque si lo es, se termina allí la ejecución de la función.

```{r}
#-----------------------------------------------------
# Función es_primo
# Determina si un número natural es primo o no
# Entrada:
#		- n, número natural mayor que 1
# Salida:
#		- Valor lógico TRUE si es n es primo o FALSE si es compuesto
#-----------------------------------------------------
es_primo <- function(n) {
	if (n > 3) {
		for (i in 2:(n - 1)) {
			if (n %% i == 0) {
				return(FALSE)
			}
		}
	}
	return(TRUE)
}
```

Ejemplos de uso:

```{r}
es_primo(47)
es_primo(253)
es_primo(2)
```

**Observación**: se puede plantear un algoritmo más eficiente, que realice menos iteraciones. No es necesario iterar hasta `n - 1`, si no hasta el entero inmediato menor a $\sqrt{n}$. Si no se encontró que `n` sea múltiplo de ningún valor menor a $\sqrt{n}$, tampoco lo será con los que siguen. Por otro lado, sería suficiente hacer las divisiones con respecto a los números primos de `n`.

## Solución Ejercicio 8

Para poder resolver una división usando solamente sumas y restas, tenemos que pensar que, por ejemplo, hacer 14 dividido 3 nos da cociente 4 y resto 2, porque el 3 "entra" 4 veces en el 14 y todavía sobran 2. Es decir, a 14 le podemos restar el 3 cuatro veces hasta que ya no se lo podamos restar más, quedando un resto de 2. Entonces la idea es empezar diciendo que el *resto* es el dividendo (al principio, nos *resta* todo el dividendo) y restarle iterativamente el valor del divisor hasta que el resto se haga menor que el divisor. Mientras tanto, tenemos que ir contando cuántas restas se hacen, puesto que eso será el valor del cociente. Ejemplo:

- dividendo = 14, divisor = 3, resto = 14
- 14 - 3 = 11, digo que el resto es 11 y cuento que ya hice una resta con cociente = 1.
- 11 - 3 = 8, digo que el resto es 8 y cuento que ya hice dos restas con cociente = 2.
- 8 - 3 = 5, digo que el resto es 5 y cuento que ya hice tres restas con cociente = 3.
- 5 - 3 = 2, digo que el resto es 2, cuento que ya hice cuatro restas con cociente = 4.
- Como ya obtuve un resto menor que el divisor, me detengo, con este resultado: cociente = 4 y resto = 2.

Como a priori no sabemos cuántas iteraciones de este proceso tenemos que hacer, empleamos un `while`.

```{r}
#-----------------------------------------------------
# Función cociente
# Obtiene cociente entero y resto en la división de dos números naturales
# Entrada:
#		- dividendo, divisor, números naturales
# Salida:
#		- Escribe en pantalla dividendo, divisor, cociente y resto
#		- Devuelve el valor del cociente
#-----------------------------------------------------
cociente <- function(dividendo, divisor) {
	resto <- dividendo
	cociente <- 0
	while (resto >= divisor) {
		cociente <- cociente + 1
		resto <- resto - divisor
	}
	cat("Dividendo:", dividendo, "\n")
	cat("Divisor:", divisor, "\n")
	cat("Cociente:", cociente, "\n")
	cat("Resto:", resto, "\n")
	return(cociente)
}
```

Ejemplos de uso:

```{r}
cociente(1253, 4)
cociente(3, 4)
```

## Solución Ejercicio 9

```{r}
#-----------------------------------------------------
# Función max_com_div
# Calcula el máximo común divisor de dos números naturales
# Entrada:
#		- a, b, números naturales
# Salida:
#		- El máximo común divisor de a y b
#-----------------------------------------------------
max_com_div <- function(a, b) {
	# Establecer como dividendo al mayor y como divisor al menor
	if (a > b) {
		dividendo <- a
		divisor <- b
	} else {
		dividendo <- b
		divisor <- a
	}
	# Iniciar al resto como igual al dividendo
	resto <- dividendo
	# Aplicar algortimo de Euclides
	while (resto != 0) {
		resto <- dividendo %% divisor
		mcd <- divisor
		dividendo <- divisor
		divisor <- resto
	}
	return(mcd)
}
```

Ejemplos de uso:

```{r}
max_com_div(100, 24)
max_com_div(25, 100)
max_com_div(24, 24)
```

Otra forma:

```{r}
max_com_div <- function(a, b) {
	# Establecer como dividendo al mayor y como divisor al menor
	if (a > b) {
		dividendo <- a
		divisor <- b
	} else {
		dividendo <- b
		divisor <- a
	}
	# Iniciar al resto como igual al dividendo
	resto <- dividendo
	# Aplicar algortimo de Euclides
	while (resto > 0) {
		resto <- dividendo %% divisor
		if (resto == 0) return(divisor)
		dividendo <- divisor
		divisor <- resto
	}
}
```
