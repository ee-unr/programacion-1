```{=latex}
\thispagestyle{primerapagina}
```

# Arreglos

::: {.presentacion-capitulo data-latex=""}
En este capítulo vamos a trabajar con **arreglos**, una clase de estructuras que agrupan múltiples datos en una mismo objeto y los organizan en una o más dimensiones. Vamos a empezar con los **vectores**, que son arreglos unidimensionales, y luego avanzaremos hacia las **matrices**, que extienden la idea a dos dimensiones. También veremos cómo se pueden añadir atributos a los objetos en R para guardar información adicional, como los nombres de las dimensiones. Nos enfocaremos en cómo acceder, modificar y operar sobre los elementos de estas estructuras con instrucciones claras y detalladas.
:::

Hasta ahora todos los programas que hemos desarrollado hacen uso de objetos que guardan datos individuales, los cuales representan un número, una cadena de texto o un valor lógico. Sin embargo, la verdadera utilidad de la computación radica en poder trabajar con muchos datos a la vez, organizados de acuerdo a ciertas reglas que permitan su manipulación y acceso.

::: {.presentacion-capitulo data-latex=""}
En el contexto de la programación, una **estructura de datos** es una forma organizada de almacenar y manipular datos dentro de un programa informático. Permite a los desarrolladores organizar y gestionar información de manera eficiente, optimizando el acceso y la manipulación de los datos para resolver problemas específicos. 
:::

Hay muchos tipos de estructuras de datos y cada lenguaje de programación propone los suyos propios. Sin embargo, las estructuras más sencillas se conocen como **arreglos** y de una u otra forma están presentes en todos los lenguajes, permitiendo generalizar su definición.

::: {.presentacion-capitulo data-latex=""}
Un **arreglo** (también conocido como *array*) es una estructura de datos que permite almacenar una **colección ordenada** de elementos. En la mayoría de los lenguajes, los elementos de un arreglo son del **mismo tipo**, lo que permite realizar operaciones de forma eficiente y sistemática sobre todos ellos. Por ejemplo, un arreglo puede contener únicamente números, caracteres o valores lógicos, según cómo haya sido definido. De esta forma, decimos que los arreglos tienen dos características fundamentales:

- *Ordenamiento*: los elementos individuales pueden ser enumerados en orden, es decir, debe ser posible identificar en qué posición del arreglo se encuentra cada valor (qué hay en primer lugar, qué hay en segundo lugar, etc.).
- *Homogeneidad*: los elementos individuales almacenados en un arreglo son del mismo tipo (numérico, carácter, lógico).
:::

Los arreglos son muy útiles para almacenar información en la memoria de la computadora, organizando valores que estén relacionados entre sí de alguna manera, por ejemplo, una conjunto de precios, los meses del año, el listado de calificaciones de estudiantes en distintos parciales, etc.

Para indicar qué posición ocupa cada elemento en el arreglo se emplean uno o más **índices**. Dependiendo de cuántos índices se deban utilizar para acceder a cada elemento dentro de los arreglos, estos se clasifican en **unidimensionales** (*vectores*), **bidimensionales** (*matrices*) o **multidimensionales**.

La homogeneidad de los arreglos no solo simplifica las operaciones sobre los elementos, sino que también permite al lenguaje de programación realizar una gestión más eficiente de la **memoria**. En los arreglos clásicos, los elementos se almacenan en **posiciones contiguas de memoria**, lo que posibilita un acceso rápido a cualquier valor. Esta propiedad se mantiene en muchos lenguajes, incluyendo R.


## Vectores

Un **vector** es la estructura de datos más simple y fundamental en R. Se trata de un arreglo unidimensional que, como tal, sólo posee elementos del mismo tipo: todos numéricos, todos de texto, todos lógicos, etc. Por ejemplo, el siguiente es un vector de tipo numérico llamado `x` con 5 elementos:

![Ejemplo de un vector numérico.](../imagenes/teoria_unidad_5/estr01.png){width="60%" fig-align="center"}

En R, los vectores se construyen con la función `c()` (de *combine*), que reúne una serie de valores en una única estructura. Para guardar un vector en nuestro ambiente global, necesitamos elegir un nombre y utilizar el operador de asignación `<-`:

```{r}
x <- c(-4.5, 12, 2.71, -6, 25)
```

Cuando ejecutamos la línea anterior, se crea en el ambiente global el objetos `x`, como podemos notar en la pestaña `Environment` de RStudio. Es decir, los arreglos son **objetos** que constituyen entidades en sí mismas y que pueden ser manipulados al hacer referencia a sus nombres. Además, RStudio nos muestra en la pestaña mencionada qué tipo de vector es cada uno (en este caso dice `num`), cuántos elementos tiene (pone `[1:5]`) y una previsualización de sus primeros elementos. También podemos chequear el tipo de vector y la cantidad de elementos que tiene en la consola:

```{r}
typeof(x)
length(x)
```

Cada uno de los elementos ocupa una posición determinada en el vector. Por ejemplo, el elemento 3 del vector `x` es el numéro 2.71. Se puede *acceder* o hacer referencia a cada elemento mediante el uso de un **índice**, expresado con un número entero entre corchetes al lado del nombre del vector. De esta forma, si escribimos `x[3]` hacemos referencia a la tercera posición del vector, que actualmente guarda al valor 2.71. Como podemos ver, sólo hace falta un índice para hacer referencia a cada elemento de un vector.

![Ejemplo de un vector numérico: se necesita de un solo índice para señalar cada posición.](../imagenes/teoria_unidad_5/estr02.png){width="60%" fig-align="center"}

```{r}
x[1]
x[3]
x[2] + x[5]
x[4] * 2
```

En R, este tipo de estructura se denomina técnicamente **vector atómico** o **atomic vector**, concepto que ya presentamos en la [Unidad 1](@sec-vetor-atomico). En aquella oportunidad, dijimos que este es el nombre que R le da al tipo de objeto más simple y básico; que hay seis tipos de vectores atómicos según los datos que guardan (*doubles*, *characters*, *logicals*, etc.); y que por el momento trabajaríamos con vectores atómicos que sólo contenían un valor almacenado. Ahora ha llegado el momento de sacarle más provecho a estas estructuras de datos, sabiendo que pueden guardar uno o más valores. Como ya sabemos, cuando definimos una variable que sólo guarda un valor, también estamos creando un vector atómico, con la particularidad de que su largo es igual a 1 y, por lo tanto, el uso del índice `[1]` se puede omitir:

```{r}
# Defino un variable numérica: es un objeto simple, llamado "vector atómico"
precio <- 100
is.vector(precio)
# Es un vector de tipo double
typeof(precio)
# Es un vector de largo 1, tien un solo dato
length(precio)
# Por comodidad, no usamos un índice para operar con el único valor almacenado
precio * 1.10
# Pero podríamos hacerlo y sería lo mismo
precio[1] * 1.10
```

Desde ahora usaremos vectores atómicos para guardar cualquier cantidad de elementos. Veamos ejemplos de vectores atómicos de tipo carácter y lógico, con distintos largos:

![Ejemplo de un vector carácter y un vector lógico.](../imagenes/teoria_unidad_5/estr03.png){width="60%" fig-align="center"}

Los definimos en R:

```{r}
y <- c("ARG", "correo@gmail.com", "Ok", "chau")
z <- c(TRUE, TRUE, FALSE)
```

![Creación de vectores en R.](../imagenes/teoria_unidad_5/estr04.png){width="80%" fig-align="center"}

Inspeccionamos su tipo y contenido, y vemos que podemos hacer algunas operaciones con ellos:

```{r}
typeof(y)
length(y)
nchar(y[2])
typeof(z)
length(z)
z[1] && z[2]
```

Podemos emplear estructuras iterativas para recorrer todas las posiciones de un vector y realizar operaciones con ellas, por ejemplo:

```{r}
suma <- 0
for (i in 1:5) {
	cat("La posición", i, "de x está ocupada por el valor", x[i], "\n")
  cat(x[i], "al cuadrado es igual a", x[i]^2, "\n")
  suma <- suma + x[i]
}
cat("La suma de los elementos del vector x es igual a", suma)
```

::: {.importante data-latex=""}
En el ejemplo anterior, se estableció que `i` itere entre 1 y 5 (`i in 1:5`) para recorrer desde el primer al último elemento de `x`. Es mucho mejor establecer el recorrido de la variable de iteración en función del largo de `x`, para que el código sirva sea cual sea la cantidad de elementos en este vector:

```{r}
#| eval: false
suma <- 0
for (i in 1:length(x)) {
	cat("La posición", i, "de x está ocupada por el valor", x[i], "\n")
  cat(x[i], "al cuadrado es igual a", x[i]^2, "\n")
  suma <- suma + x[i]
}
cat("La suma de los elementos del vector x es igual a", suma)
```
:::

::: {.comentario data-latex=""}
En relación al comentario anterior, hay otra recomendación para tener en cuenta: las buenas prácticas recomiendan reemplazar `1:length(x)` por `seq_along(x)`. Ambas formas producen el mismo resultado, un vector de valores entre 1 y la cantidad de elementos de `x`, pero la segunda es más segura, porque puede prevenir de cometer errores, especialmente cuando existe la posibilidad de que `x` sea un vector vacío. 

Supongamos que `x <- c()`, es decir, un vector vacío. Si calculamos `length(x)`, da `0`. Entonces, `1:length(x)` se convierte en `1:0`, que es una **secuencia numérica descendente**: `1, 0` y el bucle `for (i in 1:length(x))` se ejecuta con valores `1` y `0`, que no son índices válidos para `x`. Esto puede llevar a errores sutiles o comportamientos inesperados, como:

```{r}
# Vector vacío
x <- c()
# Largo del vector
length(x)
# Valores para i
1:length(x)
# Comportamiento no deseado: se ejecuta e imprime NULL
for (i in 1:length(x)) {
  print(x[i])
}
```

En cambio, `seq_along(x)` da una **secuencia vacía** si `x` está vacío, y el bucle **no se ejecuta**, que es el comportamiento esperado:

```{r}
# Vector vacío
x <- c()
# Largo del vector
length(x)
# Valores para i: ninguno
seq_along(x)
# Comportamiento deseado: no se ejecuta
for (i in seq_along(x)) {
  print(x[i])
}
```

`seq_along(x)` comunica de manera clara que vamos a recorrer los **índices válidos de x**. Es una función pensada específicamente para este uso. Asegura que el código se comporte correctamente tanto si `x` tiene muchos elementos, como si tiene uno solo o está vacío.
:::

Antes comentamos que en R los vectores se crean con expresiones como `x <- c(-4.5, 12, 2.71, -6, 25)`, donde sus elementos están listados de forma literal. También podemos crear vectores de un largo determinado dejando que cada posición quede ocupada por algún valor asignado por defecto. Por ejemplo, el siguiente código crea un vector de tipo numérico con 10 posiciones, uno carácter con 7 y otro lógico con 2. En cada caso, R rellena todas las posiciones con el mismo valor: ceros, caracteres vacíos `""` y valores `FALSE`, respectivamente:

```{r}
a <- numeric(10)
b <- character(7)
d <- logical(2)

a
b
d
```

::: {.ejercicio data-latex=""}
Sin ejecutar el código, determinar cuál será el contenido del vector `a` al finalizar:

```{r}
#| eval: false
a <- numeric(10)
for (i in 1:length(a)) {
	if (i %% 3 == 0) {
		a[i] <- i * 100
	}
}
a
```
:::

::: {.ejemplo data-latex=""}
**Invertir de lugar los elementos de un vector**

Nos planteamos el problema de dar vuelta los elementos pertenecientes a un vector, de manera que el primer elemento pase a ser el último, el segundo pase al penúltimo lugar, etc. Por ejemplo, dado el vector de tipo carácter `v`:

![Vector `v`.](../imagenes/teoria_unidad_5/estr11.png){width="80%" fig-align="center"}

queremos modificarlo para obtener:

![Resultado buscado.](../imagenes/teoria_unidad_5/estr12.png){width="80%" fig-align="center"}

Si bien podemos pensar en distintas formas para resolver este problema, probablemente la más sencilla requiere que intercambiemos de a dos los valores en ciertas posiciones del vector, empezando por intercambiar el primero con el último. Para esto podemos emplear una variable auxiliar que guarde el valor de alguna de las celdas temporalmente (por eso lo vamos a llamar `tmp`):

![Pasos para intercambiar los valores entre la primera y última posición.](../imagenes/teoria_unidad_5/estr13.png){width="80%" fig-align="center"}

Ahora sólo resta realizar el mismo procedimiento para los valores de las posiciones 2 y 4. Como el número de elementos en el vector es impar, el valor en la posición central queda en su lugar. Podemos definir el siguiente programa para resolver este problema de manera general, para vectores de cualquier largo `n`:

```{r}
v <- c("Estadística", "en", "Licenciatura", "la", "Aguante")
n <- length(v)
for (i in 1:(n %/% 2)) {
	tmp <- v[i]
	v[i] <- v[n - i + 1]
	v[n - i + 1] <- tmp
}
v
```
:::

::: {.comentario data-latex=""}
En R, la indexación de los elementos de un vector comienza en **1**, lo que significa que el primer elemento se accede con `x[1]`. Este enfoque se conoce como **indexación basada en uno** o *1-indexed*. Sin embargo, muchos otros lenguajes de programación populares (como C, C++, Java, Python y JavaScript) utilizan **indexación basada en cero** (*0-indexed*), donde el primer elemento se accede con `x[0]`. Este detalle es importante al aprender R, en especial si tenés experiencia en otros lenguajes. Confundir estos sistemas puede llevar a errores difíciles de detectar.
:::

## Matrices


## Atributos


### `names`


### `dim`


### `class`


