```{=latex}
\thispagestyle{primerapagina}
```

# Arreglos

::: {.presentacion-capitulo data-latex=""}
En este capítulo vamos a trabajar con **arreglos**, una clase de estructuras que agrupan múltiples datos en una mismo objeto y los organizan en una o más dimensiones. Vamos a empezar con los **vectores**, que son arreglos unidimensionales, y luego avanzaremos hacia las **matrices**, que extienden la idea a dos dimensiones. También veremos cómo se pueden añadir atributos a los objetos en R para guardar información adicional, como los nombres de las dimensiones. Nos enfocaremos en cómo acceder, modificar y operar sobre los elementos de estas estructuras con instrucciones claras y detalladas.
:::

Hasta ahora todos los programas que hemos desarrollado hacen uso de objetos que guardan datos individuales, los cuales representan un número, una cadena de texto o un valor lógico. Sin embargo, la verdadera utilidad de la computación radica en poder trabajar con muchos datos a la vez, organizados de acuerdo a ciertas reglas que permitan su manipulación y acceso.

::: {.presentacion-capitulo data-latex=""}
En el contexto de la programación, una **estructura de datos** es una forma organizada de almacenar y manipular datos dentro de un programa informático. Permite a los desarrolladores organizar y gestionar información de manera eficiente, optimizando el acceso y la manipulación de los datos para resolver problemas específicos. 
:::

Hay muchos tipos de estructuras de datos y cada lenguaje de programación propone los suyos propios. Sin embargo, las estructuras más sencillas se conocen como **arreglos** y de una u otra forma están presentes en todos los lenguajes, permitiendo generalizar su definición.

::: {.presentacion-capitulo data-latex=""}
Un **arreglo** (también conocido como *array*) es una estructura de datos que permite almacenar una **colección ordenada** de elementos. En la mayoría de los lenguajes, los elementos de un arreglo son del **mismo tipo**, lo que permite realizar operaciones de forma eficiente y sistemática sobre todos ellos. Por ejemplo, un arreglo puede contener únicamente números, caracteres o valores lógicos, según cómo haya sido definido. De esta forma, decimos que los arreglos tienen dos características fundamentales:

- *Ordenamiento*: los elementos individuales pueden ser enumerados en orden, es decir, debe ser posible identificar en qué posición del arreglo se encuentra cada valor (qué hay en primer lugar, qué hay en segundo lugar, etc.).
- *Homogeneidad*: los elementos individuales almacenados en un arreglo son del mismo tipo (numérico, carácter, lógico).
:::

Los arreglos son muy útiles para almacenar información en la memoria de la computadora, organizando valores que estén relacionados entre sí de alguna manera, por ejemplo, una conjunto de precios, los meses del año, el listado de calificaciones de estudiantes en distintos parciales, etc.

Para indicar qué posición ocupa cada elemento en el arreglo se emplean uno o más **índices**. Dependiendo de cuántos índices se deban utilizar para acceder a cada elemento dentro de los arreglos, estos se clasifican en **unidimensionales** (*vectores*), **bidimensionales** (*matrices*) o **multidimensionales**.

La homogeneidad de los arreglos no solo simplifica las operaciones sobre los elementos, sino que también permite al lenguaje de programación realizar una gestión más eficiente de la **memoria**. En los arreglos clásicos, los elementos se almacenan en **posiciones contiguas de memoria**, lo que posibilita un acceso rápido a cualquier valor. Esta propiedad se mantiene en muchos lenguajes, incluyendo R.


## Vectores

Un **vector** es la estructura de datos más simple y fundamental en R. Se trata de un arreglo unidimensional que, como tal, sólo posee elementos del mismo tipo: todos numéricos, todos de texto, todos lógicos, etc. Por ejemplo, el siguiente es un vector de tipo numérico llamado `x` con 5 elementos:

![Ejemplo de un vector numérico.](../imagenes/teoria_unidad_5/estr01.png){width="60%" fig-align="center"}

En R, los vectores se construyen con la función `c()` (de *combine*), que reúne una serie de valores en una única estructura. Para guardar un vector en nuestro ambiente global, necesitamos elegir un nombre y utilizar el operador de asignación `<-`:

```{r}
x <- c(-4.5, 12, 2.71, -6, 25)
```

Cuando ejecutamos la línea anterior, se crea en el ambiente global el objetos `x`, como podemos notar en la pestaña `Environment` de RStudio. Es decir, los arreglos son **objetos** que constituyen entidades en sí mismas y que pueden ser manipulados al hacer referencia a sus nombres. Además, RStudio nos muestra en la pestaña mencionada qué tipo de vector es cada uno (en este caso dice `num`), cuántos elementos tiene (pone `[1:5]`) y una previsualización de sus primeros elementos. También podemos chequear el tipo de vector y la cantidad de elementos que tiene en la consola:

```{r}
typeof(x)
length(x)
```

Cada uno de los elementos ocupa una posición determinada en el vector. Por ejemplo, el elemento 3 del vector `x` es el numéro 2.71. Se puede *acceder* o hacer referencia a cada elemento mediante el uso de un **índice**, expresado con un número entero entre corchetes al lado del nombre del vector. De esta forma, si escribimos `x[3]` hacemos referencia a la tercera posición del vector, que actualmente guarda al valor 2.71. Como podemos ver, sólo hace falta un índice para hacer referencia a cada elemento de un vector.

![Ejemplo de un vector numérico: se necesita de un solo índice para señalar cada posición.](../imagenes/teoria_unidad_5/estr02.png){width="60%" fig-align="center"}

```{r}
x[1]
x[3]
x[2] + x[5]
x[4] * 2
```

En R, este tipo de estructura se denomina técnicamente **vector atómico** o **atomic vector**, concepto que ya presentamos en la [Unidad 1](@sec-vetor-atomico). En aquella oportunidad, dijimos que este es el nombre que R le da al tipo de objeto más simple y básico; que hay seis tipos de vectores atómicos según los datos que guardan (*doubles*, *characters*, *logicals*, etc.); y que por el momento trabajaríamos con vectores atómicos que sólo contenían un valor almacenado. Ahora ha llegado el momento de sacarle más provecho a estas estructuras de datos, sabiendo que pueden guardar uno o más valores. De hecho, cuando definimos una variable que sólo guarda un valor, estamos creando un vector atómico, con la particularidad de que su largo es igual a 1 y, por lo tanto, el uso del índice `[1]` se puede omitir:

```{r}
# Defino un variable numérica: es un objeto simple, llamado "vector atómico"
precio <- 100
is.vector(precio)
# Es un vector de tipo double
typeof(precio)
# Es un vector de largo 1, tien un solo dato
length(precio)
# Por comodidad, no usamos un índice para operar con el único valor almacenado
precio * 1.10
# Pero podríamos hacerlo y sería lo mismo
precio[1] * 1.10
```


Los siguientes son ejemplos de vectores de tipo carácter y lógico, con distintas cantidades de elementos:

![Ejemplo de un vector carácter y un vector lógico.](../imagenes/teoria_unidad_5/estr03.png){width="60%" fig-align="center"}

Los definimos en R:

```{r}
y <- c("ARG", "correo@gmail.com", "Ok", "chau")
z <- c(TRUE, TRUE, FALSE)
```

![Creación de vectores en R.](../imagenes/teoria_unidad_5/estr04.png){width="80%" fig-align="center"}

Inspeccionamos su tipo y contenido, y vemos que podemos hacer algunas operaciones con ellos:

```{r}
typeof(y)
length(y)
nchar(y[2])
typeof(z)
length(z)
z[1] && z[2]
```

Podemos emplear estructuras iterativas para recorrer todas las posiciones de un vector y realizar operaciones con ellas, por ejemplo:

```
PARA i DESDE 1 HASTA 5 HACER
    ESCRIBIR "La posición " i "de x está ocupada por el valor " x[i]
FIN PARA
```

```{r}
suma <- 0
for (i in 1:5) {
	cat("La posición", i, "de x está ocupada por el valor", x[i], "\n")
  cat(x[i], "al cuadrado es igual a", x[i]^2, "\n")
  suma <- suma + x[i]
}
cat("La suma de los elementos del vector x es igual a", suma)
```

PENDIENTE
0-indexed
seq_along, ver chat


Antes comentamos que en R los vectores se crean con expresiones como `x <- c(-4.5, 12, 2.71, -6, 25)`, donde sus elementos están listados de forma literal. También podemos crear vectores de un largo determinado dejando que cada posición quede ocupada por algún valor asignado por defecto. Por ejemplo, el siguiente código crea un vector tipo numérico con 10 posiciones, uno carácter con 7 y otro lógico con 2. En cada caso, R rellena todas las posiciones con el mismo valor: ceros en el vector numérico, caracteres vacíos `""` en el vector de tipo carácter y valores `FALSE` en el vector lógico:

```{r}
a <- numeric(10)
b <- character(7)
d <- logical(2)

a
b
d
```

Se pueden asignar valores a una, varias o todas las posiciones de un vector en cualquier parte del algoritmo. Además, en pseudocódigo emplearemos la palabra clave `MOSTRAR` cuando deseamos que se escriba en pantalla todo el contenido de un vector. Por ejemplo:

```
VARIABLE numérica a(10)
PARA i DESDE 1 HASTA LARGO(a) HACER
	SI i MOD 3 == 0 ENTONCES  
		a[i] <- i * 100
	FIN SI
FIN PARA
MOSTRAR a
```

```{r}
a <- numeric(10)
for (i in 1:length(a)) {
	if (i %% 3 == 0) {
		a[i] <- i * 100
	}
}
a
```

En los ejemplos anteriores, declaramos los vectores explicitando su tamaño con un número: `VARIABLE numérica x(5)` o `VARIABLE numérica a(10)`. Sin embargo, el tamaño del vector podría estar guardado en otra variable, cuyo valor se determina en cada ejecución del programa mediante información externa o como resultado de algún cálculo anterior. En el siguiente ejemplo se deja que el usuario determine la dimensión del vector y que provea cada uno de los valores para el mismo. Antes de poder declarar la existencia del nuevo vector llamado `mi_vector`, se "lee" su tamaño:

```
VARIABLE numérica tam
LEER tam
VARIABLE numérica mi_vector(tam)
PARA i DESDE 1 HASTA tam HACER
	LEER mi_vector[i]
FIN PARA
```

Por ahora, toda instrucción de *leer* en el pseudocódigo será traducida en R mediante la asignación directa de valores. Por ejemplo, `LEER tam` se reemplaza por `tam <- 5` (o el número que necesitemos).

Antes de terminar esta sección haremos una última observación. En R todos los objetos que hemos considerado como "variable" y que guardan un único valor (como `tam` en el ejemplo anterior), son también considerados como vectores, cuyo largo es 1, como podemos verificar en el siguiente ejemplo:

```{r}
x <- 25
length(x)
is.vector(x) # Esta función lógica le pregunta a R si el objeto x es un vector
```

**Ejemplo: invertir los elementos de un vector**

Nos planteamos el problema de dar vuelta los elementos pertenecientes a un vector, de manera que el primer elemento pase a ser el último, el segundo pase al penúltimo lugar, etcétera. Por ejemplo, dado el vector de tipo carácter `v`:

```{r inv1, out.width='80%', fig.show='hold', fig.cap='Vector v original', echo=FALSE, fig.align="center"}
knitr::include_graphics('images/05_estructuras/estr11.png')
```

queremos modificarlo para obtener:

```{r inv2, out.width='80%', fig.show='hold', fig.cap='Vector v reordenado', echo=FALSE, fig.align="center"}
knitr::include_graphics('images/05_estructuras/estr12.png')
```

Si bien podemos pensar en distintas formas para resolver este problema, probablemente la más sencilla requiere que intercambiemos de a dos los valores en ciertas posiciones del vector, por ejemplo, empezando por intercambiar el primero con el último. Para esto podemos emplear una variable auxiliar que guarde el valor de alguna de las celdas temporariamente (por eso lo vamos a llamar `tmp`):

```{r inv3, out.width='80%', fig.show='hold', fig.cap='Pasos para intercambiar valores', echo=FALSE, fig.align="center"}
knitr::include_graphics('images/05_estructuras/estr13.png')
```

Ahora sólo resta realizar el mismo procedimiento para los valores de las posiciones 2 y 4. Como el número de elementos en el vector es impar, el valor en la posición central queda en su lugar. Podemos definir el siguiente algoritmo para resolver este problema de manera general. En el siguiente pseudocódigo, primero declaramos una variable numérica `n` que puede tomar cualquier valor y que servirá para declarar cuántos espacios necesita el vector. Luego, se itera para leer cada elemento del vector. Finalmente, se implementa la estrategia de reordenamiento:

```
ALGORITMO: "Invertir (dar vuelta) los elementos de un vector"
COMENZAR
    
  # Declarar variables
  VARIABLE numérica n
  VARIABLE carácter tmp
  LEER n
  VARIABLE carácter v(n)
  
  # Asignar valores al vector
  PARA i DESDE 1 HASTA n HACER
      LEER v[i]
  FIN PARA
  
  # Reordenar
  PARA i DESDE 1 HASTA n DIV 2 HACER
      tmp <- v[i]                 # Paso 1
      v[i] <- v[n - i + 1]        # Paso 2
      v[n - i + 1] <- tmp         # Paso 3
  FIN PARA
  
  # Mostrar el vector reodenado
  MOSTRAR v
    
FIN
```

En el ejemplo anterior hemos incorporado el uso de comentarios en el pseudocódigo para describir el objetivo de cada parte. Imitando lo que hacemos en R, señalamos la presencia de comentarios con el carácter `#` (podríamos usar otra cosa, pero adheriremos a esta convención). Se usó el operador `DIV` para obtener la división entera entre `n` y `2` (por ejemplo, `5 DIV 2 = 2`). En R reemplazamos todas las instrucciones `LEER` por una asignación directa de valores y empleamos el operador de división entera `%/%`:

```{r}
v <- c("Estadística", "en", "Licenciatura", "la", "Aguante")
n <- length(v)
for (i in 1:(n%/%2)) {
	tmp <- v[i]
	v[i] <- v[n - i + 1]
	v[n - i + 1] <- tmp
}
v
```

## Matrices


## Atributos


### `names`


### `dim`


### `class`


