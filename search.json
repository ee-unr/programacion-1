[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programación 1",
    "section": "",
    "text": "Bienvenida",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#hola",
    "href": "index.html#hola",
    "title": "Programación 1",
    "section": "¡Hola!",
    "text": "¡Hola!\nBienvenidos a este curso introductorio de programación para estudiantes de Estadística y Ciencia de Datos. A lo largo de estas páginas, nos embarcaremos en un recorrido que tiene como objetivo fundamental desarrollar habilidades de pensamiento algorítmico y resolución de problemas computacionales. Aprender a programar no es solo escribir código: implica descomponer problemas complejos en partes más pequeñas, identificar patrones, diseñar soluciones y comprender cómo una computadora ejecuta instrucciones paso a paso.\nEn este camino utilizaremos R, un lenguaje ampliamente utilizado en Estadística y Ciencia de Datos. Sin embargo, en este curso no nos enfocaremos en sus poderosas herramientas de modelado, manipulación de datos o visualización. Aprenderás de eso en otras asignaturas, como en Laboratorio de Datos 1. En su lugar, usaremos R como vehículo para aprender los principios esenciales de la programación. Por ejemplo, veremos cómo lograr que la computadora haga una división, cuando en realidad es algo sencillo que R o cualquier otro entorno ya lo sabe hacer. Este enfoque nos permitirá desarrollar habilidades fundamentales: estructurar código de manera ordenada, depurar errores con criterio, organizar proyectos de software y escribir funciones reutilizables. Aprenderemos a pensar como programadores, lo que no solo facilitará el uso posterior de herramientas más avanzadas, sino que también brindará una base sólida para afrontar nuevos lenguajes y paradigmas de programación.\nLa idea es que desarrollemos nuestro pensamiento lógico y algorítmico, mientras nos familiarizamos con el uso de nuestra computadora y archivos, con el objetivo de que salgas listo para seguir profundizando tus conocimientos, por ejemplo, en la asignatura Programación 2, donde usarás Python.\n¡Comencemos este viaje!",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#estructura-del-libro",
    "href": "index.html#estructura-del-libro",
    "title": "Programación 1",
    "section": "Estructura del libro",
    "text": "Estructura del libro\nEste libro se organiza en unidades, cada una de las cuales se corresponde con una unidad del programa de la asignatura y está compuesta por capítulos que abordan un tema en particular. De vez en cuando se incluyen algunos elementos especiales, que están identificados de la siguiente forma:\n\nEsto es la presentación de una unidad o un capítulo.\n\n\nEsto es un ejemplo.\n\n\nEsto es un ejercicio.\n\n\nEsto es una definición.\n\n\nEsto es una idea fundamental para tener en cuenta.\n\n\nEsto es un comentario adicional, que puede ser considerado como secundario o dejado de lado.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Programación 1",
    "section": "Licencia",
    "text": "Licencia\nEste libro adhiere a la licencia Creative Commons Attribution 4.0 International (CC BY 4.0). Esto significa que podés copiar, distribuir y adaptar este material libremente, incluso con fines comerciales, siempre que otorgues el crédito correspondiente a los autores originales. No se requieren permisos adicionales siempre que se cumplan estos términos.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "capitulos/00_info.html",
    "href": "capitulos/00_info.html",
    "title": "Información general sobre la asignatura",
    "section": "",
    "text": "Programa\nEn este enlace podés consultar el programa para esta asignatura. Allí se describe en detalle el sistema de evaluación, junto con todos los requisitos para regularizar o promover la asignatura.",
    "crumbs": [
      "Información general sobre la asignatura"
    ]
  },
  {
    "objectID": "capitulos/00_info.html#aula-virtual",
    "href": "capitulos/00_info.html#aula-virtual",
    "title": "Información general sobre la asignatura",
    "section": "Aula virtual",
    "text": "Aula virtual\nEsta asignatura posee un espacio virtual en la plataforma Comunidades 3 de la Universidad Nacional de Rosario, que será utilizado para dar anuncios y noticias, responder consultas en los foros, entregar y realizar devoluciones sobre los trabajos prácticos, informar calificaciones, etc. Es importante que visites este espacio de forma regular. Si no te ha llegado la clave para poder ingresar, contactá a los docentes.",
    "crumbs": [
      "Información general sobre la asignatura"
    ]
  },
  {
    "objectID": "capitulos/00_info.html#cursado",
    "href": "capitulos/00_info.html#cursado",
    "title": "Información general sobre la asignatura",
    "section": "Cursado",
    "text": "Cursado\n\nActividades semanales\nCada semana durante la extensión del cuatrimestre encontrarás las indicaciones referidas a los contenidos que debés cubrir para avanzar en tiempo y forma con esta asignatura. En este cronograma de trabajo verás de forma detallada cuáles son los capítulos del libro a estudiar y los ejercicios de las prácticas a resolver, semana a semana. Todos los materiales estarán publicados con anticipación, incluyendo las respuestas a los problemas, de modo que puedas autogestionar tus tiempos. Además, en el cronograma podrás ver todas las fechas importantes que deben ser respetadas, como las de las evaluaciones.\n\n\nClases\nComo acompañamiento a tu propio avance por la asignatura, cada semana podés asistir a dos clases:\n\nUna es virtual y se dicta los días lunes de 14:30 a 16:30 para todo el estudiantado. Estas clases tienen el objetivo de presentar los contenidos conceptuales de cada semana, mediante la exposición interactiva del tema a abordar.\nLa otra clase es presencial y se dicta en el Laboratorio de Computación de la Escuela de Estadística, para cada comisión por separado.\n\nSi por alguna razón una clase se suspende (por ejemplo, es feriado), ¡no te preocupes! Todo el material correspondiente a la semana en cuestión estará publicado y podrás resolver tus dudas en las consultas presenciales o virtuales, o en los foros del aula virtual. Tenés que tener en cuenta la semana siguiente no repasaremos el contenido de la semana en la que no tuviste clase, sino que avanzaremos con los temas que tocan esa semana, según el cronograma.\nInformación importante para las clases, como enlaces para conectarte o días y horarios de cada comisón, son publicados en el aula virtual.\n\n\nConsultas\nPodés resolver tus dudas recurriendo a estos medios:\n\nForos de consulta en el aula virtual.\nClases de consulta virtuales. Los enlaces y horarios se publican en el aula virtual. Si ningún estudiante se conecta, la clase se da por finalizada luego de 10 minutos de espera.\nClases de consulta presenciales en el laboratorio de computación. Estas clases tendrán una duración determinada. Durante ese tiempo, además de resolver dudas con los docentes, podés recurrir al laboratorio para hacer uso de las computadoras y resolver ejercicios u otros trabajos.",
    "crumbs": [
      "Información general sobre la asignatura"
    ]
  },
  {
    "objectID": "capitulos/00_info.html#sec-cronograma",
    "href": "capitulos/00_info.html#sec-cronograma",
    "title": "Información general sobre la asignatura",
    "section": "Cronograma",
    "text": "Cronograma\nVisitá periódicamente este cronograma para autogestionar tu tránsito por los temas y materiales de la asignatura:\n\n\n\n\n\n\n\n\n\n\n\nSemana\nInicio / Fin\nTópico\nCapítulos a leer\nEjercicios a resolver\nImportante\n\n\n\n\n1\n17/3 al 23/3\nUnidad 1\n1 a 3\n1 a 4\n\n\n\n2\n24/3 al 30/3\nUnidad 1\n4\n5 a 9\nFeriado: lun 24/3\n\n\n3\n31/3 al 6/4\nUnidades 1 y 2\n5 a 7\n10 a 13 (Unidad 1)\nFeriado: mié 2/4\n\n\n4\n7/4 al 13/4\nUnidad 2\n10\n1 a 6\n\n\n\n5\n14/4 al 20/4\nUnidad 2\n11 y 12\n7 a 9\nFeriados: Jue 17/4 y Vie 18/4\n\n\n6\n21/4 al 27/4\nUnidad 3\n14\n1 a 5\n\n\n\n7\n28/4 al 4/5\nUnidad 3\n15 y 16\n6 a 12\nFeriados: Jue 1/5 y Vie 2/5\n\n\n8\n5/5 al 11/5\nSemana del parcial\nEstudio y repaso\nEstudio y repaso\nParcial: jue 8/5 a las 18:00, todas las comisiones juntas\n\n\n9\n12/5 al 18/5\nUnidad 4\n19 a 21\nTodos los ejercicios\n\n\n\n10\n19/5 al 25/5\nUnidad 5\n24\n1 a 10\n\n\n\n11\n26/5 al 1/6\nUnidad 5\n25\n11 a 14\n\n\n\n12\n2/6 al 8/6\nUnidad 5\n26\n15 en adelante\n\n\n\n13\n9/6 al 15/6\nRecup. / Unidad 6\nA definir\nA definir\nEntrega TP: martes 10/6. Recup: jue 12/6 a la tardecita, todas las comisiones juntas\n\n\n14\n16/6 al 22/6\nUnidad 6\nA definir\nA definir\nEntrega tarea promoción: dom 22/6. Feriados: lun 16/6 y vie 20/6\n\n\n15\n23/6 al 29/6\nUnidad 6\nA definir\nA definir\nVie 27/6: notificación de la condición final en la asignatura",
    "crumbs": [
      "Información general sobre la asignatura"
    ]
  },
  {
    "objectID": "capitulos/00_info.html#código-de-conducta",
    "href": "capitulos/00_info.html#código-de-conducta",
    "title": "Información general sobre la asignatura",
    "section": "Código de conducta",
    "text": "Código de conducta\nEn esta asignatura promovemos un ambiente de respeto, colaboración y aprendizaje mutuo. Para garantizar una experiencia positiva para todas las personas involucradas, establecemos las siguientes normas de convivencia:\n\nRespeto y trato cordial\n\nTodas las personas deben ser tratadas con respeto, independientemente de su experiencia, formación, identidad de género, origen, creencias u opiniones.\nSe espera un trato cordial y profesional entre estudiantes, docentes y personal de la facultad.\n\nNo se tolerarán expresiones de discriminación, violencia verbal, acoso o cualquier forma de descalificación personal.\n\n\n\nParticipación y comunicación\n\nSe fomenta el intercambio de ideas y el debate académico en un marco de respeto.\n\nSe debe permitir que todas las voces sean escuchadas sin interrupciones ni actitudes despectivas.\n\nEl uso de lenguaje claro y respetuoso es fundamental, tanto en interacciones presenciales como en medios digitales relacionados con la asignatura.\n\nSe valora la cooperación en actividades grupales, con una distribución equitativa de tareas y reconocimiento del aporte de cada integrante.\n\nSe invita a hacer preguntas y solicitar aclaraciones cuando sea necesario, en un clima de confianza y respeto.\n\nLos comentarios hacia otros estudiantes y docentes deben ser constructivos y enfocados en la mejora del aprendizaje.\n\n\n\nResponsabilidad y compromiso\n\nLa entrega de trabajos deben realizarse con responsabilidad. En caso de dificultades, se recomienda comunicarse con el equipo docente con anticipación.\nSe espera honestidad académica en todas las actividades del curso.\n\nEl uso de dispositivos electrónicos en clase debe estar alineado con los objetivos de la misma, evitando distracciones innecesarias.\n\n\n\nUso responsable de inteligencia artificial para resolver problemas\n\nLas herramientas de inteligencia artificial (IA) pueden ser útiles en ciertos contextos, pero su uso excesivo o inadecuado puede limitar el aprendizaje real. Es fundamental que los estudiantes realicen el esfuerzo de comprender y desarrollar las soluciones por sí mismos.\n\nPara aprender a programar y desarrollar pensamiento lógico, es necesario escribir código, enfrentar errores y corregirlos. Depender demasiado de la IA puede generar una falsa sensación de dominio sin una comprensión profunda.\n\nEn las evaluaciones y entregas, queda estrictamente prohibido el plagio y todo tipo de copia, incluyendo el uso de respuestas generadas por IA sin una comprensión real del contenido.\n\nSi se detecta plagio o copia en cualquier instancia de evaluación, o falta de comprensión de las soluciones entregadas, se aplicarán las medidas correspondientes según las normativas de la institución.\n\nEl cumplimiento de estas normas contribuye a un entorno en el que todas las personas puedan participar activamente y aprovechar al máximo la experiencia educativa. Ante cualquier inquietud o situación que afecte la convivencia, se recomienda comunicarlo al equipo docente o a las autoridades institucionales.",
    "crumbs": [
      "Información general sobre la asignatura"
    ]
  },
  {
    "objectID": "capitulos/01.html",
    "href": "capitulos/01.html",
    "title": "Unidad 1. Introducción a la programación con R",
    "section": "",
    "text": "Esta unidad introduce los conceptos fundamentales para comenzar a programar en R, proporcionando las bases necesarias para desarrollar código claro, estructurado y funcional. Iniciamos con una exploración de qué significa programar, abordando las etapas del diseño algorítmico y la codificación. Luego, presentamos R y RStudio, sus características principales y su instalación, junto con los primeros comandos y estructuras esenciales del lenguaje.\nA lo largo de la unidad, aprenderemos sobre los distintos tipos de objetos y operadores en R, así como la organización eficiente del trabajo mediante archivos, proyectos y buenas prácticas. También abordaremos la gestión de errores, la importancia de seguir una guía de estilo para escribir código legible y el uso de paquetes para ampliar las capacidades del lenguaje. Finalmente, incluimos una reseña histórica de la computación y una introducción a los lenguajes de programación y sus niveles de abstracción.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R"
    ]
  },
  {
    "objectID": "capitulos/01_a_intro.html",
    "href": "capitulos/01_a_intro.html",
    "title": "1  Programación",
    "section": "",
    "text": "1.1 Qué es la programación\nLas computadoras son una parte esencial de nuestra vida cotidiana. Casi todos los aparatos que usamos tienen algún tipo de computadora capaz de ejecutar ciertas tareas: lavarropas con distintos modos de lavado, consolas de juegos para momentos de entretenimiento, calculadoras súper potentes, computadoras personales que se usan para un montón de propósitos, teléfonos celulares con un sinfín de aplicaciones y miles de cosas más.\nTodos estos dispositivos con computadoras de distinto tipo tienen algo en común: alguien “les dice” cómo funcionar, es decir, les indica cuáles son los pasos que deben seguir para cumplir una tarea. De eso se trata la programación: es la actividad mediante la cual las personas (o algoritmos de inteligencia artificial) le entregan a una computadora un conjunto de instrucciones para que, al ejecutarlas, ésta pueda resolver un problema. Los conjuntos de instrucciones que reciben las computadoras reciben el nombre de programas.\nLa programación es un proceso creativo: en muchas ocasiones la tarea en cuestión puede cumplirse siguiendo distintos caminos y al programar debemos imaginar cuáles son y elegir uno. Algunos de estos caminos pueden ser mejores que otros, pero en cualquier caso la computadora se limitará a seguir las instrucciones ideadas por nosotros.\nEstas instrucciones deben ser transmitidas en un idioma que la computadora pueda entender sin ambigüedad. Para eso debemos aprender algún lenguaje de programación, que no es más que un lenguaje artificial compuesto por una serie de expresiones que la computadora puede interpretar. Las computadoras interpretan nuestras instrucciones de forma muy literal, por lo tanto a la hora de programar hay que ser muy específicos. Es necesario respetar las reglas del lenguaje de programación y ser claros en las indicaciones provistas.\nAhora bien, ¿por qué debemos estudiar programación en carreras como Licenciatura en Estadística y Licenciatura en Ciencia de Datos? La actividad de los profesionales que trabajamos con datos está atravesada en su totalidad por la necesidad de manejar con soltura herramientas informáticas que nos asisten en las distintas etapas de nuestra labor: recolección y depuración de conjuntos de datos, aplicación de distintas metodologías de análisis, visualización de la información, comunicación efectiva de los resultados, despliegue y puesta en producción de modelos, etc. Por eso, en la asignatura Programación 1 estudiaremos los conceptos básicos de esta disciplina, fomentando la ejercitación del pensamiento abstracto y lógico necesario para poder entendernos hábilmente con la computadora y lograr que la misma realice las tareas que necesitamos.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Programación</span>"
    ]
  },
  {
    "objectID": "capitulos/01_a_intro.html#etapas-en-la-programación",
    "href": "capitulos/01_a_intro.html#etapas-en-la-programación",
    "title": "1  Programación",
    "section": "1.2 Etapas en la programación",
    "text": "1.2 Etapas en la programación\nMencionamos anteriormente que la programación consiste en instruir a una computadora para que resuelva un problema y que la comunicación de esas instrucciones debe ser realizada de forma clara. Es por eso que, ante un problema que debe ser resuelto computacionalmente, el primer paso es pensar detalladamente cuál puede ser una forma de resolverlo, es decir, crear un algoritmo.\n\nUn algoritmo es una estrategia consistente de un conjunto ordenado de pasos que nos lleva a la solución de un problema o alcance de un objetivo. Luego, hay que traducir el algoritmo elegido al idioma de la computadora.\n\nEntonces, podemos decir que la resolución computacional de un problema consiste de dos etapas básicas:\n\n1.2.1 Diseño algorítmico\nCotidianamente, hacemos uso de algoritmos para llevar adelante casi todas las actividades que realizamos: preparar el desayuno, sacar a pasear la mascota, poner en la tele un servicio de streaming para ver una película, etc. Cada una de estas tareas requiere llevar adelante algunas acciones de forma ordenada, aunque no hagamos un listado de las mismas y procedamos casi sin pensar.\nSin embargo, cuando estamos pensando la solución para un problema que va a resolver programando, debemos pensar uno por uno cuáles son todos los pasos a seguir, para asegurarnos de que cuando la computadora los siga, llegue a la solución. Suele ser útil escribir en borrador cuáles son esos pasos, de forma clara y ordenada, e incluso hacer diagramas. Una vez que hemos imaginado como resolver el problema mediante programación, podemos pasar a la siguiente etapa.\n\n\n1.2.2 Codificación\nUna vez que tenemos diseñada la solución al problema, hay que comunicársela a la computadora para que la siga. Para que ella pueda entender nuestro algoritmo, debemos traducirlo en un lenguaje de programación, que, como dijimos antes, es un idioma artificial diseñado para expresar cómputos que puedan ser llevados a cabo por equipos electrónicos, es decir es un medio de comunicación entre el humano y la máquina.\nAl aprender sobre programación, comenzamos enfrentándonos a problemas simples para los cuales la etapa del diseño algorítmico parece sencilla, mientras que la codificación se torna dificultosa, ya que hay que aprender las reglas del lenguaje de programación. Sin embargo, mientras que con práctica rápidamente podemos ganar facilidad para la escritura de código, el diseño algorítmico se torna cada vez más desafiante al encarar problemas más complejos.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Programación</span>"
    ]
  },
  {
    "objectID": "capitulos/01_a_intro.html#el-lenguaje-r-y-su-importancia-en-estadística-y-ciencia-de-datos",
    "href": "capitulos/01_a_intro.html#el-lenguaje-r-y-su-importancia-en-estadística-y-ciencia-de-datos",
    "title": "1  Programación",
    "section": "1.3 El lenguaje R y su importancia en Estadística y Ciencia de Datos",
    "text": "1.3 El lenguaje R y su importancia en Estadística y Ciencia de Datos\nR es un lenguaje de programación y un entorno de software diseñado específicamente para el análisis estadístico y la visualización de datos. Fue creado por Ross Ihaka y Robert Gentleman como una implementación libre del lenguaje S, desarrollado en los laboratorios AT&T Bell. Desde su lanzamiento, R ha crecido hasta convertirse en una de las herramientas más utilizadas en Estadística, Ciencia de Datos e investigación en una amplia variedad de disciplinas. Su código es abierto y es mantenido por una comunidad activa de desarrolladores y usuarios, con actualizaciones constantes y una enorme cantidad de paquetes adicionales que amplían sus capacidades.\nUna de las principales razones por las que R es tan popular es su flexibilidad. A diferencia de herramientas de software más rígidas, que solo permiten aplicar métodos predefinidos, R ofrece un lenguaje de programación completo que permite desarrollar soluciones adaptadas a problemas específicos. Esto significa que los usuarios pueden definir sus propias funciones, automatizar procesos y realizar simulaciones personalizadas, algo fundamental cuando se trabaja con problemas complejos que requieren enfoques innovadores.\nSin embargo, esta flexibilidad también implica una curva de aprendizaje más pronunciada en comparación con herramientas en las que sólo hay apuntar con el mouse y hacer clic para elegir algunas opciones en un menú. Algunos programadores provenientes de otros lenguajes pueden encontrar a R poco intuitivo o un tanto ambiguo en algunas cuestiones, pero es que ha sido pensado como una herramienta de programación para profesionales no formados en esa disciplina.\nLa comunidad de desarrolladores y usuarios de R ha desarrollado múltiples soluciones para hacer el lenguaje cada vez más eficiente y accesible. Existen paquetes optimizados para manejar grandes volúmenes de datos con rapidez y entornos o plataformas como RStudio, Shiny y Quarto que han ampliado el alcance de R, permitiendo desde el desarrollo de aplicaciones interactivas hasta la implementación de modelos en producción. Gracias a este continuo desarrollo del ecosistema R, este software es una opción potente y versátil para la Estadística y Ciencia de Datos.\n\nEste libro, y la asignatura a la que pertenece, no se enfoca en las poderosas herramientas de análisis de datos que ofrece R, como la modelización estadística, la manipulación de datos o la visualización gráfica. En su lugar, enseñaremos fundamentos generales de programación, y los ejemplificaresmos particularemente con R. Por ejemplo, en lugar de usar funciones que ya fueron programadas por otras personas, reinventaremos la rueda y crearemos nuestras propias funciones; o en lugar de usar paquetes que nos ayudan a realizar procesos iterativos con gran eficiencia, exploraremos estructuras de control tradicionales como bucles. Es decir, frente a variados problemas vamos a dedicarnos a crear soluciones que ya existen y están disponibles en R, pero lo haremos con el fin de utilizar dicho lenguaje para aprender y ejercitar nociones básicas de programación. Esto nos ayudará a desarrollar un pensamiento algorítmico y ganar habilidad para generar soluciones propias y comprender con mayor profundidad lo que sucede “detrás de escena” en cada análisis.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Programación</span>"
    ]
  },
  {
    "objectID": "capitulos/01_b_primeros_pasos.html",
    "href": "capitulos/01_b_primeros_pasos.html",
    "title": "2  Primeros pasos con R y RStudio",
    "section": "",
    "text": "2.1 R y RStudio\nSi bien R será nuestro medio de comunicación con la computadora, vamos a usarlo a través de otro programa que brinda algunas herramientas para facilitar nuestro trabajo de programación, es decir, vamos a usar un entorno integrado de desarrollo (o IDE, por integrated development environment). Un IDE es un programa que hace que la codificación sea más sencilla porque permite manejar varios archivos de código, visualizar el ambiente de trabajo, utilizar resaltado con colores para distintas partes del código, emplear autocompletado para escribir más rápido, explorar páginas de ayuda, implementar estrategias de depuración e incluso intercalar la ejecución de instrucciones con la visualización de los resultados mientras avanzamos en el análisis o solución del problema. El IDE más popularmente empleado para programar con R es RStudio.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con R y RStudio</span>"
    ]
  },
  {
    "objectID": "capitulos/01_b_primeros_pasos.html#instalación",
    "href": "capitulos/01_b_primeros_pasos.html#instalación",
    "title": "2  Primeros pasos con R y RStudio",
    "section": "2.2 Instalación",
    "text": "2.2 Instalación\nPara instalar estos programas, se deben visitar las páginas oficiales de R y de RStudio, descargar los instaladores y ejecutarlos. En este documento encontrarás una guía paso a paso, o también podés mirar este video con las indicaciones.\nSi experimentás algún problema con la instalación, hay una alternativa para que no pierdas tiempo hasta que los docentes puedan ayudarte a resolverlo. RStudio puede ser usado online sin que lo tengas que instalar. Sólo necesitás conexión a internet. Si necesitás usar esto porque la instalación falló, seguí las instrucciones de este archivo.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con R y RStudio</span>"
    ]
  },
  {
    "objectID": "capitulos/01_b_primeros_pasos.html#paneles-de-rstudio",
    "href": "capitulos/01_b_primeros_pasos.html#paneles-de-rstudio",
    "title": "2  Primeros pasos con R y RStudio",
    "section": "2.3 Paneles de RStudio",
    "text": "2.3 Paneles de RStudio\nCuando se abre RStudio se pueden visualizar tres paneles principales (Figura 2.1):\n\nEn el panel de la izquierda la pestaña más importante es Console (consola), que es donde se ejecutan las instrucciones de R en tiempo real. Es la ventana que usamos para comunicarnos con R. Ahí se escriben las instrucciones para que R las evalúe (también decimos, que las ejecute o corra) y también es el lugar donde se visualizan los resultados.\nEn el panel de arriba a la derecha la pestaña más importante es Environment (entorno o ambiente), que se encarga de mostrar los elementos que tenemos a disposición para programar. Al inicio de la sesión de trabajo, se encuentra vacío.\nEn el panel de abajo a la derecha, las pestañas más importantes son:\n\nFiles: explorador de archivos de la computadora.\nPlots: ventana donde aparecen los gráficos si es que nuestro código produce alguno (no lo usaremos en este curso).\nPackages: listado de los “paquetes” (herramientas adicionales) que tenemos instalados.\nHelp: manual de ayuda de R.\n\n\nMás adelante profundizaremos en el uso de estos componentes de RStudio.\n\n\n\n\n\n\nFigura 2.1: RStudio al abrirlo.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con R y RStudio</span>"
    ]
  },
  {
    "objectID": "capitulos/01_b_primeros_pasos.html#uso-de-la-consola-de-r",
    "href": "capitulos/01_b_primeros_pasos.html#uso-de-la-consola-de-r",
    "title": "2  Primeros pasos con R y RStudio",
    "section": "2.4 Uso de la consola de R",
    "text": "2.4 Uso de la consola de R\nLa consola de R en RStudio permite ejecutar comandos de manera inmediata. Al presionar Enter las instrucciones escritas serán evaluadas, produciendo algún resultado. Por ejemplo, podemos escribir expresiones matemáticas sencillas, como la suma 1 + 2. Para esto, tenemos que hacer clic en la última línea de la consola, al lado del indicador &gt; (llamado prompt), para asegurarnos que el cursor esté allí titilando. La presencia del prompt &gt; en esa última línea nos indica que R está preparado para recibir una nueva instrucción. Escribimos ahí la cuenta 1 + 2 y pulsamos Enter (Figura 2.2).\n\n\n\n\n\n\nFigura 2.2: Ejemplo de una primera instrucción de programación en: la suma entre 1 y 2.\n\n\n\nEl resultado o salida se ve inmediatamente debajo de la instrucción: se trata del número 3, por supuesto. Antes aparece la anotación [1], que indica que la primera y única línea de la salida muestra el primer y único resultado de la instrucción evaluada. En algunas operaciones, la salida está compuesta por muchos elementos y ocupa varias líneas. En ese caso R muestra un número entre corchetes al comienzo de cada línea de la salida, para darnos una idea de cuántos elementos nos está mostrando. Por ahora podemos ignorarlo.\nProbemos con más cálculos matemáticos:\n\n1 + 2\n\n[1] 3\n\n5 * 3\n\n[1] 15\n\n100 / 4\n\n[1] 25\n\n3^2\n\n[1] 9\n\n3 - (2 * 9)\n\n[1] -15\n\n\n\nA veces nos pasa que escribimos una instrucción de forma incompleta y presionamos Enter. En esta situación, la consola muestra al comienzo de la línea el símbolo +, señalando que falta “algo más” para que el comando esté completo y se pueda mostrar el resultado. Tenemos que completar lo que falta y presionar Enter otra vez, o presionar Esc para cancelar esa instrucción y que la consola vuelva a mostrar el prompt &gt;, indicando que podemos escribir el código de nuevo desde cero.\nEn el siguiente ejemplo, en la consola escribí 100 / y presioné Enter dos veces. Como la cuenta quedó incompleta, la consola muestra el +:\n\n&gt; 100 /\n+ \n+ \n\nLa solución es apretar Esc para cancelar, o completar la instrucción:\n\n&gt; 100 /\n+ \n+ \n+ 4\n\n\n\n[1] 25\n\n\nEs importante reconocer que no podemos escribir una nueva instrucción en la consola cuando está el + porque algo de lo anterior quedó incompleto. Debemos solucionarlo, ver que aparezca otra vez el &gt; y entonces sí volver a escribir un comando.\nPor otro lado, si escribimos una instrucción que R no sabe interpretar o que presenta algún tipo de problema, la salida mostrará un mensaje de error. Por ejemplo, el símbolo para hacer divisiones es / y no %. Si lo usamos, pasa esto:\n\n100 % 4\n\nError in parse(text = input): &lt;text&gt;:1:5: unexpected input\n1: 100 % 4\n        ^",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con R y RStudio</span>"
    ]
  },
  {
    "objectID": "capitulos/01_b_primeros_pasos.html#sec-scripts",
    "href": "capitulos/01_b_primeros_pasos.html#sec-scripts",
    "title": "2  Primeros pasos con R y RStudio",
    "section": "2.5 Archivos de código o scripts",
    "text": "2.5 Archivos de código o scripts\nHasta ahora hemos usado la consola de R para ejecutar comandos de manera inmediata. Sin embargo, cuando trabajamos con tareas de programación más complejas, es importante guardar nuestro código para poder reutilizarlo, modificarlo y compartirlo. Para esto, usamos los scripts.\n\nUn archivo de código o script es un archivo de texto que contiene una serie de instrucciones de escritas en algún lenguaje de programación. En lugar de escribir y ejecutar los comandos uno por uno en la consola, podemos escribirlos en un script y ejecutarlos cuando sea necesario. Esto nos permite organizar mejor nuestro trabajo y evitar repetir tareas manualmente. A veces usamos el término programa como sinónimo de script.\n\nEl uso de scripts en lugar de escribir código directamente en la consola tiene varias ventajas:\n\nReproducibilidad: podemos volver a ejecutar nuestro programa sin necesidad de reescribirlo.\n\nOrganización: podemos estructurar el código en secciones claras.\n\nDepuración: es más fácil detectar y corregir errores en un script que en la consola.\n\n\n2.5.1 Crear un script\nPara crear un nuevo script en RStudio podemos seguir algunas de estas opciones:\n\nIr a File &gt; New &gt; R Script.\nUsar el atajo Ctrl + Shift + N.\nHacer clic en el primer ícono de la barra de herramientas (hoja en blanco con signo +)\n\nEl sector izquierdo de RStudio se subdivide en dos paneles: abajo queda la consola y arriba aparece el editor de scripts (Figura 2.5). Podemos crear o abrir más de un script a la vez, cada uno aparece como una pestaña de este panel.\n\n\n\n\n\n\nFigura 2.3: Código escrito en un nuevo script.\n\n\n\n\n\n2.5.2 Escribir código y guardar el script\nUna vez creado el script, podemos escribir ahí todo nuestro código de R. Para no perder el trabajo debemos guardar este documento en nuestra computadora, con alguna de estas opciones:\n\nIr a File &gt; Save.\nUsar el atajo CTRL + S.\nUsar el ícono de guardar en la barra de herramientas.\n\nLa primera vez que guardamos el script recién creado, tendremos que elegir un nombre para el archivo y un lugar en la computadora para su ubicación. En el caso presentado en la Figura 2.4, elegimos el nombre “ejemplos”.\n\n\n\n\n\n\nFigura 2.4: El nuevo script ha sido guardado bajo el nombre `ejemplos.R.\n\n\n\nAhora la pestaña del editor de scripts muestra el nombre elegido para el archivo seguido por .R, es decir, vemos que dice: ejemplos.R. El nombre de un archivo informático se compone de dos partes: la raíz y la extensión. La raíz es el nombre principal que elegimos para identificar el archivo (ejemplos), mientras que la extensión es un sufijo separado por un punto que indica el tipo de archivo y con qué programas se puede abrir. Por ejemplo, los archivos de texto suelen tener la extensión .txt, las imágenes pueden ser .jpg o .png y las hojas de cálculo de Excel suelen ser .xlsx. En el caso de los scripts de R, la extensión es .R, lo que indica que el archivo contiene código en el lenguaje R y puede ser ejecutado dentro de RStudio o cualquier otro entorno compatible. Al guardar un archivo de código, se agrega automáticamente la extensión en el nombre y esto nos permite organizarlos adecuadamente y asegurarnos de que R los reconozca como archivos de código.\n\nSi buscamos el archivo recién creado en el Explorador de archivos de Windows, puede que en su nombre no se vea la extensión. Windows, por defecto, oculta las extensiones de los archivos, pero es posible mostrarlas siguiendo estos pasos:\n\nAbrir el Explorador de archivos.\nAcceder a la configuración de vista:\n\nEn Windows 10 y 11, hacé clic en la pestaña Vista en la parte superior.\n\nEn Windows 11, si no ves la pestaña, haz clic en Ver &gt; Mostrar.\n\n\nActivar la visualización de extensiones: marcá la opción “Extensiones de nombre de archivo”.\n\nHabilitar esta opción es útil para evitar confusiones entre tipos de archivos. Dos archivos diferentes pueden tener en su nombre la misma raíz, pero tratarse de distintas cosas porque tienen diferente extensión.\n\nA medida que seguimos editando nuestro script de código agregando nuevas instrucciones de programación, es conveniente guardar frecuentemente los cambios añadidos.\n\n\n2.5.3 Ejecutar código desde un script\nEscribir código en un script no lo ejecuta automáticamente. Para ejecutarlo, podemos:\n\nSeleccionar una o varias líneas del script y presionar Ctrl + Enter (Windows/Linux) o Cmd + Enter (Mac).\nSeleccionar una o varias líneas y hacer clic en el botón Run en la parte superior del editor.\n\nSi empleamos cualquiera de esas opciones sin tener líneas de código seleccionadas, se ejecutará una sola línea, aquella sobre la cual esté colocado el cursor.\n\n\n\n\n\n\nFigura 2.5: Se han ejecutado las líneas seleccionadas del script. En la consola se ven los resultados.\n\n\n\n\n\n2.5.4 Comentarios en el código\nEn todo lenguaje de programación existe un carácter especial que, al ser colocado al comienzo de una línea de código, le indica al software que dicha línea no debe ser evaluada. Esto se utiliza para incluir comentarios, es decir, líneas escritas en español que ayudan a documentar lo que hace cada parte de nuestro programa. Los comentarios no afectan la ejecución del código y son fundamentales para hacer que nuestro trabajo sea comprensible para nosotros y otras personas. También sirven para marcar distintas partes del script. En R, los comentarios se escriben con el símbolo # (Figura 2.6).\n\n\n\n\n\n\nFigura 2.6: Comentarios en el script. Todo el contenido del script fue evaluado, por eso se ve también en la consola. Las líneas comentadas son ignoradas, sólo se muestran resultados para las demás.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con R y RStudio</span>"
    ]
  },
  {
    "objectID": "capitulos/01_b_primeros_pasos.html#sec-funciones",
    "href": "capitulos/01_b_primeros_pasos.html#sec-funciones",
    "title": "2  Primeros pasos con R y RStudio",
    "section": "2.6 Funciones",
    "text": "2.6 Funciones\nEn los ejemplos anteriores hemos realizado algunas operaciones básicas, como sumas o multiplicaciones. Otros cálculos matemáticos requieren que usemos funciones. Por ejemplo, para calcular una raíz cuadrada debemos usar la función sqrt (del inglés squared root):\n\nsqrt(49)\n\n[1] 7\n\n\nUsamos funciones como sqrt para pedirle a R que realice algún tipo de operación. Como resultado R nos devuelve cierta respuesta o información (“salida”).\nLas funciones están representadas por su nombre, seguido por los paréntesis (). Dentro de los paréntesis se colocan las porciones de información que queremos compartir con la función, que reciben el nombre de argumentos o parámetros. Una función puede depender de uno o más argumentos. Si hay más de uno, se separan con comas.\nCuando usamos una función, generalmente se dice que la estamos llamando, invocando o corriendo. Por ejemplo, corremos la función log con el argumento 100. Esta función calcula, por defecto, el logaritmo natural:\n\nlog(100)\n\n[1] 4.60517\n\n\nEn este caso 100 representa un valor numérico que se pasa como argumento a la función para que la misma opere. Algunas funciones predefinidas en R pueden trabajar con más de un argumento, en cuyo caso hay que enumerarlos dentro de los paréntesis, separados con comas. Por ejemplo, si en lugar de calcular el logaritmo natural (cuya base es la constante matemática \\(e\\)), queremos calcular un logaritmo en base 10, podemos hacer lo siguiente:\n\n# Logaritmo de 100 en base 10\nlog(100, 10)\n\n[1] 2\n\n\n¿Cómo sabemos que la función log() se puede usar de esa forma, con uno o dos argumentos, cambiando o no el valor de la base con respecto a la cual toma el logaritmo? Lo aprendemos al leer el manual de ayuda de R.\nToda función de R viene con un instructivo que detalla cómo se usa, qué argumentos incluye y otras aclaraciones. Lo encontramos en la pestaña de Ayuda (Help) en el panel de abajo a la derecha en RStudio. Otras formas de abrir la página de ayuda sobre una función es correr en la consola alguna de estas sentencias:\n\nhelp(log)\n?log\n\nEsa página de ayuda tiene bastante información, porque reúne explicaciones sobre muchas funciones relacionadas con logaritmos y exponenciales, pero podemos detenernos en algunas partes más importantes (Figura 2.7).\n\n\n\n\n\n\nFigura 2.7: Captura de pantalla de la ayuda sobre la función log().\n\n\n\nEn la sección Usage (“uso”) descubrimos que la función log() puede usarse con dos argumentos: x y base. En la sección Arguments entendemos que x es el número al cual le vamos a sacar el logaritmo y base es la base con respecto a la cual se toma el logaritmo. Por eso, al correr log(100, 10), estamos calculando el logaritmo de x = 100 con base = 10.\nVemos, además, una diferencia en la forma en que x y base aparecen en la descripción: log(x, base = exp(1)). Cuando un argumento tiene un signo = significa que tiene asignado un valor por defecto y que no es obligatorio usarlo. Por eso, cuando corremos log(100) estamos calculando el logaritmo de x = 100 con la base elegida por R: base = exp(1), que es la forma que tiene R de nombrar a la constante \\(e = 2.718282...\\) (es el logaritmo natural). Si quiero cambiar la base, debo proveer un valor, por ejemplo, log(100, 10). Por el contrario, el argumento x no tiene asignado un valor por default. Eso significa que obligatoriamente tenemos que proveer un valor para el mismo.\nR también permite usar una función escribiendo los nombres de los argumentos, lo cual muchas veces es muy esclarecedor, en especial cuando las funciones llevan muchos argumentos:\n\nlog(x = 100, base = 10)\n\n[1] 2\n\n\nSi escribimos los nombres de los parámetros explícitamente como en el caso anterior, podemos cambiar su orden, sin alterar el resultado:\n\nlog(base = 10, x = 100)\n\n[1] 2\n\n\nSi no escribimos los nombres, el orden importa. R hace corresponder los valores provistos con los argumentos presentados en la ayuda sobre la función, uno por uno, en orden:\n\n# Toma el logaritmo de x = 100 con base = 10\nlog(100, 10)\n\n[1] 2\n\n# Toma el logaritmo de x = 10 con base = 100\nlog(10, 100)\n\n[1] 0.5\n\n\n\nPresentamos los siguientes ejemplos a modo de resumen:\n\n# Tres usos equivalentes de la función para obtener el \n# logaritmo de x = 100 con base = 10:\nlog(100, 10)\n\n[1] 2\n\nlog(x = 100, base = 10)\n\n[1] 2\n\nlog(base = 10, x = 100)\n\n[1] 2\n\n# Si no indico la base, se toma el valor por defecto (logaritmo \n# natural). Ambas expresiones son equivalentes:\nlog(100)\n\n[1] 4.60517\n\nlog(x = 100)\n\n[1] 4.60517\n\n# Si no indico el argumento obligatorio x, obtengo un error:\nlog(base = 10)\n\nError: argument \"x\" is missing, with no default",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos con R y RStudio</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html",
    "href": "capitulos/01_c_objetos.html",
    "title": "3  Objetos y ambiente",
    "section": "",
    "text": "3.1 Objetos\nAnteriormente usamos R para realizar cálculos matemáticos como:\n5 * 6\n\n[1] 30\nLos operandos en ese cálculo y su resultado no están guardados en ningún lugar de nuestra computadora. Podríamos decir que lo que vemos ahí son las huellas de algunos números que existieron brevemente en la memoria de nuestra computadora pero ya desaparecieron. Si queremos usar ese resultado para realizar otro cálculo, tendremos que pedirle a R que calcule 5 * 6 de nuevo.\nClaramente, al resolver problemas complejos no podemos trabajar con resultados o valores efímeros. Tenemos que guardarlos en algún lugar para poder reutilizarlos. En R podemos hacer:\nx &lt;- 5 * 6\nEn este caso que estamos analizando, x es un ejemplo de un objeto creado por nosotros.\nUn nuevo objeto se crea con el operador de asignación (&lt;-, “operador flecha”). Como lo vamos a usar muchísimas veces, es conveniente recordar su atajo para escribirlo rápidamente con el teclado: Alt + - (teclas Alt y guión medio). De esta forma, informalmente la línea x &lt;- 5 * 6 puede ser leída así: “creamos un objeto llamado x que contiene al resultado de la operación 5 * 6 (30)”.\nUna vez que almacenamos un valor en x, podemos utilizarlo en nuevos cálculos:\nx * 100\n\n[1] 3000\n\n80 - x\n\n[1] 50\nHay distintos tipos de objetos, algunos con estructuras muy simples (como aquellos que sólo almacenan un único valor, al igual que x en el ejemplo) y otros mucho más complejos (como aquellos que sirven para representar conjuntos de datos completos o resultados de algún análisis). Cada lenguaje de programación propone su propio catálogo de tipos de objetos y cada programador puede crear otros tipos nuevos. Durante las primeras unidades sólo emplearemos el tipo de objeto más sencillo que R ofrece.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html#objetos",
    "href": "capitulos/01_c_objetos.html#objetos",
    "title": "3  Objetos y ambiente",
    "section": "",
    "text": "Los objetos son estructuras capaces de almacenar las distintas piezas de información, (o datos), que podemos manipular para resolver una tarea de programación. Dependiendo de las características de un objeto en particular, podemos hacer con él diferentes operaciones. Nuestro programa, a lo largo de su ejecución, va creando o modificando los objetos existentes.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html#sec-vetor-atomico",
    "href": "capitulos/01_c_objetos.html#sec-vetor-atomico",
    "title": "3  Objetos y ambiente",
    "section": "3.2 Vectores atómicos de R",
    "text": "3.2 Vectores atómicos de R\nEl tipo de objeto más simple y básico en R se llama vector atómico (atomic vector). De hecho, en el ejemplo, x es un vector atómico que hospeda un único valor numérico. En Matemática, la palabra “vector” hace referencia a un conjunto de números ordenados. Los vectores atómicos de R también pueden contener más de un valor, pero por ahora sólo consideraremos situaciones donde cada vector atómico contiene un sólo valor (como x). A los objetos que se usan para almacenar un solo valor a veces también se les dice variables (porque suele ocurrir que ese valor va cambiando a lo largo del programa).\nUn vector atómico puede guardar otras cosas además de números. R define seis tipos básicos de vectores atómicos dependiendo de cómo son los datos que guardan: doubles, integers, characters, logicals, complex y raw1. Los últimos dos sirven para guardar números complejos y bytes en crudo, respectivamente y muy rara vez son usados para tareas de análisis de datos, por lo cual no los volveremos a nombrar. Vamos a ver a los otros, uno por uno.\n\n3.2.1 Doubles (dobles)\nUn vector atómico de tipo double almacena números reales (positivos o negativos, grandes o chicos, con decimales o sin decimales). Casi siempre que usamos números para analizar datos en R, empleamos este tipo de vector. Con estos objetos podemos realizar operaciones aritméticas comunes, como en los ejemplos que ya vimos antes.\nLa función typeof() se usa para preguntar a R de qué tipo es un objeto:\n\ntypeof(x)\n\n[1] \"double\"\n\n\n\n\n3.2.2 Integers (enteros)\nUn vector atómico de tipo integer también almacena números, pero sólo números enteros. Muchos lenguajes de programación tratan a los números enteros de forma diferente al resto de los números porque utilizan estrategias especiales para almacenarlos en la memoria de la compu (ocupan menos espacio y su representación tiene mayor precisión).\nPara distinguir a los integers de los doubles, R los muestra con una L al costado. De hecho, podemos crear un vector atómico de tipo integer agregando la L\n\ny &lt;- 1L\ntypeof(y)\n\n[1] \"integer\"\n\n\nEn aplicaciones de análisis de datos, es raro que los números con los que se trabaja sean sólo enteros, por lo que podemos prestarle poca atención a esto por ahora. Es bueno saber que existen, porque en algunas salidas a veces aparece esa L y ahora sabemos de qué se trata.\nEn algunos contextos, R directamente les dice numeric tanto a los doubles como a los integers.\n\n\n3.2.3 Characters (caracteres)\nUn vector atómico de tipo character almacena texto, es decir, una cadena de caracteres (una palabra o palabras). No es posible hacer operaciones matemáticas con este tipo de vector. Para crear un vector de tipo character debemos encerrar entre comillas el texto que será almacenado en él:\n\nz &lt;- \"Hola, ¿cómo estás?\"\nz\n\n[1] \"Hola, ¿cómo estás?\"\n\ntypeof(z)\n\n[1] \"character\"\n\n\n\n\n3.2.4 Logicals (lógicos)\nUn vector atómico de tipo logical puede almacenar el valor lógico TRUE (verdadero) o el valor lógico FALSE (falso). Si bien es poco común que este tipo de valores aparezca de forma natural en conjuntos de datos a analizar, son sumamente importantes. Permiten hacer comparaciones y entender su resultado, así como también evaluar condiciones para decidir o no implementar algunas acciones en el proceso que estamos llevando adelante.\nPodemos crear un vector logical así:\n\nv &lt;- TRUE\nv\n\n[1] TRUE\n\ntypeof(v)\n\n[1] \"logical\"\n\n\nNotar que los valores lógicos no se escriben entre comillas, puesto que no son cadenas de texto. Tal vez crear vectores lógicos no es lo más común; es más frecuente que los valores lógicos surjan como resultado de algunas operaciones. Por ejemplo:\n\nx &gt; y\n\n[1] TRUE\n\nx &lt; y\n\n[1] FALSE\n\nis.logical(x)\n\n[1] FALSE\n\nis.logical(v)\n\n[1] TRUE\n\nis.numeric(x)\n\n[1] TRUE\n\n\n\n¿Para qué necesitamos distintos tipos de vectores atómicos? Para poder establecer qué operaciones se pueden realizar con unos y otros, y que todo tenga sentido. Por ejemplo, podemos hacer sumas aritméticas con vectores numéricos pero no con vectores carácter:\n\n# Se puede:\nx * 100\n\n[1] 3000\n\nx + y\n\n[1] 31\n\n# No se puede:\nx + z\n\nError in x + z: non-numeric argument to binary operator\n\n\n\n\nSeleccionar la respuesta correcta.\n¿Cuál de los siguientes es un valor numérico?\n\n “dos” “2” 2\n\n¿Cuál de los siguientes es un valor lógico?\n\n FALSE “FALSE”",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html#nombres-de-los-objetos",
    "href": "capitulos/01_c_objetos.html#nombres-de-los-objetos",
    "title": "3  Objetos y ambiente",
    "section": "3.3 Nombres de los objetos",
    "text": "3.3 Nombres de los objetos\nDe manera general, al nombre de un objeto se le dice identificador, ya que se trata de secuencia de caracteres que sirve para identificarlo a lo largo de un programa. Nombrar los objetos hace posible referirse a los mismos. La elección de los identificadores es una tarea del programador, pero cada lenguaje tiene sus propias reglas. Por ejemplo, en R los nombres de los objetos:\n\ndeben empezar con una letra o un punto (no pueden empezar con un número);\nsólo pueden contener letras, números, guiones bajos y puntos; y\nno se pueden usar las siguientes palabras como nombres, ya que son están reservadas por el lenguaje: break, else, FALSE, for, function, if, Inf, NA, NaN, next, repeat, return, TRUE, while.\n\nEs aconsejable elegir un nombre que sea representativo de la información que va a guardar el objeto, ya que esto facilita la lectura y la comprensión tanto del algoritmo como del programa. Por ejemplo, si se necesita un objeto para guardar el valor numérico del precio de algún producto, el identificador p sería una mala elección, mientras que precio sería mejor. Si se necesitan varios identificadores para distinguir los precios de diversos productos, podríamos usar algo como precio_manzana, precio_banana, etc.\nPor otro lado, no es posible usar como identificador a precio manazana, puesto que un nombre no puede tener espacios. Otra opción podría ser preciomanzana o precioManzana, pero en este curso seguimos la convención de usar guiones bajos para facilitar la lectura de nombres compuestos por más de una palabra (esto se conoce como snake case).\nEs importar que R distingue entre mayúsculas y minúsculas, por lo que precio y Precio pueden referirse a distintos objetos, con diferentes valores almacenados:\n\nprecio &lt;- 15\nPrecio &lt;- 2\nprecio + Precio\n\n[1] 17\n\n\nNo es aconsejable tener objetos cuyos nombres sólo difieran en mayúsculas o minúsculas como en el ejemplo anterior, puesto que sirve para confusión. En general, preferimos evitar usar mayúsculas.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html#actualizar-la-información-guardada-en-un-objeto",
    "href": "capitulos/01_c_objetos.html#actualizar-la-información-guardada-en-un-objeto",
    "title": "3  Objetos y ambiente",
    "section": "3.4 Actualizar la información guardada en un objeto",
    "text": "3.4 Actualizar la información guardada en un objeto\nEl valor guardado en un objeto puede cambiar en cualquier momento del programa. Además, podemos usar otros objetos para calcular el valor que será guardado. Por ejemplo, imaginemos que un programa contabiliza el stock disponible de un artículo en un comercio. Inicialmente había 43 artículos, pero en el día se vendieron 29 y se compraron otros 12 al proveedor para reponer. Al finalizar la jornada, para saber cuántos hay en stock hay que tomar la cantidad disponible original, restar la cantidad que se vendió y sumar la cantidad que se compró. El código podría lucir así:\n\nstock &lt;- 43\nventas &lt;- 29\ncompras &lt;- 12\nstock &lt;- stock - ventas + compras\nstock\n\n[1] 26\n\ncat(\"Hay un stock de\", stock, \"artículos disponibles.\")\n\nHay un stock de 26 artículos disponibles.\n\n\n\nEn el ejemplo anterior usamos por primera vez la función cat() para emitir un mensaje, concatenando cadenas de texto encerradas entre comillas y el valor de una variable a la cual hacemos referencia por su nombre (stock).\n\nEl valor 43 que originalmente estaba guardado en stock se perdió para siempre en el preciso momento cuando se ejecutó la línea stock &lt;- stock - ventas + compras, que “sobrescribió” su valor. Es importante sobrescribir el valor de un objeto sólo si estamos seguros de que es lo correcto.\nTambién se debe tener en cuenta que podemos reemplazar el objeto representado con un nombre por otro de un tipo diferente, y a R no le va a molestar:\n\n# x es un vector atómico de tipo numeric:\nx &lt;- 100\nx\n\n[1] 100\n\n# ahora x pasa a ser un vector atómico de tipo caracter:\nx &lt;- \"hola\"\nx\n\n[1] \"hola\"\n\n\nOtros lenguajes no admiten este comportamiento. Por el contrario, requieren se “declare” el nombre y el tipo de cada objeto antes de ser usados y, si bien se puede actualizar su valor, éste siempre debe ser del mismo tipo. R es un lenguaje dinámico que no tiene este recaudo.\n\nExpresiones como “crear un objeto llamado x que contiene el valor 100” o “sobreescribir, actualizar o reemplazar su valor” nos permiten imaginar lo que sucede y encarar tareas generales de programación en R, pero en realidad son formas simplificadas y poco precisas de describir procesos más complejos relacionados al funcionamiento de R. Estudiantes con experiencia en programación pueden opcionalmente referirse a este material para leer más.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html#sec-ambiente",
    "href": "capitulos/01_c_objetos.html#sec-ambiente",
    "title": "3  Objetos y ambiente",
    "section": "3.5 Ambiente",
    "text": "3.5 Ambiente\n\nEn R, un environment (entorno o ambiente) es un espacio donde se almacenan los objetos creados durante una sesión de trabajo. Se trata una estructura clave en la gestión de variables y funciones dentro de un programa.\n\nDurante la evaluación de un programa coexisten muchos environments. Vamos a hablar un poco más de esto cuando aprendamos a crear nuevas funciones, pero en general podemos programar en R sin preocuparnos por este tema, que es bastante complejo y avanzado.\nLo fundamental es saber que el conjunto de objetos que vamos creando en nuestro programa forman parte de un ambiente llamado Global Environment y es el que vemos en la pestaña Environment del panel superior derecho de RStudio (Figura 14.1).\n\n\n\n\n\n\nFigura 3.1: Captura de pantalla del Global Environment.\n\n\n\nTambién podemos ver en la consola un listado de todos los nombres de los objetos que existen en el ambiente con la función ls():\nls()\n[1] \"v\"               \"x\"              \"y\"               \"z\" \nLos objetos que aparecen listados en esta salida o en el panel Environment son los que podemos usar para programar, porque están disponibles en nuestro ambiente. Si por error queremos usar un objeto que aún no fue definido en el ambiente global, obtenemos un error así:\n\nw * 10\n\nError: object 'w' not found\n\n\nSi necesitamos borrar un objeto del ambiente global podemos usar rm() indicando como argumento el nombre del objeto a eliminar:\n\nrm(x)\n\nSi necesitamos borrar todos los objetos del ambiente podemos usar el ícono de la escoba en la pestaña Environment o ejecutar:\n\nrm(list = ls())\n\nA pesar de que el ambiente nos muestre todos los objetos creados durante el trabajo o análisis, es fundamental que el código que los generó esté siempre escrito y guardado en un script. Con un script siempre es posible recrear el entorno de trabajo, pero si sólo tenemos los objetos en el ambiente, no podemos adivinar con qué código fueron creados. Para asegurar que nuestros scripts sean la referencia principal y es el respaldo de todo lo que se hace en un análisis de datos, se recomienda configurar RStudio para que no guarde automáticamente el ambiente cuando se cierra. Esto se logra yendo al menú Tools &gt; Global Options y estableciendo las opciones de configuración tal como se observa en la Figura 3.2. Aunque al principio puede resultar incómodo, ya que cada vez que reinicies RStudio deberás volver a ejecutar el código para generar tus objetos, esta práctica evita problemas a largo plazo. Dejar solo los resultados en el entorno sin registrar el código que los generó puede dificultar la reproducibilidad del análisis en el futuro.\n\n\n\n\n\n\nFigura 3.2: Estas opciones garantizan que el ambiente de trabajo esté limpio cada vez que iniciamos RStudio.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_c_objetos.html#footnotes",
    "href": "capitulos/01_c_objetos.html#footnotes",
    "title": "3  Objetos y ambiente",
    "section": "",
    "text": "Los nombramos en inglés puesto que esos son sus nombres formales.↩︎",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Objetos y ambiente</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html",
    "href": "capitulos/01_d_operadores.html",
    "title": "4  Operadores",
    "section": "",
    "text": "4.1 Operadores aritméticos\nLos operadores aritméticos permiten realizar operaciones matemáticas con vectores atómicos que almacenen valores numéricos, como double o integer (Tabla 4.1).\nLos operadores aritméticos actúan con un orden de prioridad establecido, también conocido como orden de evaluación u orden de precedencia, tal como estamos acostumbrados en matemática. Las expresiones entre paréntesis se evalúan primero. Si hay paréntesis anidados se evalúan desde adentro hacia afuera. Dentro de una misma expresión, los operadores se evalúan en este orden:\nSi la expresión presenta operadores con igual nivel de prioridad, se evalúan de izquierda a derecha.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html#operadores-aritméticos",
    "href": "capitulos/01_d_operadores.html#operadores-aritméticos",
    "title": "4  Operadores",
    "section": "",
    "text": "Tabla 4.1: Operadores aritméticos.\n\n\n\n\n\n\n\n\n\n\n\nOperación\nOperador\nEjemplo de uso\nResultado con x &lt;- 7 e y &lt;- 3\n\n\n\n\nSuma\n+\nx + y\n10\n\n\nResta\n-\nx - y\n4\n\n\nMultiplicación\n*\nx * y\n21\n\n\nDivisión\n/\nx / y\n2.33\n\n\nPotenciación\n^\nx ^ y\n343\n\n\nDivisión entera\n%/%\nx %/% y\n2\n\n\nDivisión módular (resto de la división)\n%%\nx %% y\n1\n\n\n\n\n\n\n\n\nPotenciación (^)\nDivisión entera y módulo (%/%, %%)\nMultiplicación y división (*, /)\nSuma y resta (+, -)\n\n\n\n\n\n\nTabla 4.2: Ejemplos de operaciones aritméticas según el orden de precedencia de R.\n\n\n\n\n\nOperación\nResultado\n\n\n\n\n4 + 2 * 4\n12\n\n\n23 * 2 / 5\n9.2\n\n\n3 + 5 * (10 - (2 + 4))\n23\n\n\n2.1 * 1.5 + 12.3\n15.45\n\n\n2.1 * (1.5 + 12.3)\n28.98\n\n\n1 %% 4\n1\n\n\n8 * (7 - 6 + 5) %% (1 + 8 / 2) - 1\n7\n\n\n\n\n\n\n\n\nLos operadores aritméticos también se pueden aplicar con valores lógicos. En este caso, TRUE es considerado como 1 y FALSE, como 01:\n\nTRUE + TRUE\n\n[1] 2\n\nTRUE + FALSE\n\n[1] 1",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html#operadores-relacionales-o-de-comparación",
    "href": "capitulos/01_d_operadores.html#operadores-relacionales-o-de-comparación",
    "title": "4  Operadores",
    "section": "4.2 Operadores relacionales o de comparación",
    "text": "4.2 Operadores relacionales o de comparación\nLos operadores relacionales sirven para comparar dos valores de cualquier tipo y dan como resultado un valor lógico, TRUE o FALSE.\n\n\n\nTabla 4.3: Operadores relacionales\n\n\n\n\n\n\n\n\n\n\n\nComparación\nOperador\nEjemplo de uso\nResultado con x &lt;- 7 e y &lt;- 3\n\n\n\n\nMayor que\n&gt;\nx &gt; y\nTRUE\n\n\nMenor que\n&lt;\nx &lt; y\nFALSE\n\n\nMayor o igual que\n&gt;=\nx &gt;= y\nTRUE\n\n\nMenor o igual que\n&lt;=\nx &lt;= y\nFALSE\n\n\nIgual a\n==\nx == y\nFALSE\n\n\nDistinto a\n!=\nx != y\nTRUE\n\n\n\n\n\n\n\nEjemplos del uso de operadores relacionales:\n\na &lt;- 3\nb &lt;- 4\nd &lt;- 2\ne &lt;- 10\nf &lt;- 15\n\n(a * b) == (d + e)\n\n[1] TRUE\n\n(a * b) != (f - b)\n\n[1] TRUE\n\n\n\nEs interesante notar que primero se evalúan las operaciones a cada lado de los operadores relacionales y luego se hace la comparación. Es decir, los operadores aritméticos preceden a los relacionales en el orden de prioridad. Por eso, en los ejemplos anteriores en realidad no son necesarios los paréntesis y podríamos omitirlos:\n\na * b == d + e\n\n[1] TRUE\n\na * b != f - b\n\n[1] TRUE\n\n\n\nPara pensar… ¿en base a qué criterio se determina si un valor de tipo character es mayor qué otro? Mirá este ejemplo:\n\ntexto1 &lt;- \"Hola\"\ntexto2 &lt;- \"Chau\"\ntexto3 &lt;- \"Adiós\"\n\ntexto1 &gt; texto2\n\n[1] TRUE\n\ntexto3 &gt; texto2\n\n[1] FALSE\n\n\n\n\n¿Qué valor lógico devuelve esta operación?\n\ntexto1 == \"hola\"\n\n\n TRUE FALSE",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html#operadores-lógicos",
    "href": "capitulos/01_d_operadores.html#operadores-lógicos",
    "title": "4  Operadores",
    "section": "4.3 Operadores lógicos",
    "text": "4.3 Operadores lógicos\nMientras que los operadores relacionales comparan cualquier tipo de valores, los operadores lógicos sólo toman operandos de tipo logical y producen también un resultado lógico.\n\n\n\nTabla 4.4: Operadores lógicos\n\n\n\n\n\n\n\n\n\n\n\nOperación\nOperador\nEjemplo de uso\nResultado con x &lt;- TRUE e y &lt;- FALSE\n\n\n\n\nConjunción\n&&\nx && y\nFALSE\n\n\nDisyunción\n||\nx || y\nTRUE\n\n\nNegación\n!\n!x\nFALSE\n\n\n\n\n\n\nVeamos uno por uno:\n\nLa operación de conjunción devuelve un valor TRUE sólo si son verdaderas ambas expresiones que vincula. Ejemplo: (3 &gt; 2) && (3 &gt; 5) resulta en TRUE && FALSE y esto es FALSE.\nLa operación de disyunción devuelve un valor TRUE si al menos una de las dos expresiones que vincula es verdadera. Ejemplo: (3 &gt; 2) || (3 &gt; 5) resulta en TRUE || FALSE y esto es TRUE.\nLa operación de negación niega un valor lógico, es decir, devuelve el opuesto. Ejemplo: !(3 &gt; 2) resulta en !TRUE y esto es FALSE.\n\nLa tabla de verdad o tabla de valores de verdad se utiliza para mostrar todos los resultados posibles de estas operaciones lógicas:\n\n\n\nTabla 4.5: Tabla de la verdad\n\n\n\n\n\nx\ny\n!x\nx && y\nx || y\n\n\n\n\nTRUE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nFALSE\nTRUE\nTRUE\nFALSE\nTRUE\n\n\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\n\n\n\n\n\n\nCon estos operadores es posible construir evaluaciones lógicas algo más elaboradas como los siguientes ejemplos:\n\nDeterminar si el valor numérica guardado en la variable x está entre 5 y 7. Tal vez tu intuición te sugiere que la expresión lógica a evaluar en este caso debe ser 5 &lt; valor &lt; 7, pero esto genera un error en R. Para saber si valor está entre 5 y 7, se tiene que evaluar por separado que valor sea mayor que 5 y también menor que 7, y ambas condiciones deben ser verdaderas.\n\nvalor &lt;- 6.4\n(valor &gt; 5) && (valor &lt; 7)\n\n[1] TRUE\n\nvalor &lt;- 2.1\n(valor &gt; 5) && (valor &lt; 7)\n\n[1] FALSE\n\n\nEstablecer si el valor de tipo carácter almacenado en la variable nacionalidad sea igual a una de dos opciones.\n\nnacionalidad &lt;- \"Argentino\"\n(nacionalidad == \"Uruguayo\") || (nacionalidad == \"Chileno\")\n\n[1] FALSE\n\n\nVerificar que el valor guardado en nacionalidad no coincida con “Argentino”.\n\nnacionalidad &lt;- \"Uruguayo\"\n!(nacionalidad == \"Argentino\")\n\n[1] TRUE\n\n\nChequear que el valor numérico guardado en x no sea igual a 2 ni a 3.\nOpción correcta 1: (x != 2) && (x != 3)\n\n# Da verdadero porque x no es ni 2 ni 3\nx &lt;- 10\n(x != 2) && (x != 3)\n\n[1] TRUE\n\n# Da falso porque x es igual a 3\nx &lt;- 3\n(x != 2) && (x != 3)\n\n[1] FALSE\n\n\nOpción correcta 2: !(x == 2 || x == 3)\n\n# Da verdadero porque x no es ni 2 ni 3\nx &lt;- 10\n!(x == 2 || x == 3)\n\n[1] TRUE\n\n# Da falso porque x es igual a 3\nx &lt;- 3\n!(x == 2 || x == 3)\n\n[1] FALSE\n\n\nOpción incorrecta: (x != 2) || (x != 3)\n\n# Como la primera parte es verdadera (porque x es igual a 3), la\n# conjunción es verdadera, cuando quisiéramos que en este caso el\n# resultado sea FALSO\nx &lt;- 3\n(x != 2) || (x != 3)\n\n[1] TRUE\n\n\n\n\nEs importante notar que todos los paréntesis usados en el código de R de los ejemplos 1, 2 y 4 son innecesarios, puesto que los operadores relacionales preceden a los lógicos en el orden de prioridad. Sin embargo, a veces preferimos usar paréntesis para que la lectura sea más sencilla. Retomando el ejemplo 1, notemos que ambas expresiones son equivalentes:\n\nvalor &lt;- 2.1\n(valor &gt; 5) && (valor &lt; 7)\n\n[1] FALSE\n\nvalor &gt; 5 && valor &lt; 7\n\n[1] FALSE\n\n\n\n\n¿Cuál es el resultado de las siguientes operaciones?\n\nx &lt;- 2\ny &lt;- -2\n\n\nx &gt; 0 && y &lt; 0: TRUEFALSE\nx &gt; 0 || y &lt; 0: TRUEFALSE\n!(x &gt; 0 && y &lt; 0): TRUEFALSE\n\n\n\nTanto para la conjunción como para la disyunción, R provee dos operadores diferentes, los ya mencionados && y || y otros que no repiten el símbolo, & y |. La diferencia entre las dos versiones se hace notar cuando operamos con vectores atómicos que almacenen más de un valor, por lo cual por ahora podemos ignorarla. Usaremos la versión de símbolos dobles.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html#orden-de-precedencia-completo-en-r",
    "href": "capitulos/01_d_operadores.html#orden-de-precedencia-completo-en-r",
    "title": "4  Operadores",
    "section": "4.4 Orden de precedencia completo en R",
    "text": "4.4 Orden de precedencia completo en R\nResumiendo la información anterior, a continuación se presenta el orden de precedencia completo de los operadores en R que utilizaremos2:\n\n\n\nTabla 4.6: Orden de precedencia de los operadores en R.\n\n\n\n\n\n\n\n\n\n\nOrden\nOperaciones\nOperadores\n\n\n\n\n1\nPotenciación\n^\n\n\n2\nSigno de un número (ej: -3)\n+, -\n\n\n3\nDivisión entera y resto\n%/%, %%\n\n\n4\nMultiplicación y división\n*. /\n\n\n5\nSuma y resta\n+. -\n\n\n6\nOperadores de comparación\n&lt;, &gt;, &lt;=, &gt;=, ==, !=\n\n\n7\nNegación\n!\n\n\n8\nConjunción\n&&, &\n\n\n9\nDisyunción\n||, |\n\n\n10\nAsignación\n&lt;-\n\n\n\n\n\n\nDentro de una misma expresión, operadores con igual prioridad se evalúan de izquierda a derecha.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html#evaluación-en-cortocircuito",
    "href": "capitulos/01_d_operadores.html#evaluación-en-cortocircuito",
    "title": "4  Operadores",
    "section": "4.5 Evaluación en cortocircuito",
    "text": "4.5 Evaluación en cortocircuito\nPara evaluar la operación de conjunción x && y, en R se comienza por evaluar la expresión del primer operando x y si su resultado es FALSE ya no se evalúa la expresión y del segundo operando. Esto es porque si x es FALSE, el resultado de x && y ya no depende de y, será siempre FALSE. Por este motivo se dice que el operador && se evalúa en cortocircuito. La evaluación en cortocircuito evita realizar operaciones innecesarias3.\nPor ejemplo:\n\nf &lt;- 1\ng &lt;- 2\n\n# La primera parte da TRUE, se continúa con la segunda, pero da error porque no\n# existe un objeto llamado h\n(g &gt; f) && (f &gt; h)\n\nError: object 'h' not found\n\n\n\n# La primera parte da FALSE, entonces toda la operación será FALSE, no se\n# continúa con la segunda parte, con lo cual no se intenta usar el objeto\n# inexistente h y no hay error\n(g &lt; f) && (f &gt; h)\n\n[1] FALSE\n\n\nLa operación de disyunción también se evalúa en cortocircuito, es decir, si se encuentra que uno de los operandos es TRUE, no hace falta evaluar los restantes, puesto que el resultado general será TRUE:\n\n# Es TRUE porque la primera parte es TRUE, sin evaluar la segunda, que daría\n# error\n(g &gt; f) || (f &gt; h)\n\n[1] TRUE\n\n# Como la primera parte es FALSE, debe evaluar la segunda, no encuentra a h y da\n# error\n(f &gt; g) || (f &gt; h)\n\nError: object 'h' not found",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_d_operadores.html#footnotes",
    "href": "capitulos/01_d_operadores.html#footnotes",
    "title": "4  Operadores",
    "section": "",
    "text": "Esta conversión de un tipo de valor a otro se llama coerción.↩︎\nHay algunos operadores más que no vamos a usar, pero que pueden ser consultados en ?Syntax.↩︎\nEl otro operador de conjunción, &, no evalúa en cortocircuito, además de poseer otras diferencias.↩︎",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "capitulos/01_e_organizacion.html",
    "href": "capitulos/01_e_organizacion.html",
    "title": "5  Organización de archivos",
    "section": "",
    "text": "5.1 Carpetas, archivos y rutas informáticas\nEn las tareas de programación y de análisis de datos se trabaja con muchos archivos de distinto tipo al mismo tiempo (scripts, conjuntos de datos, archivos con resultados, gráficos, etc.). Resulta fundamental mantener un orden para que todo funcione bien y prestar atención dónde guardamos nuestros archivos y elegir esa ubicación de forma cuidadosa.\nEn una computadora, los archivos se organizan de manera jerárquica dentro de carpetas y subcarpetas, lo que facilita su acceso y gestión. La organización de estos archivos sigue un esquema de árbol, donde las carpetas actúan como contenedores que agrupan archivos relacionados. Este sistema permite a los usuarios almacenar y clasificar la información de forma ordenada y accesible.\nLa Figura 5.1 muestra como ejemplo un trabajo de análisis de datos de una encuesta a estudiantes. Dentro de la carpeta Documentos, se ha creado un directorio llamado encuesta_estudiantes para guardar allí absolutamente todos los archivos relacionados con este caso. Incluso se pueden usar subcarpetas para distribuirlos de forma bien clara, dentro de esa carpeta principal. Dentro de esa carpeta, se crearon otras subcarpetas para agrupar los archivos de forma ordenada. Este ejemplo esconde un principio muy importante: es bueno tener la costumbre de crear una carpeta específica para almacenar todos los archivos vinculados al trabajo que estamos realizando y no dejar archivos tirados por cualquier lugar en la computadora.\nCada archivo o carpeta en una computadora tiene una ruta informática o path que indica su ubicación dentro del sistema de almacenamiento. Esta ruta es como una dirección que permite encontrar un archivo o carpeta específica. La ruta se lee desde una ubicación principal en el disco de la computadora y sigue el camino de las carpetas y subcarpetas hasta llegar al archivo deseado.\nPor ejemplo, en relación a la Figura 5.1, la ruta informática que identifica la ubicación de la carpeta datos_crudos es C:\\Users\\Marcos\\Documents\\encuesta_estudiantes\\datos_crudos. Si dentro de ella hay una planilla de Excel con los datos de la encuesta, llamada datos_encuesta.xlsx, su ruta informática será C:\\Users\\Marcos\\Documents\\encuesta_estudiantes\\datos_crudos\\datos_encuesta.xlsx. En sistemas operativos como Windows, las rutas suelen comenzar con una letra de unidad, como “C:”, seguida de las carpetas y subcarpetas.\nCuando guardamos un archivo en algún lugar de la computadora estamos definiendo cuál es su ruta informática para que distintos programas de la computadora puedan encontrarlo. Tener esta noción es fundamental a la hora de programar. Por ejemplo, puede ser que nuestro script de R necesite importar los datos del archivo datos_encuesta.xlsx. Para esto tal vez necesitemos escribir un comando especial que incluya su ruta informática para que R pueda encontrar el archivo. Si no la escribimos bien, R producirá un error diciendo que el archivo no existe.\nTener un buen sistema para ordenar archivos también es una gran recomendación al cursar una carrera universitaria, ya que necesitarás manejar múltiples archivos de distintas asignaturas a la vez. Podrías crear un esquema de trabajo como el de la Figura 5.2.\nUna buena idea adicional es que alojes la carpeta facultad y todo su contenido dentro de algún sistema de sincronización de archivos como Google Drive o OneDrive, para que tengas un respaldo en la nube y puedas acceder al contenido desde el celular u otras computadoras, manteniendo siempre todo sincronizado.\nPara nuestra asignatura, te sugerimos que dentro de la carpeta facultad/anio_1/programacion_1, definas una carpeta distinta para cada unidad o trabajo práctico (por ejemplo, unidad_1, unidad_2, etc.). Esto ayudará a mantener el orden. No hace falta que crees a mano cada una de estas carpetas. Las vamos a crear con RStudio, lo cual resultará en beneficios adicionales.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organización de archivos</span>"
    ]
  },
  {
    "objectID": "capitulos/01_e_organizacion.html#sec-rutas",
    "href": "capitulos/01_e_organizacion.html#sec-rutas",
    "title": "5  Organización de archivos",
    "section": "",
    "text": "Figura 5.1: Organización de carpetas para analizar los datos de una encuesta.\n\n\n\n\n\n\n\nPara saber con exactitud cuál es la ruta informática de un archivo en Windows, podemos seguir alguna de estas opciones:\n\nUsando el Explorador de Archivos: ubicar el archivo, hacer clic derecho y seleccionar “Copiar como ruta”. Luego podemos pegar la ruta en cualquier lugar (Ctrl + V).\nDesde la Barra de Direcciones: abrir la carpeta donde está el archivo, hacer clic en la barra de direcciones, copiar la ruta (Ctrl + C) y al pegarla donde se necesite, agregar manualmente el nombre del archivo.\nDesde las Propiedades del Archivo: hacer clic derecho sobre el archivo y seleccionar “Propiedades”. En la pestaña “General”, copiar el contenido del campo Ubicación y, al pegarlo, agregar el nombre del archivo.\n\nEs importante recordar lo siguiente: si bien Windows usa barras diagonales / para mostrar rutas informáticas, R sólo las reconoce si las escribimos con barras invertidas \\.\n\n\n\n\n\n\n\n\nFigura 5.2: Organización de carpetas para las asignaturas de la facultad.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organización de archivos</span>"
    ]
  },
  {
    "objectID": "capitulos/01_e_organizacion.html#directorio-de-trabajo",
    "href": "capitulos/01_e_organizacion.html#directorio-de-trabajo",
    "title": "5  Organización de archivos",
    "section": "5.2 Directorio de trabajo",
    "text": "5.2 Directorio de trabajo\nComo hemos visto en la sección anterior, nuestra computadora organiza todos sus archivos bajo un sistema jerárquico de carpetas y subcarpetas. Entre todas ellas, en cada sesión de trabajo R posa su mirada en una de forma particular, la cual recibe el nombre directorio de trabajo (o working directory, wd). Aquí es donde R busca los archivos que le pedís que cargue y donde colocará los archivos que le pedís que guarde. El directorio de trabajo por default suele ser la carpeta Documentos o alguna equivalente según el sistema operativo y es la que se muestra en el panel Files cuando iniciamos RStudio. Otras formas de saber cuál es la carpeta de la computadora que actúa como working directory en una sesión de trabajo son:\n\nLeer la ruta informática escrita en la parte superior del panel de la consola, al lado del logo y la versión de R (Figura 5.3).\n\n\n\n\n\n\nFigura 5.3: Indicación del working directory arriba en la consola\n\n\n\nEjecutar en la consola la instrucción getwd(). Por ejemplo:\n\ngetwd()\n\n\"C:/Users/Marcos\"\n\nEse resultado implica que en este momento R puede ver y acceder de manera directa a todos los archivos que hay en esa carpeta, sin necesidad de escribir la ruta informática completa para hacer referencia a cada uno de ellos. Si creamos un nuevo script y apretamos el ícono de guardar, R nos ofrece guardarlo en el working directory. Si queremos importar un conjunto de datos, lo buscará ahí, a menos que le indiquemos otra cosa. Si queremos guardar cualquier resultado de nuestro análisis, también lo guardará en esa carpeta.\nPor esa razón, es muy útil que, al trabajar con R, el working directory no sea la carpeta que aparece por defecto, sino aquella carpeta en la que tengamos guardados todos los archivos referidos al problema que estamos resolviendo. Para poder cambiar y elegir como working directory a cualquier carpeta de nuestra computadora que nos interese podemos usar una instrucción que se llama setwd(). Sin embargo, a continuación aprenderemos algo mejor.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organización de archivos</span>"
    ]
  },
  {
    "objectID": "capitulos/01_e_organizacion.html#sec-organizacion",
    "href": "capitulos/01_e_organizacion.html#sec-organizacion",
    "title": "5  Organización de archivos",
    "section": "5.3 Organización del trabajo con RStudio Projects",
    "text": "5.3 Organización del trabajo con RStudio Projects\nA partir de las dos secciones anteriores, llegamos a las siguientes conclusiones:\n\nCuando encaramos un trabajo de programación o de análisis de datos, tenemos que destinar una carpeta específica de nuestra computadora para guardar ahí todos los archivos relacionados.\nSi estamos usando R, tenemos que setear como working directory a dicha carpeta, para que podamos acceder con facilidad a los archivos y guardar allí los archivos nuevos que generemos, sin tener que depender de rutas informáticas largas.\n\nRStudio nos permite trabajar de esa forma a través los RStudio Projects.\n\nAl crear un RStudio Project (o sencillamente, proyecto), se genera una nueva carpeta en la computadora con el objetivo de colocar allí todos los archivos relacionados con un trabajo específico, incluyendo scripts, datos, gráficos y otros documentos.\n\nPara crear un nuevo proyecto en RStudio, seguimos estos pasos (Figura 5.4):\n\nIr al menú File (Archivo) y seleccionar New Project… (Nuevo Proyecto).\n\nElegir New Directory (Nueva carpeta, Figura 5.4).\nIngresar un nombre para el proyecto y elegir la ubicación donde se guardará en nuestra computadora.\n\nHacer clic en Create Project (Crear Proyecto).\n\n\n\n\n\n\n\nFigura 5.4: Creación de un nuevo proyecto de RStudio.\n\n\n\nComo resultado, se crea una carpeta con el nombre elegido y se reinicia RStudio, con una nueva sesión de trabajo, en la cual dicha carpeta es configurada como working directory. Podemos leer y guardar los archivos relacionados con nuestro trabajo de forma directa en esa carpeta, sin tener que usar rutas informáticas largas.\n\nUsar proyectos de RStudio tiene varias ventajas:\n\nCada proyecto tiene su propia carpeta, lo que evita mezclar archivos de diferentes trabajos (o asignaturas).\nSe automatiza la configuración del directorio de trabajo.\nSe pueden gestionar múltiples trabajos simultáneamente. Podemos cambiar de un proyecto a otro sin perder el contexto de cada análisis (scripts abiertos, objetos en el ambiente, etc.). Abrimos cada proyecto en una instancia de RStudio diferente, pudiendo tener varias abiertas a la vez.\nTodo el código y los archivos quedan organizados en un solo lugar, lo que facilita compartir o retomar un proyecto en el futuro.\n\n\nCuando dejamos de trabajar en el proyecto, ya sea porque terminamos o debemos continuar más tarde, cerramos RStudio y listo. Para continuar trabajando en otro momento, tenemos que volver a abrir el proyecto, de alguna de estas formas:\n\nA diferencia de cualquier otra carpeta, un RStudio Project incluye un archivo de extensión .Rproj. Si lo abrimos, se abre el proyecto una nueva sesión de trabajo en RStudio, que ya tiene seteado como working directory a dicha carpeta.\nEn caso de que ya tengamos RStudio abierto:\n\nPodemos ir a File &gt; Open project y buscar en la computadora la carpeta del proyecto, para seleccionar el archivo .Rproj.\nO bien, podemos seleccionar un proyecto de la lista de proyectos abiertos recientemente (File &gt; Recent projectos o en la esquina superior derecha de RStudio).\n\n\nAl abrir un RStudio Project, los scripts que estaban abiertos en el editor la última vez que trabajamos en este proyecto, vuelven a aparecer tal como los dejamos, sin importar que estemos trabajando de manera intermitente en distintos proyectos.\nAl trabajar con un proyecto, si necesitamos referirnos en el código a la ubicación de un archivo sólo debemos usar rutas informáticas relativas, no absolutas. Una ruta absoluta es la ruta completa, como C:\\Usuarios\\Marcos\\Documentos\\encuesta_estudiantes\\datos_crudos\\datos_encuesta.xlsx. En cambio, una ruta relativa es relativa al working directory, es decir, al directorio de inicio del proyecto. Suponiendo que nuestro proyecto se corresponde con la carpeta encuesta_estudiantes, la ruta relativa que tenemos que usar para ubicar a la planilla de Excel sólo está compuesta por datos_crudos\\datos_encuesta.xlsx.\nLas rutas relativas son importantes: funcionan siempre bien, a pesar de que el código lo use otra persona en otra computadora. La primera parte de la ruta absoluta, que contiene incluso hasta el nombre de usuario, cambia de computadora a computadora, pero la parte que se usa en la ruta relativa es siempre la misma. Todas las computadoras que tengan una copia del proyecto podrán usar el mismo código sin problemas para encontrar a todos los archivos involucrados.\n\nTal vez hayas notados que los nombres de carpeta de los ejemplos lucen algo raros, no tienen espacios, mayúsculas o tildes. Es recomendable usar nombres de carpetas y archivos que no contengan espacios, tildes, la letra “ñ” ni caracteres especiales, y preferiblemente en minúsculas. Esto se debe a que algunos sistemas operativos y programas pueden interpretar estos caracteres de manera diferente, lo que puede generar errores al acceder a los archivos o al ejecutar código. Además, cuando trabajamos con rutas de archivos en R, los espacios pueden causar problemas si no se manejan correctamente. Una práctica común es utilizar guiones bajos (_) o guiones medios (-) en lugar de espacios, por ejemplo, encuesta_estudiantes en lugar de Encuesta de Estudiantes. Esto es una sugerencia que ayuda a evitar errores y asegura que los archivos sean accesibles sin complicaciones en cualquier sistema.\n\n\nVamos a establecer el siguiente modo de trabajo para este curso. En tu computadora, tal como mencionamos antes, creá una carpeta para guardar todo lo relacionado a tu carrera (puede estar en Documentos o dentro de Google Drive u otro sistema de sincronización y respaldo). Luego, creá una subcarpeta para los elementos relacionados al primer año de cursado. A continuación, creá una carpeta para cada materia que estás cursando, incluída Programación 1. El resultado tiene que ser similar al que se ve en la Figura 5.2.\nCada vez que comencemos una nueva etapa en Programación 1, vamos a crear un nuevo proyecto de RStudio para gestionar todos los archivos referidos a ella. Particularmente, ahora es momento de crear un proyecto llamado unidad_1, dentro de la carpeta programacion_1. Guardarás ahí todos los scripts que desarrollaremos a lo largo de la unidad, con ejemplos y soluciones de ejercicios. Cada vez que quieras continuar trabajando en los materiales de esta unidad, tendrás que abrir el proyecto a partir del archivo unidad_1.Rproj. Tomá de ejemplo la Figura 5.4.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organización de archivos</span>"
    ]
  },
  {
    "objectID": "capitulos/01_f_errores_estilo_paquetes.html",
    "href": "capitulos/01_f_errores_estilo_paquetes.html",
    "title": "6  Errores de programación, guías de estilo y paquetes de R",
    "section": "",
    "text": "6.1 Errores de programación\nApenas iniciemos nuestro camino en el mundo de la programación nos daremos cuenta que tendremos siempre ciertos compañeros de viaje: los errores. Muchas veces nos pasará que queremos ejecutar nuestro código y el mismo no anda o no produce el resultado esperado. No importa cuán cuidadosos seamos, ni cuánta experiencia tengamos, los errores están siempre presentes. Con el tiempo y práctica, vamos a poder identificarlos y corregirlos con mayor facilidad, pero probablemente nunca dejemos de cometerlos.\nA los errores en programación se los suele llamar bugs (insecto o bicho en inglés) y el proceso de la corrección de los mismos se conoce como debugging (depuración)1. Se dice que esta terminología proviene de 1947, cuando una computadora en la Universidad de Harvard (la Mark II) dejó de funcionar y finalmente se descubrió que la causa del problema era la presencia de una polilla en un relé electromagnético de la máquina. Sin embargo, otros historiadores sostienen que el término ya se usaba desde antes.\nA continuación se presenta una clasificación de los errores que se pueden cometer en programación:\nLos errores en la programación son tan comunes, que un científico de la computación muy reconocido, Edsger Dijkstra, dijo una vez: “si la depuración es el proceso de eliminar errores, entonces la programación es el proceso de generarlos”. Ante la presencia de uno, no hay más que respirar profundo y con paciencia revisar hasta encontrarlo y solucionarlo.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errores de programación, guías de estilo y paquetes de R</span>"
    ]
  },
  {
    "objectID": "capitulos/01_f_errores_estilo_paquetes.html#errores-de-programación",
    "href": "capitulos/01_f_errores_estilo_paquetes.html#errores-de-programación",
    "title": "6  Errores de programación, guías de estilo y paquetes de R",
    "section": "",
    "text": "La polilla (bug) encontrada por la científica de la computación Grace Hooper en la Mark II fue pegada con cinta en un reporte sobre el malfuncionamiento de la máquina.\n\n\n\n\nErrores de sintaxis. Tal como el lenguaje humano, los lenguajes de programación tienen su propio vocabulario y su propia sintaxis, que es el conjunto de reglas gramaticales que establecen cómo se pueden combinar las distintas partes. Estas reglas sintácticas determinan que ciertas instrucciones están correctamente construidas, mientras que otras no. Cuando ejecutamos un programa, se chequea si el mismo es sintácticamente correcto. Si hemos violado alguna regla, por ejemplo, nos faltó una coma o nos sobra un paréntesis, mostrará un mensaje de error y debemos editar nuestro programa para corregirlo. En estos casos, hay que interpretar el mensaje de error, revisar el código y corregir el error.\nErrores lógicos. Se presentan cuando el programa no tiene errores de sintaxis pero arroja resultados incorrectos o ningún resultado. El software no muestra mensajes de error, debido a que, por supuesto, no sabe cuál es el resultado deseado, sino que sólo se limita a hacer lo que hemos programado. En estos casos hay que revisar el programa para encontrar algún error en su lógica. Este tipo de errores suelen ser los más problemáticos. Algunas ideas para enfrentarlos incluyen volver a pensar paso por paso lo que se debería hacer para solucionar el problema y compararlo con lo que se ha programado, agregar pasos para mostrar resultados intermedios o emplear herramientas especializadas de debugging (llamadas debuggers) para explorar el código paso a paso hasta identificar el error.\nErrores en la ejecución (runtime errors). Se presentan cuando el programa está bien escrito, sin errores lógicos ni sintácticos, pero igualmente se comporta de alguna forma incorrecta. Se dan a pesar de que el programa ande bien en el entorno de desarrollo del programador, pero no cuando algún usuario lo utiliza en algún contexto particular. Puede ser que se intente abrir un archivo que no existe, que el proceso supere la memoria disponible, que tomen lugar operaciones aritméticas no definidas como la división por cero, etc.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errores de programación, guías de estilo y paquetes de R</span>"
    ]
  },
  {
    "objectID": "capitulos/01_f_errores_estilo_paquetes.html#guías-de-estilo",
    "href": "capitulos/01_f_errores_estilo_paquetes.html#guías-de-estilo",
    "title": "6  Errores de programación, guías de estilo y paquetes de R",
    "section": "6.2 Guías de estilo",
    "text": "6.2 Guías de estilo\nEs sumamente importante mantener la prolijidad en la escritura del código para facilitar su lectura, especialmente cuando estamos trabajando con problemas largos. Siempre hay que tener en cuenta de que cuando escribimos un programa, tenemos dos públicos potenciales: integrantes de nuestro equipo de trabajo que tienen leer el código y hacer sus propios aportes y nosotros mismos en el futuro, cuando retomemos código hecho en el pasado y necesitemos interpretar qué es lo que hicimos hacer.\nEs por eso que se establecen conjuntos de reglas para controlar y unificar la forma de escribir programas, que se conocen como guía de estilo. Estas reglas cubren aspectos como, por ejemplo, la forma de escribir comentarios en el código, la utilización de espacios o renglones en blanco, el formato de los nombres para los elementos que creamos nosotros mismos (como las funciones) y para los archivos que generamos, etc. Una guía de estilo no indica la única forma de escribir código, ni siquiera la forma correcta de hacerlo, sino que establece una convención para que todos trabajen de la misma forma, basándose en costumbres que sí se ha visto que pueden tener más ventajas que otras.\nPara programar en R existe una guía de estilo muy popular llamada The tidyverse style guide, creada por los desarrolladores de RStudio (Posit). En este curso vamos a adherir a sus recomendaciones. Si bien es una lectura muy interesante, particularmente si tenés intenciones de profundizar tus conocimientos sobre programación en R, no es necesario que lean dicha guía completa. Por ahora es suficiente con que imiten con atención el estilo que usamos en los ejemplos provistos en esta guía y sigan algunas recomendaciones generales como las siguientes:\n\nComo dijimos antes, escribimos los nombres de nuevos objetos con snake case y en minúscula:\n\nOk: mi_objeto.\nEvitar: MIOBJETO, miObjeto.\n\nEn R los espacios en blanco son ignorados, colocarlos o no no produce errores en el código. Sin embargo, se recomienda hacer uso de los mismos para facilitar la lectura. Se sugiere colocar espacios alrededor del operador de asignación &lt;- y de los operadores matemáticos (excepto la potencia). No colocamos espacio después de abrir o antes de cerrar un paréntesis.\n\nOk: z &lt;- (a + b)^2 / d\nEvitar: z&lt;-( a + b ) ^ 2/d\n\nUsamos un espacio después de poner una coma y entre el signo igual que se usa para definir argumentos en una función:\n\nOk: log(100, base = 10)\nEvitar: log(100 ,base=10)\n\nLos nombres de archivo deben describir su contenido y evitar espacios, símbolos y caracteres especiales, y preferentemente estar escritos en minúsculas.\n\nOk: analisis_exploratorio.R\nEvitar: Análisis exploratorio.R, codigo.r\n\n\nRecordemos siempre que seguir un buen estilo para programar es como hacer uso de una correcta puntuación cuando escribimos, podemos entendernos sin ella, peroesmuchomasdificilleersinolarespetamosno?2",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errores de programación, guías de estilo y paquetes de R</span>"
    ]
  },
  {
    "objectID": "capitulos/01_f_errores_estilo_paquetes.html#paquetes-de-r",
    "href": "capitulos/01_f_errores_estilo_paquetes.html#paquetes-de-r",
    "title": "6  Errores de programación, guías de estilo y paquetes de R",
    "section": "6.3 Paquetes de R",
    "text": "6.3 Paquetes de R\n\n6.3.1 Diseño del sistema R\nR está diseñado como un sistema modular, dividido en dos partes principales:\n\nR Base: Se instala automáticamente cuando descargamos R desde CRAN (Comprehensive R Archive Network). Incluye las funciones fundamentales del lenguaje, como operadores matemáticos, herramientas para manipular datos y funciones estadísticas básicas.\nPaquetes adicionales: Son extensiones opcionales que amplían las funcionalidades de R. Cada paquete es un conjunto de funciones y datos diseñados para tareas específicas, como visualización de datos, modelado estadístico o manipulación avanzada de estructuras de datos.\n\n\n\n6.3.2 Instalación de paquetes\nPara utilizar un paquete en R, primero debemos instalarlo. La mayoría de los paquetes están disponibles en CRAN y, teniendo conexión a internet, se pueden descargar directamente con el siguiente comando:\ninstall.packages(\"nombre-del-paquete\")\nEsto descargará e instalará el paquete en la computadora, permitiéndolo usarlo en futuras sesiones.\n\n\n6.3.3 Carga de paquetes\nDespués de instalar un paquete, es necesario cargarlo en la sesión de R para poder utilizar sus funciones. Es como abrirlo para sacar las funciones que están guardadas dentro. Para hacerlo, usamos la función library():\nlibrary(\"nombre-del-paquete\")\nSi intentás usar una función de un paquete sin haberlo cargado previamente, R mostrará un error indicando que el objeto no fue encontrado.\nEs importante recordar que la instalación de un paquete solo se hace una vez, pero debemos cargarlo en cada nueva sesión de R en la que queramos utilizarlo. Cuando cerramos RStudio, los paquetes se descargan de la memoria, por lo que es necesario volver a llamarlos con library() la próxima vez que los necesitemos.\nEste sistema modular permite que R sea altamente flexible, permitiendo a los usuarios instalar solo las herramientas que realmente necesitan para sus análisis.\n\n\n6.3.4 Creación de paquetes en R\nLos paquetes en R no solo son desarrollados por expertos en estadística y computación, sino también por cualquier persona que quiera compartir herramientas útiles con la comunidad. Investigadores, analistas de datos y programadores contribuyen a la expansión del ecosistema de R creando paquetes que facilitan tareas específicas.\nSi bien algunos paquetes pueden ser muy sofisticados, la creación de uno no es algo exclusivo de grandes desarrolladores. De hecho, al finalizar esta materia, contarás con los conocimientos necesarios para construir tu propio paquete desde cero. Esto te permitirá organizar y compartir funciones de manera eficiente, facilitando su reutilización en distintos proyectos.\n\n\n6.3.5 Paquetes utilizados en esta materia\nComo estaremos aprendiendo nociones de programación, no necesitaremos usar paquetes adicionales en el contexto de esta asignatura, pero sí usarás muchos en otras materias.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errores de programación, guías de estilo y paquetes de R</span>"
    ]
  },
  {
    "objectID": "capitulos/01_f_errores_estilo_paquetes.html#footnotes",
    "href": "capitulos/01_f_errores_estilo_paquetes.html#footnotes",
    "title": "6  Errores de programación, guías de estilo y paquetes de R",
    "section": "",
    "text": "Algunos usan el término bug para referirse exclusivamente a errores lógicos.↩︎\nFrase tomada de acá.↩︎",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errores de programación, guías de estilo y paquetes de R</span>"
    ]
  },
  {
    "objectID": "capitulos/01_g_opcional.html",
    "href": "capitulos/01_g_opcional.html",
    "title": "7  Lectura opcional",
    "section": "",
    "text": "7.1 Breve reseña histórica sobre la programación\nLa historia de la programación está vinculada directamente con la de la computación. Esta palabra proviene del latín computatio, que deriva del verbo computare, cuyo significado es “enumerar cantidades”. Computación, en este sentido, designa la acción y efecto de computar, realizar una cuenta, un cálculo matemático. De allí que antiguamente computación fuese un término usado para referirse a los cálculos realizados por una persona con un instrumento expresamente utilizado para tal fin (como el ábaco, por ejemplo) o sin él. En este sentido, la computación ha estado presente desde tiempos ancestrales, sin embargo debemos remontarnos al siglo XVII para encontrar los primeros dispositivos diseñados para automatizar cómputos matemáticos.\nEn 1617 el matemático escocés John Napier (el mismo que definió los logaritmos) inventó un sistema conocido como los huesos de Napier o huesos neperianos que facilitaba la tarea de multiplicar, dividir y tomar raíces cuadradas, usando unas barras de hueso o marfil que tenían dígitos grabados. Esta fue la base para otras ideas más avanzadas, entre ellas la que dio origen a la primera calculadora mecánica, inventada por el alemán Wilhelm Schickard en 1623, capaz de realizar cómputos aritméticos sencillos funcionando a base de ruedas y engranajes. Se componía de dos mecanismos diferenciados, un ábaco de Napier de forma cilíndrica en la parte superior y un mecanismo en la inferior para realizar sumas parciales de los resultados obtenidos con el aparato de la parte superior. Fue llamado reloj calculador. A partir de aquí se fueron desarrollando otros modelos, todos ellos teniendo en común el hecho de ser puramente mecánicos, sin motores ni otras fuentes de energía. El operador ingresaba números ubicando ruedas de metal en posiciones particulares y al girarlas otras partes de la máquina se movían y mostraban el resultado. Algunos ejemplos son las calculadoras del inglés William Oughtred en 1624, de Blaise Pascal en 1645 (llamada pascalina), la de Samuel Morland en 1666 y las de Leibniz, en 1673 y 1694.\nDe izquierda a derecha: los huesos de Napier (Museo Arqueológico Nacional de España), el reloj calculador de Schickard (Museo de la Ciencia de la Universidad Pública de Navarra) y una pascalina del año 1952\nEl siglo XVIII trajo consigo algunos otros diseños, pero un gran salto se dio a comienzos del siglo XIX de mano de un tejedor y comerciante francés, Joseph Jacquard. En 1801 creó un telar que tenía un sistema de tarjetas perforadas para controlar las puntadas del tejido, de forma que fuera posible programar una gran diversidad de tramas y figuras. Sin saberlo, Jacquard sentó una idea fundamental para la creación de las computadoras.\nUn telar de Jacquard y sus tarjetas perforadas en el Museo de la ciencia y la industria en Mánchester.\nEn 1822 el matemático británico Charles Babbage publicó un diseño para la construcción de una máquina diferencial, que podía calcular valores de funciones polinómicas mediante el método de las diferencias. Este complejo sistema de ruedas y engranajes era el primero que podía trabajar automáticamente utilizando resultados de operaciones previas. Si bien el diseño era viable, por motivos técnicos y económicos no lo pudo concretar (sólo construyó un modelo de menor escala). Sin embargo, Babbage no se dio por vencido y en 1837 presentó el diseño de una máquina analítica, un aparato capaz de ejecutar cualquier tipo de cálculo matemático y que, por lo tanto, se podría utilizar con cualquier propósito. Tal como el telar de Jacquard, la operación de esta máquina sería controlada por un patrón de perforaciones hechas sobre una tarjetas que la misma podría leer. Al cambiar el patrón de las perforaciones, se podría cambiar el comportamiento de la máquina para que resuelva diferentes tipos de cálculos. Para la salida de resultados, la máquina sería capaz de perforar tarjetas. Además, funcionaría con un motor a vapor y su tamaño hubiese sido de 30 metros de largo por 10 de ancho. Si bien Babbage tampoco llegó a concretar en vida este diseño que dejó plasmado en más de 300 dibujos y 2200 páginas por motivos políticos, se lo considera como la primera conceptualización de lo que hoy conocemos como computadora, por lo cual Babbage es conocido como el padre de la computación.\nEn 1843 Lady Ada Lovelace, una matemática y escritora británica, publicó una serie de notas sobre la máquina analítica de Babbage, en las que resaltaba sus potenciales aplicaciones prácticas, incluyendo la descripción detallada de tarjetas perforadas para que sea capaz de calcular los números de Bernoulli. Al haber señalado los pasos para que la máquina pueda cumplir con estas y otras tareas, Ada es considerada actualmente como la primera programadora del mundo, a pesar de que en la época no fue tomada en serio por la comunidad científica, principalmente por su condición de mujer.\nCharles Babbage, Ada Lovelace y el algoritmo que publicó Ada para calcular los números de Bernoulli con la máquina analítica de Charles.\nLa utilidad de las tarjetas perforadas quedó confirmada en 1890, cuando Herman Hollerith las utilizó para automatizar la tabulación de datos en el censo de Estados Unidos. Las perforaciones en determinados lugares representaban información como el sexo o la edad de las personas, logrando que se pudieran lograr clasificaciones y conteos de forma muy veloz. Así, se tardaron sólo 3 años en procesar la información del censo, cinco años menos que en el anterior de 1880. Con el fin de comercializar esta tecnología, Hollerith fundó una compañía que terminaría siendo la famosa International Business Machine (IBM), empresa líder en informática hasta el día de hoy.\nSin embargo, la visión de Babbage de una computadora programable no se hizo realidad hasta los años 1940, cuando el advenimiento de la electrónica hizo posible superar a los dispositivos mecánicos existentes. John Atanasoff y Clifford Berry (Iowa State College, Estados Unidos) terminaron en 1942 en Iowa State College (Estados Unidos) una computadora electrónica capaz de resolver sistemas de ecuaciones lineales simultáneas, llamada ABC (por “Atanasoff Berry Computer”). La misma contaba con 300 tubos de vacío, unas bombillas de vidrio con ciertos componentes que podían recibir y modificar una señal eléctrica mediante el control del movimiento de los electrones produciendo una respuesta, que habían sido presentados por primera vez en 1906 por el estadounidense Lee De Forest. La ABC dio comienzo a la conocida como la primera generación de computadoras basadas en el empleo de tubos de vacío.\nLa primera computadora electrónica de propósito general fue la ENIAC, Electronic Numerical Integrator and Computer, completada por Presper Eckert y John Mauchly en la Universidad de Pensilvania. Podía realizar cinco mil operaciones aritmética por segundo y tenía más de 18000 tubos de vacío, ocupando una sala de 9x15 metros en un sótano de la universidad donde se montó un sistema de aire acondicionado especial.\nNi la ABC ni la ENIAC eran reprogramables: la ABC servía el propósito específico de resolver sistemas de ecuaciones y la ENIAC era controlada conectando ciertos cables en un panel, lo que hacía muy compleja su programación. El siguiente gran avance se produjo en 1945, cuando el matemático húngaro-estadounidense John von Neumann (Universidad de Princeton) propuso que los programas, es decir, las instrucciones para que la máquina opere, y también los datos necesarios, podrían ser representados y guardados en una memoria electrónica interna. Así nació el concepto de programa almacenado (o stored-program), en contraposición con el uso de tableros de conexiones y mecanismos similares de los modelos vigentes. Los creadores de la ENIAC, bajo la consultoría de von Neumann, implementaron esto en el diseño de su sucesora, la EDVAC, terminada en 1949. También ya había experimentado con esta idea el alemán Konrad Zuse, quien entre 1937 y 1941 desarrolló la Z3, por lo cual es considerada por algunos como la primera máquina completamente automática y programable. En lugar de usar tubos de vacíos, empleaba un conjunto de 2600 relés, unos dispositivos electromagnéticos inventados en 1835 y empleados, por ejemplo, en telegrafía.  El modelo original de la Z3 fue destruido en Berlín por un bombardeo durante la segunda guerra mundial.\nDe izquierda a derecha: las computadoras ABC, ENIAC y Z3\nEste nuevo paradigma cambió la historia de la computación, como también lo hizo la invención del transistor en 1947 en los Laboratorios Bell. Un transistor es un dispositivo electrónico semiconductor que entrega una señal de salida en respuesta a una señal de entrada, mucho más pequeño que los tubos de vacío y que consumen menos energía eléctrica. Así, una computadora podía tener cientos de miles de transistores, no obstante ocupando mucho espacio.\nDesde entonces, la computación ha evolucionado muy rápidamente, con la introducción de nuevos sistemas y conceptos, que llegan a los complejos y poderosos diseños electrónicos que caracterizan la vida actual. En un intento de caracterizar y resumir esta impactante evolución, algunos historiadores dividen al desarrollo de las computadoras modernas en “generaciones”.\nDe derecha a izquierda: un tubo de vacío, un transistor y un chip.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lectura opcional</span>"
    ]
  },
  {
    "objectID": "capitulos/01_g_opcional.html#niveles-de-abstracción-de-los-lenguajes-de-programación",
    "href": "capitulos/01_g_opcional.html#niveles-de-abstracción-de-los-lenguajes-de-programación",
    "title": "7  Lectura opcional",
    "section": "7.2 Niveles de abstracción de los lenguajes de programación",
    "text": "7.2 Niveles de abstracción de los lenguajes de programación\nSi bien hay distintos lenguajes de programación, una computadora en definitiva es un aparato que sólo sabe hablar en binario, es decir, sólo interpreta señales eléctricas con dos estados posibles, los cuales son representados por los dígitos binarios 0 y 1. Toda instrucción que recibe la computadora se construye mediante una adecuada y larga combinación de ceros y unos1. Este sistema de código con ceros y unos que la computadora interpreta como instrucciones o conjuntos de datos se llama lenguaje de máquina (o código de máquina).\nProgramar en lenguaje de máquina es muy complejo y lento, es fácil cometer errores pero es difícil arreglarlos. Por eso a principios de la década de 1950 se inventaron los lenguajes ensambladores, que usan palabras para representar simbólicamente las operaciones que debe realizar la computadora. Cada una de estas palabras reemplaza un código de máquina binario, siendo un poco más fácil programar. Imaginemos que deseamos crear un programa que permita sumar dos números elegidos por una persona. La computadora puede hacer esto si se lo comunicamos mediante un mensaje compuesto por una larga cadena de ceros y unos (lenguaje de máquina) que a simple vista no podríamos entender. Sin embargo, escrito en lenguaje ensamblador, el programa se vería así (por ejemplo):\n\n\n\n\n\n\n\n\n\nPrograma en lenguaje ensamblador para leer dos números, sumarlos y mostrar el resultado. Al final de cada línea hay una descripción de la operación realizada.\n\n\n\n\nEl programa que se encarga de traducir esto al código de máquina se llama ensamblador. A pesar de que no haya ceros y unos como en el lenguaje de máquina, probablemente el código anterior tampoco sea fácil de entender. Aparecen instrucciones que tal vez podemos interpretar, como add por sumar o sub por substraer, pero está lleno de cálculos hexadecimales, referencias a posiciones en la memoria de la computadora y movimientos de valores que no lo hacen muy amigable. Por eso, a pesar de que la existencia de los lenguajes ensambladores simplificó mucho la comunicación con la computadora, se hizo necesario desarrollar lenguajes que sean aún más sencillos de usar.\nPor ejemplo, con el lenguaje que vamos a aprender, R, el problema de la imagen anterior, que consiste en pedirle a una persona que ingrese dos números para luego sumarlos se resumen en las siguientes líneas de código:\n\nn1 &lt;- scan()\nn2 &lt;- scan()\nprint(n1 + n2)\n\nEn las dos primeras líneas con la instrucción scan() (que quiere decir “escanear”, “leer”) se le pide a la persona que indique dos números y en la tercera línea se muestra el resultado de la suma, con la instrucción print() (“imprimir”, “mostrar”). Mucho más corto y entendible.\nEsta simplificación es posible porque nos permitimos ignorar ciertos aspectos del proceso que realiza la computadora. Todas esas acciones que se ven ejemplificadas en la imagen con el código ensamblador se llevan a cabo de todas formas, pero no lo vemos. Nosotros sólo tenemos que aprender esas últimas tres líneas de código, de forma que nos podemos concentrar en el problema a resolver (ingresar dos números, sumarlos y mostrar el resultado) y no en las complejas operaciones internas que tiene que hacer el microprocesador.\nEn programación, la idea de simplificar un proceso complejo ignorando algunas de sus partes para comprender mejor lo que hay que realizar y así resolver un problema se conoce como abstracción2. Esto quiere decir que los lenguajes de programación pueden tener distintos niveles de abstracción:\n\nLenguajes de bajo nivel de abstracción: permiten controlar directamente el hardware de la computadora, son específicos para cada tipo de máquina, y son más rígidos y complicados de entender para nosotros. El lenguaje ensamblador entra en esta categoría.\nLenguajes de alto nivel de abstracción: diseñados para que sea fácil para los humanos expresar los algoritmos sin necesidad de entender en detalle cómo hace exactamente el hardware para ejecutarlos. El lenguaje que utilizaremos en este taller, R, es de alto nivel. Son independientes del tipo de máquina.\nLenguajes de nivel medio de abstracción: son lenguajes con características mixtas entre ambos grupos anteriores.\n\n\n\n\n\n\n\n\n\n\nDistintos lenguajes de programación y sus logos.\n\n\n\n\nSi bien podemos programar usando un lenguaje de alto nivel para que nos resulte más sencillo, alguien o algo debe traducirlo a lenguaje de máquina para que la computadora, que sólo entiende de ceros y unos, pueda realizar las tareas. Esto también es necesario incluso si programáramos en lenguaje ensamblador. Para estos procesos de traducción se crearon los compiladores e intérpretes.\nUn compilador es un programa que toma el código escrito en un lenguaje de alto nivel y lo traduce a código de máquina, guardándolo en un archivo que la computadora ejecutará posteriormente (archivo ejecutable). Para ilustrar el rol del compilador, imaginemos que alguien que sólo habla español le quiere mandar una carta escrita en español a alguien que vive en Alemania y sólo habla alemán. Cuando esta persona la reciba, no la va a entender. Se necesita de un intermediario que tome la carta en español, la traduzca y la escriba en alemán y luego se la mande al destinatario, quien ahora sí la podrá entender. Ese es el rol de un compilador en la computadora. Ahora bien, el resultado de la traducción, que es la carta escrita en alemán, sólo sirve para gente que hable alemán. Si se quiere enviar el mismo mensaje a personas que hablen otros idiomas, necesitaremos hacer la traducción que corresponda. De la misma forma, el código generado por un compilador es específico para cada máquina, depende de su arquitectura.\nAdemás de los compiladores, para realizar este pasaje también existen los intérpretes. Un intérprete es un programa que traduce el código escrito en lenguaje de alto nivel a código de máquina, pero lo va haciendo a medida que se necesita, es decir, su resultado reside en la memoria temporal de la computadora y no se genera ningún archivo ejecutable. Siguiendo con el ejemplo anterior, es similar a viajar a Alemania con un intérprete que nos vaya traduciendo en vivo y en directo cada vez que le queramos decir algo a alguien de ese país. En su implementación por defecto, el lenguaje R es interpretado, no compilado.\nConcluyendo, gracias al concepto de la abstracción podemos escribir programas en un lenguaje que nos resulte fácil entender, y gracias al trabajo de los compiladores e intérpretes la computadora podrá llevar adelante las tareas necesarias.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lectura opcional</span>"
    ]
  },
  {
    "objectID": "capitulos/01_g_opcional.html#software-y-hardware",
    "href": "capitulos/01_g_opcional.html#software-y-hardware",
    "title": "7  Lectura opcional",
    "section": "7.3 Software y hardware",
    "text": "7.3 Software y hardware\nComo podemos ver, en la historia de la computación hubo dos aspectos que fueron evolucionando: las máquinas y los programas que las dirigen. Hacemos referencia a estos elementos como hardware y software respectivamente, y es la conjunción de ambos la que le da vida a la computación y hace posible la programación.\n\n\n\n\n\n\n\n\n\nRepresentación de la diferencia entre hardware y software.\n\n\n\n\nEl hardware es el conjunto de piezas físicas y tangibles de la computadora. Existen diversas formas de clasificar a los elementos que componene al hardware, según distintos criterios:\n\n\n(#tab:hardware) Clasificación del hardware\n\n\n\n\n\n\nCritero\n\n\nClasificación\n\n\nDescripción\n\n\nEjemplos\n\n\n\n\n\n\nSegún su utilidad\n\n\nDispositivos de procesamiento\n\n\nSon los que reciben las instrucciones mediante señales eléctricas y usan cálculos y lógica para interpretarlas y emitir otras señales eléctricas como resultado.\n\n\nmicroprocesador, tarjeta gráfica, tarjeta de sonido, etc.\n\n\n\n\nDispositivos de almacenamiento\n\n\nSon capaces de guardar información para que esté disponible para el sistema.\n\n\ndisco duro, pen drive, DVD, etc.\n\n\n\n\nDispositivos de entrada\n\n\nCaptan instrucciones por parte de los usuarios y las transforman en señales eléctricas interpretables por la máquina.\n\n\nteclado, mouse, touch pad, etc.\n\n\n\n\nDispositivos de salida\n\n\nTransforman los resultados de los dispositivos de procesamiento para presentarlos de una forma fácilmente interpretable para el usuario.\n\n\nmonitor, impresora, etc\n\n\n\n\nSegún su ubicación\n\n\nDispositivos internos\n\n\nGeneralmente se incluye dentro de la carcasa de la computadora.\n\n\nmicroprocesador, disco rígido, ventiladores, módem, tarjeta gráfica, fuente de alimentación, puertos, etc.\n\n\n\n\nDispositivos externos o periféricos\n\n\nNo se incluye dentro de la carcasa de la computadora y está al alcance del usuario\n\n\nmonitor, teclado, mouse, joystick, micrófono, impresora, escáner, pen drive, lectores de código de barras, etc.\n\n\n\n\nSegún su importancia\n\n\nHardware principal\n\n\nDispositvos esenciales para el funcionamiento de la computadora\n\n\nmicroprocesador, disco rígido, memoria RAM, fuente de alimentación, monitor, etc.\n\n\n\n\nHardware complementario\n\n\nAquellos elementos no indispensables (claramente, dependiendo del contexto, alguna pieza del hardware que en alguna situación podría considerarse complementaria, en otras resulta principal).\n\n\n\n\n\n\n\n\\(~\\)\nPor otro lado tenemos al software, que es el conjunto de todos los programas (es decir, todas las instrucciones que recibe la computadora) que permiten que el hardware funcione y que se pueda concretar la ejecución de las tareas. No tiene una existencia física, sino que es intangible. El software se puede clasificar de la siguiente forma:\n\n\n(#tab:software) Clasificación del software\n\n\n\n\n\n\nClasificación\n\n\nDescripción\n\n\nEjemplos\n\n\n\n\n\n\nSoftware de sistema o software base\n\n\nSon los programas informáticos que están escritos en lenguaje de bajo nivel como el de máquina o ensamblador y cuyas instrucciones controlan de forma directa el hardware.\n\n\nBIOS o UEFIs (sistemas que se encargan de operaciones básicas como el arranque del sistema, la configuración del hardware, etc), sistemas operativos (Linux, Windows, iOS, Android), controladores o drivers, etc.\n\n\n\n\nSoftware de aplicación o utilitario\n\n\nSon los programas o aplicaciones que usamos habitualmente para realizar alguna tarea específica.\n\n\nprocesadores de texto como Word, reproductor de música, Whatsapp, Guaraní, navegadores web, juegos, etc.\n\n\n\n\nSoftware de programación o de desarrollo\n\n\nSon los programas y entornos que nos permiten desarrollar nuestras propias herramientas de software o nuevos programas. Aquí se incluyen los lenguajes de programación.\n\n\nC++, Java, Python, R, etc.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lectura opcional</span>"
    ]
  },
  {
    "objectID": "capitulos/01_g_opcional.html#footnotes",
    "href": "capitulos/01_g_opcional.html#footnotes",
    "title": "7  Lectura opcional",
    "section": "",
    "text": "Como podés leer en Sección 7.1, las primeras computadoras no se manejaban con lenguajes de programación, sino que para introducir información e instrucciones en las primeras computadoras se usaban tarjetas perforadas, en las cuales los orificios representaban un “0” y las posiciones que no los tenían se entendían como un “1”, de modo que la máquina podía operar empleando el sistema binario.↩︎\nLa abstracción no es una idea exclusiva de la programación. Se encuentra, también, por ejemplo, en el arte abstracto.↩︎",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lectura opcional</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html",
    "href": "capitulos/01_practica.html",
    "title": "Práctica de la Unidad 1",
    "section": "",
    "text": "Ejercicio 1\nUsar la consola de R en RStudio para realizar las siguientes operaciones:\nLuego, crear un nuevo script en RStudio y escribir en él las operaciones anteriores. En una línea anterior, agregar el comentario “Ejercicio 1”. Guardar el script con el nombre resolucion_practica_1.R en cualquier lugar de tu computadora. Continuar completando el script la solución de los restantes ejercicios de esta práctica, usando comentarios para identificarlos.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-1",
    "href": "capitulos/01_practica.html#ejercicio-1",
    "title": "Práctica de la Unidad 1",
    "section": "",
    "text": "Sumar 25 y 17.\nMultiplicar 6 por 8.\nCalcular la raíz cuadrada de 144.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-2",
    "href": "capitulos/01_practica.html#ejercicio-2",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\n\nEncontrar la página de ayuda en R para la función round().\n\nDescubrir qué argumentos acepta la función y qué hace cada uno de ellos.\n\n¿Cuál de esos argumentos es de uso obligatorio y cuál, opcional?\nUsar la función para redondear el valor 3.14159 con 0, 1 o 2 decimales.\nEscribir tres formas distintas de usar la función para redondear el valor 3.14159 con dos decimales/",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-3",
    "href": "capitulos/01_practica.html#ejercicio-3",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nEn R, crear los siguientes objetos y observar sus valores:\nx &lt;- 10\ny &lt;- \"Hola\"\nz &lt;- 5\n\n¿Qué tipo de objeto es cada uno?\nModificar el objeto z para almacene el resultado de multiplicar a x por 6.\n¿Qué sucede si intentás sumar x e y? Explicar por qué ocurre esto.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-4",
    "href": "capitulos/01_practica.html#ejercicio-4",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nDescargar el archivo practica1_ambiente.RData. Su extensión .RData indica que contiene objetos de R. Cuando este archivo se lee con R, se cargan en el environment los objetos que tiene almacenados. Vamos a leerlo para identificar qué tipo de objetos aparecen en nuestro ambiente, con alguna de estas opciones:\n\nHacer doble clic en el archivo practica1_ambiente.RData.\nEn la pestaña Environment de RStudio, hacer clic en el ícono de abrir y seleccionar el archivo practica1_ambiente.RData.\nEjecutar la siguiente instrucción:\n\n\nload(\"ruta/completa/hasta/el/archivo/practica1_ambiente.RData\")\n\nUna vez que el archivo haya sido cargado en R, responder: ¿cuántos objetos fueron incorporadas al ambiente al haber cargado el archivo? ¿Cuáles son sus nombres o identificadores? ¿Qué tipo de dato contiene cada uno? ¿Qué valor contiene cada uno?",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-5",
    "href": "capitulos/01_practica.html#ejercicio-5",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nTeniendo en cuenta los objetos cargados en el ambiente en el ejercicio anterior:\n\nEvaluar si al menos una de las variables var2 o var5 contiene un número negativo, escribiendo la correspondiente operación en R.\nEvaluar si ambas variables var2 y var5 contienen un número negativo, escribiendo la correspondiente operación en R.\nEvaluar si al dividir var2 por la suma entre var5 y 100, el resto es menor que 10, escribiendo la correspondiente operación en R.\nEvalar si los valores guardados en var3 y var6 son iguales o no. Inspeccione dichos valores y comente lo observado.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-6",
    "href": "capitulos/01_practica.html#ejercicio-6",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\nSin utilizar R, calcular el valor resultante de las siguientes operaciones, para cada uno de los casos presentados en las columnas. Luego, verificar en R.\n\n\n\n\n\n\n\n\n\nOperación\nedad &lt;- 21, altura &lt;- 1.90\nedad &lt;- 17 , altura &lt;- 1.90\nedad &lt;- 21, altura &lt;- 1.50\n\n\n\n\n(edad &gt; 18) && (altura &lt; 1.70)\n\n\n\n\n\n(edad &gt; 18) || (altura &lt; 1.70)\n\n\n\n\n\n!(edad &gt; 18)",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-7",
    "href": "capitulos/01_practica.html#ejercicio-7",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\nAplicando las reglas de prioridad en los operadores aritméticos, anticipar el resultado de la siguiente expresión. Luego, verificar en R.\n\n1 + 2 + (3 + 4) * ((5 * 6 %% 7 * 8) - 9) - 10",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-8",
    "href": "capitulos/01_practica.html#ejercicio-8",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 8",
    "text": "Ejercicio 8\n¿Para qué valores de x la siguiente expresión resulta verdadera?: (x != 4) || (x != 17).",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-9",
    "href": "capitulos/01_practica.html#ejercicio-9",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 9",
    "text": "Ejercicio 9\nSe desea determinar si un determinado año es bisiesto. Si bien pensamos que los años bisiestos ocurren cada 4 años, los procesos astronómicos que dan origen a este concepto son algo más complejos. Dado que en realidad la Tierra tarda 365.25 días en completar su órbita anual alrededor del sol, agregar un día extra una vez cada 4 años ayuda a mantener el calendario en sincronización con el sol, pero aún queda un pequeño desfasaje. Por lo tanto, la regla completa dice que los años bisiestos ocurren cada 4 años, excepto los terminados en 00, los cuales son bisiestos sólo si son divisibles por 400. Es decir, los años como 1600, 1700, 1800 son bisiestos si son divisibles por 400. Por ejemplo, el año 1900 no fue bisiesto a pesar de ser divisible por 4, pero el año 2000 si lo fue por ser divisible por 400. Entonces, para que un año dado sea bisiesto, se debe cumplir una de las siguientes condiciones:\n\nEl año es divisible por 4 pero no divisible por 100, o\nEl año es divisible por 400.\n\nSiendo año el nombre del objeto cuyo valor es el año que se desea evaluar, expresar la operación lógica que devuelve el valor TRUE sólo si año es un año bisiesto.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-10",
    "href": "capitulos/01_practica.html#ejercicio-10",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 10",
    "text": "Ejercicio 10\nPara cada bloque de código, determinar el valor final de cada variable antes de ejecutarlo en R. Luego, comprobar la respuesta ejecutando el código.\n\n¿Cuáles son los valores finales de a y b?\n\n\na &lt;- 10\nb &lt;- a * 2\na &lt;- a + 5\nb &lt;- b - a\n\n\n¿Cuáles son los valores finales de m y n?\n\n\nm &lt;- 5\nn &lt;- 2 * m\nm &lt;- m + 3\nn &lt;- n + m\nm &lt;- n - 4\n\n\n¿Cuál es el valor final de y?\n\n\nx &lt;- 6\ny &lt;- 2\nx &lt;- x / y + x * y\ny &lt;- x^2 %% 10\ny &lt;- y * 2\ny\n\n\n¿Cuál es el valor final de resultado?\n\n\na &lt;- 5\nb &lt;- 2\nc &lt;- 3\n\nresultado &lt;- a^b - (c * b) + (a %% c)\n\n\n¿Cuáles son los valores finales de x, y y z?\n\n\nx &lt;- 8\ny &lt;- 3\nz &lt;- 2\n\nx &lt;- x %% y + z^y\ny &lt;- (x + y) %/% z\nz &lt;- z + x - y",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-11",
    "href": "capitulos/01_practica.html#ejercicio-11",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 11",
    "text": "Ejercicio 11\nEscribir una expresión en R para calcular el área total y el volumen de un prisma rectangular, considerando que las longitudes se guardan en las variables numéricas a, b y h, como se muestra en la imagen.\n\n\n\n\n\n\n\nPrisma rectangular.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-12",
    "href": "capitulos/01_practica.html#ejercicio-12",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 12",
    "text": "Ejercicio 12\nResponder las siguientes preguntas:\n\n¿Cuál es la ruta informática o path del script resolucion_practica_1.R que creaste en el ejercicio 1?\n¿Cuál es el directorio de trabajo o working directory en tu sesión de trabajo actual?",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_practica.html#ejercicio-13",
    "href": "capitulos/01_practica.html#ejercicio-13",
    "title": "Práctica de la Unidad 1",
    "section": "Ejercicio 13",
    "text": "Ejercicio 13\n\nCrear en tu computadora una carpeta para guardar todo lo relacionado a tus estudios (puede estar en Documentos o dentro de Google Drive u otro sistema de sincronización y respaldo).\nCrear una subcarpeta para los elementos relacionados al primer año de cursado.\nEn ella, crear una carpeta para cada materia que estás cursando, incluyendo una para Programación 1, con el nombre programacion_1.\nCrear un proyecto de RStudio llamado unidad_1, dentro de la carpeta programacion_1.\nGuardar en la carpeta del proyecto todos los archivos que hayas utilizado. Por ejemplo, el script resolucion_practica_1.R y el archivo descargado practica1_ambiente.RData.\nA partir de ahora, cada vez que comiences una nueva unidad en esta asignatura, crear un nuevo proyecto como hicimos para la Unidad 1.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_actividad_autoevaluativa.html",
    "href": "capitulos/01_actividad_autoevaluativa.html",
    "title": "Actividad de autoevaluación 1",
    "section": "",
    "text": "Pregunta 1\nDada la operación:\n(x &gt; y) || !(x / 2 &gt; 10)\nindique su resultado (TRUE o FALSE) para cada una de las siguientes asignaciones de valor para las variables x e y:\na) x &lt;- 15\n   y &lt;- 30\nSeleccione una:\nb) x &lt;- 22\n   y &lt;- 30\nSeleccione una:\nc) x &lt;- 32\n   y &lt;- 30\nSeleccione una:",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Actividad de autoevaluación 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_actividad_autoevaluativa.html#pregunta-1",
    "href": "capitulos/01_actividad_autoevaluativa.html#pregunta-1",
    "title": "Actividad de autoevaluación 1",
    "section": "",
    "text": "TRUE FALSE\n\n\n\nExplicación\n\nComo x = 15 y y = 30, entonces (15 &gt; 30) es FALSE.\n15/2 = 7.5 y (7.5 &gt; 10) también es FALSE.\nSin embargo, !(FALSE) = TRUE.\nFinalmente, FALSE || TRUE = TRUE ya que el operador || resulta TRUE si al menos una de las dos condiciones es TRUE.\n\n\n\n\n TRUE FALSE\n\n\n\nExplicación\n\nComo x = 22 y y = 30, entonces (22 &gt; 30) es FALSE\n22/2 = 11, y (11 &gt; 10) es TRUE\nSin embargo, !(TRUE) = FALSE\nFinalmente, FALSE || FALSE = FALSE\n\n\n\n\n TRUE FALSE\n\n\n\nExplicación\n\nComo x = 32 y y = 30 entonces (32 &gt; 30) es TRUE\n32/2 = 16 y (16 &gt; 10) es TRUE\nSin embargo, !(TRUE) = FALSE\nFinalmente, TRUE || FALSE = TRUE",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Actividad de autoevaluación 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_actividad_autoevaluativa.html#pregunta-2",
    "href": "capitulos/01_actividad_autoevaluativa.html#pregunta-2",
    "title": "Actividad de autoevaluación 1",
    "section": "Pregunta 2",
    "text": "Pregunta 2\n¿Cuál es el valor almacenado en var1 luego de ejecutar las siguientes acciones?\n\nvar1 &lt;- 100\nvar2 &lt;- var1 %% 30\nvar3 &lt;- var1 + var2\nvar3 &lt;- var3 - 3 * var2\nvar1 &lt;- var3 + 20\n\nLa respuesta es (ingrese un numero): \n\n\nExplicación\n\n\nvar1 recibe el valor 100\nvar2 almacena el resto de dividir var1 entre 30:\n\n\nComo 30 × 3 = 90 y 100 − 90 = 10, entonces:\nvar2 = 10\n\n\nvar3 guarda la suma de var1 y var2:\n\n\n100 + 10 = 110\n\n\nModificación de var3:\n\n\nSe actualiza var3 restando 3 veces var2:\n110 − (3 × 10) = 80\n\n\nActualización final de var1:\n\n\nvar1 toma el valor de var3 + 20\n80 + 20 = 100\n\nTras todas las operaciones, var1 vuelve a su valor inicial: 100.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Actividad de autoevaluación 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_actividad_autoevaluativa.html#pregunta-3",
    "href": "capitulos/01_actividad_autoevaluativa.html#pregunta-3",
    "title": "Actividad de autoevaluación 1",
    "section": "Pregunta 3",
    "text": "Pregunta 3\nLos operadores aritméticos tienen mayor orden de precedencia que los operadores relacionales (es decir, se evalúan antes). ¿Es esta afirmación verdadera o falsa?\n\n TRUE FALSE\n\n\n\nExplicación\n\nJerarquía de operadores:\n\nAritméticos (^, %%, /, *, +, -): Mayor precedencia.\nRelacionales (&gt;, &lt;, ==, !=, &gt;=, &lt;=): Menor precedencia.\n\nEjemplo:\n3 + 5 * 2 &gt; 1\nPaso 1 (aritméticos): 5 * 2 = 10 → 3 + 10 = 13 Paso 2 (relacional): 13 &gt; 10 → TRUE\nRegla clave: Paréntesis () &gt; Aritméticos &gt; Relacionales &gt; Lógicos",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Actividad de autoevaluación 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_actividad_autoevaluativa.html#pregunta-4",
    "href": "capitulos/01_actividad_autoevaluativa.html#pregunta-4",
    "title": "Actividad de autoevaluación 1",
    "section": "Pregunta 4",
    "text": "Pregunta 4\nUna inmobiliaria necesita guardar el valor de una operación de venta de un inmueble efectuada durante el corriente año en una variable para realizar operaciones posteriores. Entre los siguientes posibles nombre de variable indique cual sería el más adecuado:\n\n ventainmuebleanio2025 venta_inmueble_2025 operación_Año2025 Valor-Venta-Inmueble-2025 valorVentaInmueble2025 2025_venta_inmueble venta inmueble 2025 VentaOperación\n\n\n\nExplicación\n\nVentaOperación: No es la mejor opción porque incluye un acento (“ó”) en el nombre de la variable, lo que puede generar problemas de codificación en algunos entornos. Además, se recomienda usar guiones bajos para separar palabras en minúsculas y mejorar la legibilidad.\n2025_venta_inmueble: En general no es buena práctica que los nombres de variables comiencen con un número en ningún lenguaje de programación. R y la mayoría de lenguajes no lo permiten, y aunque algunos sí lo hacen, dificulta la lectura y puede causar errores.\nValor-Venta-Inmueble-2025: No se recomienda usar guiones medios en nombres de variables porque este carácter está reservado para la operación de resta. En muchos lenguajes, incluyendo R, provocaría errores de sintaxis. Siempre es mejor usar guiones bajos.\nventa inmueble 2025: Los espacios entre palabras no son válidos en nombres de variables. El sistema interpretaría “venta”, “inmueble” y “2025” como tres variables distintas. Para unir palabras, se usan guiones bajos.\nvalorVentaInmueble2025: Este tipo de escritura se conoce como camelCase, y aunque muchos lo utilizan, en R la convención más clara y extendida es el uso de snake_case (con guiones bajos). Funciona, pero no sigue el estilo típico de R.\noperación_Año2025: Este nombre contiene un acento (“ó”) y la letra “ñ”, lo que puede causar conflictos en algunos entornos. Para evitar errores, es mejor evitar caracteres especiales como estos. Ademas utiliza mayúsculas, lo que puede complicar innecesariamente la escritura del nombre de la variable.\nventainmuebleanio2025: Aunque técnicamente válido, este nombre es largo y poco intuitivo porque carece de separadores entre palabras. Usar guiones bajos mejora significativamente la legibilidad.",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Actividad de autoevaluación 1</span>"
    ]
  },
  {
    "objectID": "capitulos/01_actividad_autoevaluativa.html#pregunta-5",
    "href": "capitulos/01_actividad_autoevaluativa.html#pregunta-5",
    "title": "Actividad de autoevaluación 1",
    "section": "Pregunta 5",
    "text": "Pregunta 5\nIndicar si la siguiente afirmación es verdadera o falsa:\n“Al crear un nuevo Rproject en RStudio se inicia una nueva sesión, se setea el directorio de trabajo y se cargan todas las librerias que necesito para trabajar automáticamente”\n\n TRUE FALSE\n\n\n\nExplicación\n\nUn nuevo RProject en RStudio inicia una nueva sesión de R (limpia el entorno de trabajo) y setea el directorio de trabajo al directorio raíz del proyecto, pero no carga librerías instaladas. Las librerías deben cargarse manualmente en cada sesión o mediante scripts usando el comando library().",
    "crumbs": [
      "Unidad 1. Introducción a la programación con R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Actividad de autoevaluación 1</span>"
    ]
  },
  {
    "objectID": "capitulos/02.html",
    "href": "capitulos/02.html",
    "title": "Unidad 2. Estructuras de control",
    "section": "",
    "text": "Un programa está compuesto por una sucesión ordenada de instrucciones que se ejecutan una detrás de otra, de forma secuencial. Sin embargo, con frecuencia es necesario recurrir a comandos especiales que alteran o controlan el orden en el que se ejecutan las instrucciones. Llamamos estructuras de control del flujo del código al conjunto de reglas que permiten controlar el orden o la cantidad de veces con la que se ejecutan las instrucciones de un algoritmo o programa. Las mismas pueden clasificarse en condicionales e iterativas y son el tema de estudio de esta unidad.",
    "crumbs": [
      "Unidad 2. Estructuras de control"
    ]
  },
  {
    "objectID": "capitulos/02_1_if.html",
    "href": "capitulos/02_1_if.html",
    "title": "10  Estructuras de control condicionales",
    "section": "",
    "text": "10.1 Estructuras condicionales simples\nPostulan una evaluación lógica y, si su resultado es TRUE, se procede a ejecutar las acciones delimitadas entre las llaves que definen el cuerpo de esta estructura. se expresan en R con la siguiente sintaxis:\nLa palabra if indica el comando de evaluación lógica, condición indica la evaluación a realizar y entre llaves se detallan las instrucciones que se realizan sólo si se cumple la condición, es decir, si la evaluación resulta TRUE. Dentro de las llaves puede haber una o muchas líneas de código. Si la condición no se verifica (es FALSE), no se ejecuta ninguna acción y el programa sigue su estructura secuencial con el código que prosigue a la última llave.\nNotar que si bien el uso de sangrías o indentación en el código dentro de las llaves es opcional, decidimos emplearlo para facilitar la lectura y la identificación del inicio y el fin del bloque condicional. Mantener la prolijidad en nuestros programas es esencial.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Estructuras de control condicionales</span>"
    ]
  },
  {
    "objectID": "capitulos/02_1_if.html#estructuras-condicionales-simples",
    "href": "capitulos/02_1_if.html#estructuras-condicionales-simples",
    "title": "10  Estructuras de control condicionales",
    "section": "",
    "text": "if (condición) {\n    hacer esto\n}\n\n\nEl siguiente programa registra la edad de una persona y, en el caso de que sea mayor de edad, avisa que puede votar en las elecciones provinciales de Santa Fe:\n\n# Persona A\nedad &lt;- 27\nif (edad &gt;= 18) {\n    cat(\"Edad =\", edad, \"años: puede votar\")\n}\n\nEdad = 27 años: puede votar\n\n# Persona B\nedad &lt;- 15\nif (edad &gt;= 18) {\n    cat(\"Edad =\", edad, \"años: puede votar\")\n}\n\n# no se ejecuta ninguna acción",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Estructuras de control condicionales</span>"
    ]
  },
  {
    "objectID": "capitulos/02_1_if.html#estructuras-condicionales-dobles",
    "href": "capitulos/02_1_if.html#estructuras-condicionales-dobles",
    "title": "10  Estructuras de control condicionales",
    "section": "10.2 Estructuras condicionales dobles",
    "text": "10.2 Estructuras condicionales dobles\nLa estructura simple sólo provee un curso de acción en el caso de que la evaluación sea TRUE. La estructura doble permite especificar, además, qué se debe hacer en el caso de que le resultado sea FALSE. La sintaxis es:\nif (condición) {\n    hacer esto\n} else {\n    hacer otra cosa\n}\nDentro del primer bloque de llaves se escriben las instrucciones que se ejecutan si se cumple la condición, mientras que en el segundo, luego de la expresión else (“si no”), se incluyen las que se evalúan si no se verifica la misma.\n\nRetomamos el caso anterior para emitir un mensaje cualquiera sea la situación:\n\n# Persona A\nedad &lt;- 27\nif (edad &gt;= 18) {\n    cat(\"Edad =\", edad, \"años: puede votar\")\n} else {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n}\n\nEdad = 27 años: puede votar\n\n# Persona B\nedad &lt;- 15\nif (edad &gt;= 18) {\n    cat(\"Edad =\", edad, \"años: puede votar\")\n} else {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n}\n\nEdad = 15 años: no puede votar",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Estructuras de control condicionales</span>"
    ]
  },
  {
    "objectID": "capitulos/02_1_if.html#estructuras-condicionales-múltiples-o-anidadas",
    "href": "capitulos/02_1_if.html#estructuras-condicionales-múltiples-o-anidadas",
    "title": "10  Estructuras de control condicionales",
    "section": "10.3 Estructuras condicionales múltiples o anidadas",
    "text": "10.3 Estructuras condicionales múltiples o anidadas\nPermiten combinar varias estructuras condicionales para establecer controles más complejos sobre el flujo de la ejecución de las instrucciones, representando una toma de decisión múltiple. Podemos ejemplificar la sintaxis de la siguiente forma:\nif (condición 1) {\n    hacer esto\n} else if (condición 2) {\n    hacer otra cosa\n} else {\n    hacer otra cosa distinta\n}\nEn la estructura anterior, hay una primera evaluación lógica. Si su resultado es TRUE, se ejecuta el código encerrado en el primer juego de llaves y el resto es ignorado. En cambio, si su resultado es FALSE, se procede a evaluar la segunda evaluación lógica, que da lugar a la ejecución del segundo bloque de código si el resultado es TRUE o del tercer bloque, si su resultado es FALSE.\nEl último bloque de acciones, indicado con hacer otra cosa distinta, se evaluará sólo si ninguna de las condiciones lógicas anteriores fue TRUE.\n\nCompletamos el caso de la edad y la votación, considerando la no obligatoriedad para las personas mayores:\n\n# Persona A\nedad &lt;- 27\nif (edad &lt; 18) {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n} else if (edad &gt;= 70) {\n    cat(\"Edad =\", edad, \"años: puede votar opcionalmente\")\n} else {\n    cat(\"Edad =\", edad, \"años: debe votar obligatoriamente\")\n}\n\nEdad = 27 años: debe votar obligatoriamente\n\n# Persona B\nedad &lt;- 15\nif (edad &lt; 18) {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n} else if (edad &gt;= 70) {\n    cat(\"Edad =\", edad, \"años: puede votar opcionalmente\")\n} else {\n    cat(\"Edad =\", edad, \"años: debe votar obligatoriamente\")\n}\n\nEdad = 15 años: no puede votar\n\n# Persona C\nedad &lt;- 81\nif (edad &lt; 18) {\n    cat(\"Edad =\", edad, \"años: no puede votar\")\n} else if (edad &gt;= 70) {\n    cat(\"Edad =\", edad, \"años: puede votar opcionalmente\")\n} else {\n    cat(\"Edad =\", edad, \"años: debe votar obligatoriamente\")\n}\n\nEdad = 81 años: puede votar opcionalmente\n\n\n\n\n¿Cuál será el valor final de resultado después de ejecutar el siguiente código en R?\nx &lt;- 20\nif (x &lt; 10) {\n  resultado &lt;- x * 20\n} else if (x &lt; 20) {\n  resultado &lt;- x / 2\n} else {\n  resultado &lt;- x + 100\n}\nresultado\nresultado es igual a: .",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Estructuras de control condicionales</span>"
    ]
  },
  {
    "objectID": "capitulos/02_2_for_while.html",
    "href": "capitulos/02_2_for_while.html",
    "title": "11  Estructuras de control iterativas",
    "section": "",
    "text": "11.1 Estructuras de control iterativas con un número fijo de iteraciones: for\nUna estructura for se aplican cuando se conoce de antemano el número exacto de veces que se debe repetir una secuencia de instrucciones dentro de un programa. También se conoce como bucle o loop for. La sintaxis es:\nEn lo anterior, conjunto representa un conjunto de elementos, usualmente números o cadenas de texto. El bloque de instrucciones encerrados entre las llaves (que puede contener una o muchas líneas) se ejecutará tantas veces como elementos haya en conjunto. Por ejemplo:\nfor (variable in c(\"Hola\", \"cómo\", \"estás\")) {\n  print(\"Esto es una repetición.\")\n}\n\n[1] \"Esto es una repetición.\"\n[1] \"Esto es una repetición.\"\n[1] \"Esto es una repetición.\"\nEn el ejemplo, con la expresión c(\"Hola\", \"cómo\", \"estás\") se define un conjunto de tres cadenas de texto. Dado que hay tres elementos en ese conjunto, la acción indicada entre las llaves se realiza exactamente tres veces. Dicha acción consiste en imprimir en la consola el mensaje “Esto es una repetición” y se realiza gracias al uso de la función print().\n¿Y para qué está variable en esa estructura? Se trata de un objeto que recibe el nombre de variable o índice de iteración. En cada repetición y respetando el orden, el objeto variable va a recibir el valor de uno de los elementos del conjunto. En este caso, durante la primera iteración, variable almacena el valor \"Hola\". En la segunda repetición, el valor \"cómo\" y en la tercera, \"estás\". De hecho, si queremos podemos usar este objeto, cuyo valor va cambiando iteración tras iteración, en las acciones que se implementan dentro de las llaves:\nfor (variable in c(\"Hola\", \"cómo\", \"estás\")) {\n  print(\"-------------------------\")\n  print(\"Esto es una repetición:\")\n  print(variable)\n}\n\n[1] \"-------------------------\"\n[1] \"Esto es una repetición:\"\n[1] \"Hola\"\n[1] \"-------------------------\"\n[1] \"Esto es una repetición:\"\n[1] \"cómo\"\n[1] \"-------------------------\"\n[1] \"Esto es una repetición:\"\n[1] \"estás\"\nLa variable de iteración, que en el ejemplo se llamó variable, en realidad puede llevar cualquier nombre que queramos. Es común usar sencillamente el nombre i. También es usual que el conjunto de elementos contenga números:\nfor (i in c(1, 2, 3, 4, 5)) {\n  print(\"-------------------------\")\n  print(\"En esta iteración i vale:\")\n  print(i)\n}\n\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 1\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 2\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 3\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 4\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 5\nEn los elementos del conjunto son números enteros ordenados, se puede usar un atajo con la forma inicio:fin:\nfor (i in 1:5) {\n  print(\"-------------------------\")\n  print(\"En esta iteración i vale:\")\n  print(i)\n}\n\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 1\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 2\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 3\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 4\n[1] \"-------------------------\"\n[1] \"En esta iteración i vale:\"\n[1] 5",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estructuras de control iterativas</span>"
    ]
  },
  {
    "objectID": "capitulos/02_2_for_while.html#estructuras-de-control-iterativas-con-un-número-fijo-de-iteraciones-for",
    "href": "capitulos/02_2_for_while.html#estructuras-de-control-iterativas-con-un-número-fijo-de-iteraciones-for",
    "title": "11  Estructuras de control iterativas",
    "section": "",
    "text": "for (variable in conjunto) {\n  hacer esto\n}\n\n\n\n\n\n\n\n\n\n\nEl siguiente bloque de código calcula y muestra la tabla de multiplicar del ocho:\n\nfor (i in 0:10) {\n  resultado &lt;- 8 * i\n  cat(\"8 x\", i, \"=\", resultado, \"\\n\")\n}\n\n8 x 0 = 0 \n8 x 1 = 8 \n8 x 2 = 16 \n8 x 3 = 24 \n8 x 4 = 32 \n8 x 5 = 40 \n8 x 6 = 48 \n8 x 7 = 56 \n8 x 8 = 64 \n8 x 9 = 72 \n8 x 10 = 80 \n\n\n\n\nPara emitir mensajes, podemos usar print() o cat():\n\nprint() tiene la ventaja de que al terminar de emitir el mensaje, agrega un salto de línea: lo próximo que se escriba, aparecerá en un nuevo renglón de la consola. No obstante, no nos permite de forma sencilla concatenar varias piezas de información para armar frases complejas.\ncat() nos permite unir cadenas de texto y valores guardados en variables para armar cualquier frase que queramos, separando entre comas cada una de las partes. Sin embargo, no incluye automáticamente un salto de línea: lo próximo que se escriba queda pegado a lo anterior en el mismo renglón. Para evitar esto, incluimos el carácter especial \\n que representa un salto de línea. Si no lo agreamos, el resultado se ve así:\n\n\nfor (i in 0:10) {\n  resultado &lt;- 8 * i\n  cat(\"8 x\", i, \"=\", resultado)\n}\n\n8 x 0 = 08 x 1 = 88 x 2 = 168 x 3 = 248 x 4 = 328 x 5 = 408 x 6 = 488 x 7 = 568 x 8 = 648 x 9 = 728 x 10 = 80\n\n\n\n\nImaginemos que queremos escribir un programa que permita calcular la quinta potencia de cualquier número, por ejemplo, \\(2^5\\). Para esto, se debe tomar el número \\(2\\) y multiplicarlo por sí mismo \\(5\\) veces. Por lo tanto, una posible solución es:\n\nx &lt;- 2\nresultado &lt;- 1\nresultado &lt;- resultado * x\nresultado &lt;- resultado * x\nresultado &lt;- resultado * x\nresultado &lt;- resultado * x\nresultado &lt;- resultado * x\ncat(x, \"a la quinta es igual a\", resultado)\n\n2 a la quinta es igual a 32\n\n\nYa que sabemos que la multiplicación se debe repetir 5 veces, podemos resumir lo anterior con la siguiente estructura:\n\nx &lt;- 2\nresultado &lt;- 1\nfor (i in 1:5) {\n    resultado &lt;- resultado * x\n}\ncat(x, \"a la quinta es igual a\", resultado)\n\n2 a la quinta es igual a 32\n\n\n\n\n¿Cuál será el valor final de salida después de ejecutar el siguiente código en R?\nsalida &lt;- 30\nfor (i in 1:4) {\n  salida &lt;- salida - i\n}\nsalida es igual a: .",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estructuras de control iterativas</span>"
    ]
  },
  {
    "objectID": "capitulos/02_2_for_while.html#estructuras-de-control-iterativas-con-un-número-indeterminado-de-iteraciones-while",
    "href": "capitulos/02_2_for_while.html#estructuras-de-control-iterativas-con-un-número-indeterminado-de-iteraciones-while",
    "title": "11  Estructuras de control iterativas",
    "section": "11.2 Estructuras de control iterativas con un número indeterminado de iteraciones: while",
    "text": "11.2 Estructuras de control iterativas con un número indeterminado de iteraciones: while\nEn otras circunstancias se necesita repetir un bloque de acciones sin conocer con exactitud cuántas veces, sino que esto depende de algún otro aspecto del programa. Las iteraciones deben continuar mientras que se verifique alguna condición, dando lugar a la estructura while, también conocida como bucle o loop controlado por una condición.\nEn una estructura while (mientras), el conjunto de instrucciones se repite mientras que se siga evaluando como TRUE una condición declarada al inicio del bloque. Cuando la condición ya no se cumple, el proceso deja de ejecutarse. La sintaxis es:\nwhile (condición) {\n    hacer esto\n}\nEl flujo de ejecución es el siguiente:\n\nSe evalúa la condición.\nSi la condición es TRUE, se ejecuta el bloque de código dentro del while.\nUna vez ejecutado el bloque de código, se vuelve a evaluar la condición.\nSi la condición sigue siendo TRUE, se repite el proceso.\nSi la condición es FALSE, el bucle termina y el programa continúa con las instrucciones que siguen después del while.\n\n\nLa variable y tiene un valor inicial igual a 5. Dado que este valor es mayor a 0, se ejecuta por primera vez el bloque entre llaves: le restamos 1 e imprimimos el resultado, el valor 4. Este valor sigue siendo mayor que 0, por lo tanto el proceso se repite. En una de las iteraciones, y queda con el valor 1. Dado que es mayor que 0, la condición es TRUE, a y le restamos uno, queda igual a 0 y lo imprimimos. La condición se evalúa una vez más, pero resulta en FALSE, por lo tanto no se detiene la repetición.\n\ny &lt;- 5\nwhile (y &gt; 0) {\n  y &lt;- y - 1\n  print(y)\n}\n\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n[1] 0\n\n\n\nEl valor 0 se imprime porque una vez dentro del bloque, se ejecutan todas sus acciones. El procesamiento no se interrumpe cuando y toma el valor 0, sino cuando se vuelve a evaluar la condición lógica y esta es FALSE, después de la última vuelta. En otras palabras, la evaluación de la condición sólo se lleva a cabo al inicio de cada iteración; si la condición se vuelve FALSE en algún punto durante la ejecución del bloque, el programa no lo nota hasta que termine de ejecutarlo y la condición sea evaluada antes de comenzar la próxima iteración.\n\nEn el siguiente bloque intercambiamos de lugar las líneas dentro de las llaves. ¿En qué difiere el resultado?\n\ny &lt;- 5\nwhile (y &gt; 0) {\n  print(y)\n  y &lt;- y - 1\n}\n\n[1] 5\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n\n\n\nComo ya observamos, la evaluación de la condición se lleva a cabo antes de cada iteración, incluso antes de ejecutar el código dentro del bloque por primera vez. Si la condición es FALSE inicialmente, entonces las acciones en el cuerpo de la estructura no se ejecutan nunca:\n\ny &lt;- -5\nwhile (y &gt; 0) {\n  print(y)\n  y &lt;- y - 1\n}\n\n\nEste programa divide un número por 2 mientras que el resultado sea mayor o igual a 1 (es decir, hasta encontrar un valor menor que 1):\n\nx &lt;- 100\nwhile (x &gt;= 1) {\n    x &lt;- x / 2\n    print(x)\n}\n\n[1] 50\n[1] 25\n[1] 12.5\n[1] 6.25\n[1] 3.125\n[1] 1.5625\n[1] 0.78125\n\n\n\n\n¿Cuál será la salida del siguiente código en R?\n\nx &lt;- 1\nsuma &lt;- 0\n\nwhile (suma + x &lt;= 15) {\n  suma &lt;- suma + x\n  cat(suma, \" \")\n  x &lt;- x + 1\n}\n\n1 2 3 4 51 3 6 10 151 3 6 10 15 21\n\n\nEn R existe otra estructura iterativa, muy relacionada con el while. Se trata de la estructura repeat, que repite indefinidamente el bloque de instrucciones entre llaves. Para detener las iteraciones, se incluye dentro del bloque una evaluación lógica con un if y la instrucción break. Si la condición es TRUE, se ejecuta el break, deteniendo el proceso iterativo.\n\nx &lt;- 100\nrepeat {\n  x &lt;- x / 2\n  print(x)\n  if (x &lt; 1) break\n}\n\n[1] 50\n[1] 25\n[1] 12.5\n[1] 6.25\n[1] 3.125\n[1] 1.5625\n[1] 0.78125\n\n\nEn general, no utilizaremos la estructura repeat, pero es otra herramienta disponible.\nAsí como contamos con la instrucción break para detener un proceso iterativo (ya sea un for, while o repeat), también contamos con next para saltar una iteración. Notemos su efecto:\n\nx &lt;- 100\nwhile (x &gt;= 1) {\n    x &lt;- x / 2\n    print(x)\n}\n\n[1] 50\n[1] 25\n[1] 12.5\n[1] 6.25\n[1] 3.125\n[1] 1.5625\n[1] 0.78125\n\n\n\nx &lt;- 100\nwhile (x &gt;= 1) {\n    x &lt;- x / 2\n    if (x == 12.5) next\n    print(x)\n}\n\n[1] 50\n[1] 25\n[1] 6.25\n[1] 3.125\n[1] 1.5625\n[1] 0.78125",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estructuras de control iterativas</span>"
    ]
  },
  {
    "objectID": "capitulos/02_2_for_while.html#ejemplos",
    "href": "capitulos/02_2_for_while.html#ejemplos",
    "title": "11  Estructuras de control iterativas",
    "section": "11.3 Ejemplos",
    "text": "11.3 Ejemplos\nCon las sentencias de tipo while se debe tener mucha precaución, puesto que si la evaluación lógica no está bien especificada o nunca deja de ser evaluada como TRUE, se incurre en un loop infinito: el programa nunca deja de repetir el bloque (al menos hasta que la máquina se tilde o se produzca un error por desbordamiento de memoria, por ejemplo).\nLa siguiente situación ilustra esto:\nvar &lt;- 9\nwhile (var &lt; 10) {\n    var &lt;- var - 1\n    cat(\"var =\", var, \"No puedo parar!!!\\n\")\n}\nvar = 8 No puedo parar!!!\nvar = 7 No puedo parar!!!\nvar = 6 No puedo parar!!!\nvar = 5 No puedo parar!!!\nvar = 4 No puedo parar!!!\nvar = 3 No puedo parar!!!\nvar = 2 No puedo parar!!!\nvar = 1 No puedo parar!!!\nvar = 0 No puedo parar!!!\nvar = -1 No puedo parar!!!\nvar = -2 No puedo parar!!!\n.\n.\n.\nSi ejecutás ese código, vas a tener que forzar “a mano” el detenimiento del procesamiento, con el botón rojo de “Stop” arriba a la derecha de la consola, o con el atajo CTRL + C. También podemos implementar un “conteo” de las iteraciones y agregar un break: si el bloque se repitió, por ejemplo, 15 veces, que se detenga:\n\nconteo &lt;- 0\nvar &lt;- 9\nwhile (var &lt; 10) {\n    var &lt;- var - 1\n    cat(\"var =\", var, \"No puedo parar!!!\\n\")\n    conteo &lt;- conteo + 1\n    if (conteo == 15) break\n}\ncat(\"Se hicieron\", conteo, \"iteraciones.\")\n\nvar = 8 No puedo parar!!!\nvar = 7 No puedo parar!!!\nvar = 6 No puedo parar!!!\nvar = 5 No puedo parar!!!\nvar = 4 No puedo parar!!!\nvar = 3 No puedo parar!!!\nvar = 2 No puedo parar!!!\nvar = 1 No puedo parar!!!\nvar = 0 No puedo parar!!!\nvar = -1 No puedo parar!!!\nvar = -2 No puedo parar!!!\nvar = -3 No puedo parar!!!\nvar = -4 No puedo parar!!!\nvar = -5 No puedo parar!!!\nvar = -6 No puedo parar!!!\nSe hicieron 15 iteraciones.\n\n\nLas distintas estructuras iterativas se pueden combinar entre sí, dando lugar flujos de ejecución del código altamente flexibles. En el siguiente caso se tienen dos estructuras for anidadas:\n\nfor (i in 1:3) {\n    for (j in 1:2) {\n        suma &lt;- i + j\n        cat(\"| i vale\", i, \"| j vale\", j, \"| La suma es igual a\", suma, \"|\\n\")  \n    }\n}\n\n| i vale 1 | j vale 1 | La suma es igual a 2 |\n| i vale 1 | j vale 2 | La suma es igual a 3 |\n| i vale 2 | j vale 1 | La suma es igual a 3 |\n| i vale 2 | j vale 2 | La suma es igual a 4 |\n| i vale 3 | j vale 1 | La suma es igual a 4 |\n| i vale 3 | j vale 2 | La suma es igual a 5 |\n\n\nEn primer lugar, i toma el valor 1, y entonces j varía de 1 a 2, generando las combinaciones i = 1, j = 1 e i = 1, j = 2. Luego de que el loop de j finalice habiendo recorrido todo su campo de variación, comienza la segunda iteración del loop de i, actualizándose su valor a 2 y comenzando otra vez el loop de j, que varía de 1 a 2. Así, se generan las combinaciones i = 2, j = 1 e i = 2, j = 2. Finalmente, se actualiza i y pasa a valer 3, generando las combinaciones i = 3, j = 1 e i = 3, j = 2. Para cada combinación, se muestra el valor de la suma entre i y j.\nRecordemos que las variables de iteración pueden recibir cualquier nombre:\n\nfor (guau in 1:3) {\n    for (miau in 1:2) {\n        suma &lt;- guau + miau\n        cat(\"| guau vale\", guau, \"| miau vale\", miau, \"| La suma es igual a\", suma, \"|\\n\")  \n    }\n}\n\n| guau vale 1 | miau vale 1 | La suma es igual a 2 |\n| guau vale 1 | miau vale 2 | La suma es igual a 3 |\n| guau vale 2 | miau vale 1 | La suma es igual a 3 |\n| guau vale 2 | miau vale 2 | La suma es igual a 4 |\n| guau vale 3 | miau vale 1 | La suma es igual a 4 |\n| guau vale 3 | miau vale 2 | La suma es igual a 5 |\n\n\nCon estas herramientas, podemos crear programas que nos permitan verificar algunos principios matemáticos. Por ejemplo, sabemos que la suma de los primeros \\(n\\) números naturales es igual a \\(n(n+1)/2\\). Entonces, la suma de los 50 primeros números naturales (\\(1 + 2 + 3 + ... + 50\\)) debe ser igual a \\(50 \\times 51 / 2 = 1275\\). ¿Será verdad?\n\nn &lt;- 50\nsuma &lt;- 0\nfor (i in 1:n) {\n    suma &lt;- suma + i\n}\nsuma\n\n[1] 1275\n\n\nAhora que nos quedamos tranquilos de que ese postulado matemático se cumple, si necesitamos esa suma podemos hacer sencillamente:\n\nn * (n + 1) / 2\n\n[1] 1275\n\n\nEs momento de dejar volar nuestra imaginación y plantearnos cualquier problema de este estilo que se nos ocurra, ya estamos en condiciones de resolverlo. Por ejemplo, sumemos números naturales hasta que la suma pase el valor 100:\n\nsuma &lt;- 0\nnro_natural &lt;- 1\nwhile (suma &lt; 100) {\n    suma &lt;-  suma + nro_natural\n    nro_natural &lt;- nro_natural + 1\n}\ncat(\"Se deben sumar los primeros\", nro_natural - 1, \"números naturales para superar el valor 100.\")\n\nSe deben sumar los primeros 14 números naturales para superar el valor 100.\n\ncat(\"La suma de los primeros\", nro_natural - 1, \"números naturales es igual a\", suma, \".\")\n\nLa suma de los primeros 14 números naturales es igual a 105 .\n\n\n\nAnalizar con atención el caso anterior y explicar por qué se utiliza nro_natural - 1 para indicar cuántos números naturales formaron parte de la suma.\n\n¿Alguien sabe cuántos múltiplos de 8 menores a 150 hay? Contemos1:\n\n# cada nro es múltiplo de sí mismo, así que el primero es el mismo 8\nmultiplo &lt;- 8\n# contamos que ya tenemos identificado al primer múltiplo\nconteo &lt;- 1\n# encontramos los siguientes múltiplos sumando de a 8\nwhile (multiplo &lt; 150) {\n    print(multiplo)\n    multiplo &lt;- multiplo + 8\n    conteo &lt;- conteo + 1\n}\n\n[1] 8\n[1] 16\n[1] 24\n[1] 32\n[1] 40\n[1] 48\n[1] 56\n[1] 64\n[1] 72\n[1] 80\n[1] 88\n[1] 96\n[1] 104\n[1] 112\n[1] 120\n[1] 128\n[1] 136\n[1] 144\n\ncat(\"Hay\", conteo, \"múltiplos de 8 menores que 150.\")\n\nHay 19 múltiplos de 8 menores que 150.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estructuras de control iterativas</span>"
    ]
  },
  {
    "objectID": "capitulos/02_2_for_while.html#footnotes",
    "href": "capitulos/02_2_for_while.html#footnotes",
    "title": "11  Estructuras de control iterativas",
    "section": "",
    "text": "Para gente curiosa: este conteo se puede hacer sencillamente con 150 %/% 8 + 1. ¿Por qué?↩︎",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estructuras de control iterativas</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html",
    "href": "capitulos/02_practica.html",
    "title": "Práctica de la Unidad 2",
    "section": "",
    "text": "Ejercicio 1\nEscribir un programa en R para determinar si un número entero dado es par o impar.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-2",
    "href": "capitulos/02_practica.html#ejercicio-2",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nEscribir un programa en R para leer tres números y determinar cuál es el mayor.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-3",
    "href": "capitulos/02_practica.html#ejercicio-3",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nUna fábrica organiza a sus operarios en tres turnos de trabajo rotativos: mañana, tarde y noche. Los turnos mañana y tarde se pagan $4000 la hora, mientras que en el turno noche se paga un adicional de $2000. Además, los domingos se paga un adicional de $1000 la hora. Escribir un programa en R que permita calcular cuánto se le debe pagar a un operario por un día de trabajo, dados el turno, el día de la semana y la cantidad de horas trabajadas. Los turnos son identificados mediante los caracteres \"M\", \"T\" y \"N\"; los días de semana mediante las primeras tres letras (\"DOM\", \"LUN\", \"MAR\", \"MIE\", \"JUE\", \"VIE\", \"SAB\").",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-4",
    "href": "capitulos/02_practica.html#ejercicio-4",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nEscribir un programa en R para convertir un valor de temperatura expresado en grados Celsius a su equivalente en grados Farenheit y viceversa. El problema debe leer la magnitud a convertir en la variable numérica temp y el tipo de conversión en la variable caracter modo, que puede tomar los valores \"C a F\" o \"F a C\".",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-5",
    "href": "capitulos/02_practica.html#ejercicio-5",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nEscribir un programa en R que permita calcular:\n\nla suma de los n primeros números naturales.\nla suma de los cuadrados de los n primeros números naturales.\nel producto de los primeros n números naturales impares.\nla suma de los cubos de los n primeros números naturales pares.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-6",
    "href": "capitulos/02_practica.html#ejercicio-6",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\nEscribir un programa en R que permita calcular el factorial de un número natural n, n!. Realizarlo de dos formas, empleando estructuras iterativas diferentes.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-7",
    "href": "capitulos/02_practica.html#ejercicio-7",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\nEn el siglo XIII el matemático italiano Leonardo Fibonacci ideó una secuencia matemática que lleva su nombre, intentando explicar el crecimiento geométrico de una población de conejos. Los primeros dos términos de la secuencia son 0 y 1, y cada uno de los subsecuentes términos es la suma de los dos anteriores. De esta forma, el inicio de la secuencia de Fibonacci es: 0 - 1 - 1 - 2 - 3 - 5 - 8 - … . Escribir un programa en R para mostrar todos los términos de la secuencia de Fibonacci menores que 10000.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-8",
    "href": "capitulos/02_practica.html#ejercicio-8",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 8",
    "text": "Ejercicio 8\nSe tiene una caja fuerte que, para poder abrirla, se desea crear una lista con todas las combinaciones posibles. Se sabe que:\n\nLa combinación tiene 3 cifras.\nLa combinación es múltiplo de 11.\nLa combinación no es mayor que 800.\nLa combinación no es múltiplo de 8.\nLa combinación no comienza con 0.\n\nEscribir un programa en R que permita imprimir una lista con todas las combinaciones posibles bajo las condiciones anteriores.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_practica.html#ejercicio-9",
    "href": "capitulos/02_practica.html#ejercicio-9",
    "title": "Práctica de la Unidad 2",
    "section": "Ejercicio 9",
    "text": "Ejercicio 9\nEn un pequeño pueblo en expansión, la población es igual a 1000 al inicio del año. La población aumenta regularmente un 2% anual. Además, 50 nuevos habitantes se mudan al pueblo cada año.\n\nAl finalizar el año, ¿cuál es el tamaño de la población? Expresar una fómula general usando la simbología po para el valor inicial de la población (1000), tasa para el porcentaje de aumento anual (2) e inmigrantes para la cantidad de nuevos habitantes que llegan por año (50).\n¿Cuántos años tienen que transcurrir para que el pueblo alcance una población mayor o igual a 1200 habitantes? Realice la cuenta para cada año, tomando la parte entera del resultado en cada oportunidad, en el caso de que el resultado tenga decimales.\nEscribir un programa en R que permita responder la pregunta del punto anterior para este caso y para cualquier otro, en el que cambien los parámetros del problema (la población inicial, población objetivo, tasa de crecimiento anual y cantidad de habitantes que inmigran al pueblo). El programa debe terminar emitiendo una descripción de la situación del problema y cuántos años deben transcurrir para llegar a la población objetivo.\nRepetir el cálculo para la situación en la que la población inicialmente es de 10000 habitantes, hay un crecimiento anual del 3%, se añaden 100 inmigrantes por año y se desea saber cuántos años llevará superar los 50000 habitantes.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_actividad_autoevaluativa.html",
    "href": "capitulos/02_actividad_autoevaluativa.html",
    "title": "Actividad de autoevaluación 2",
    "section": "",
    "text": "Pregunta 1\nSe desea determinar si una persona puede conducir o no, en función de las siguientes reglas:\nSe presentan distintas opciones para hacer la evaluación requerida:\n# Opción A\nif (edad &gt;= 18 && tiene_carnet) {\n  print(\"Puede conducir\")\n} else if (edad &gt;= 70 || !tiene_carnet) {\n  print(\"Requiere evaluación adicional\")\n}\n\n# Opción B\nif (edad &gt;= 18 && tiene_carnet) {\n  print(\"Puede conducir\")\n}\nif (edad &gt;= 70 || !tiene_carnet) {\n  print(\"Requiere evaluación adicional\")\n}\n\n# Opción C\nif (edad &gt;= 70 || !tiene_carnet) {\n  print(\"Requiere evaluación adicional\")\n} else if (edad &gt;= 18 && tiene_carnet) {\n  print(\"Puede conducir\")\n}\n\n# Opción D\nif (edad &gt;= 18 && tiene_carnet) {\n  print(\"Puede conducir\")\n} else {\n  print(\"Requiere evaluación adicional\")\n}\n¿Cuál es la opción correcta?: ABCD",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Actividad de autoevaluación 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_actividad_autoevaluativa.html#pregunta-1",
    "href": "capitulos/02_actividad_autoevaluativa.html#pregunta-1",
    "title": "Actividad de autoevaluación 2",
    "section": "",
    "text": "Si tiene 18 años o más y tiene carnet, puede conducir.\nSi tiene 70 años o más, o no tiene carnet, necesita una evaluación adicional.\n\n\n\n\n\n\nExplicación\n\nDel enunciado hay que tener en cuenta que algunas personas pueden cumplir las dos reglas a la vez. Por ejemplo: si una persona tiene 80 años y carnet, puede conducir pero además necesita una evaluación adicional (por la edad). Esto significa que las condiciones NO son mutuamente excluyentes (pueden cumplirse sin excluirse una a la otra). Para resolver este tipo de condiciones se utilizan if independientes así, si una persona cumple las dos condiciones, recibe ambos mensajes.\nProblemas con las otras opciones:\n\nOpciones A y D: usan else / else if, es decir, solo muestran uno de los dos mensajes (aunque ambas reglas apliquen). Ejemplo: 80 años con carnet solo diría “Puede conducir” (y se olvida de la evaluación).\nOpción C: pone la evaluación primera, si alguien tiene +70 años, siempre mostrará solo “Necesita evaluación” (aunque igual pueda conducir).\n\nConclusión clave:\nCuando dos reglas pueden cumplirse juntas, usamos if independientes. Si usamos else / else if, el programa se detiene en la primera condición TRUE.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Actividad de autoevaluación 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_actividad_autoevaluativa.html#pregunta-2",
    "href": "capitulos/02_actividad_autoevaluativa.html#pregunta-2",
    "title": "Actividad de autoevaluación 2",
    "section": "Pregunta 2",
    "text": "Pregunta 2\n¿Cuál de las siguientes expresiones NO muestra la tabla del 8?\n\n# Opción A\nfor (i in 0:10) {\n  cat(\"8 por\", i, \"es\", 8 * i, \"\\n\")\n}\n\n# Opción B\nnumero &lt;- 0\nfor (i in 0:10) {\n  cat(\"8 por\", i, \"es\", numero, \"/n\")\n  numero &lt;- numero + 8\n}\n\n# Opción C\nnumero &lt;- 1\nfor (i in 0:10) {\n  cat(\"8 por\", i, \"es\", numero, \"\\n\")\n  numero &lt;- numero * 8\n}\n\nLa opción que no muestra la tabla del 8 es la: ABC\n\n\nExplicación\n\n\nLa opción A está bien porque multiplica directamente 8 por cada valor de i.\nLa opción B también es correcta, porque empieza desde cero y va sumando 8 en cada paso, lo cual genera la tabla correctamente.\nEn cambio, la opción C no muestra la tabla del 8 por dos razones:\n\nEn primer lugar, el primer cat(\"8 por\", i, \"es\", numero, \"\\n\") da como resultado 8 por 0 es 1 puesto que la variable numero se inicializa en 1.\nAdemás, en cada vuelta se multiplica el resultado anterior por 8, en lugar de sumarle 8, lo cual genera una secuencia exponencial.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Actividad de autoevaluación 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_actividad_autoevaluativa.html#ej3-aa2",
    "href": "capitulos/02_actividad_autoevaluativa.html#ej3-aa2",
    "title": "Actividad de autoevaluación 2",
    "section": "Pregunta 3",
    "text": "Pregunta 3\nEn una fábrica, los tornillos se empaquetan de a 10 y luego los paquetes se agrupan de a 5 en cajas. En la etapa de control de calidad se eligen al azar 3 cajas y se pesan todos los tornillos. Se desea escribir un programa que informe el peso de cada tornillo evaluado, indicando a qué caja y paquete pertenece. Además, se desea informar el porcentaje de tornillos evaluados que pesan más de 1 gramo, puesto que se los considera defectuosos.\nCompletar el siguiente fragmento de código, escribiendo las partes faltantes en los campos en blanco disponibles debajo. Para las variables de iteración se puede utilizar nombres descriptivos como caja, paquete y tornillo o los genéricos i, j o k:\n\ncajas &lt;- 3\npaquetes &lt;- 5\ntornillos &lt;- 10\ndefectuosos &lt;- 'A ___'\n\nfor ('B ___' in 1:'C ___') {\n  for ('D ___' in 1:'E ___') {\n    for ('F ___' in 1:'G ___') {\n      # Se pesa el tornillo (la siguiente línea genera un número al azar)\n      peso &lt;- round(rnorm(1, 0.99, 0.01), 4)\n      cat(\n        \"El tornillo\", 'H ___', \"del paquete\", 'I ___', \"de la caja\", 'J ___',\n        \"pesa\", 'K ___', \"gramos.\\n\"\n      )\n      if (peso &gt; 'L ___') {\n        defectuosos &lt;- 'M ___' + 1\n      }\n    }\n  }\n}\ntotal_tornillos &lt;- cajas * paquetes * 'N ___'\nporcentaje &lt;- round(defectuosos / 'Ñ ___' * 100)\ncat(\"El porcentaje de tornillos defectuosos es\", 'O ___', \"%\")\n\n\nA: \nB: \nC: \nD: \nE: \nF: \nG: \nH: \nI: \nJ: \nK: \nL: \nM: \nN: \nÑ: \nO: \n\n\n\nExplicación\n\nEn este ejercicio, queremos recorrer todas las cajas, luego cada paquete dentro de cada caja, y finalmente cada tornillo dentro de cada paquete. Como ya están definidas las cantidades totales de cajas, paquetes y tornillos, esas variables se deben usar como los límites de los bucles. Para verificar si un tornillo está en buen estado, usamos una condición simple: si su peso es mayor a 1, contamos un tornillo defecutoso más, en una variable que fue iniciada en 0:\n\ncajas &lt;- 3\npaquetes &lt;- 5\ntornillos &lt;- 10\ndefectuosos &lt;- 0\n\nfor (caja in 1:cajas) {\n  for (paquete in 1:paquetes) {\n    for (tornillo in 1:tornillos) {\n      # Se pesa el tornillo (la siguiente línea genera un número al azar)\n      peso &lt;- round(rnorm(1, 0.99, 0.01), 4)\n      cat(\n        \"El tornillo\", tornillo, \"del paquete\", paquete, \"de la caja\", caja,\n        \"pesa\", peso, \"gramos.\\n\"\n      )\n      if (peso &gt; 1) {\n        defectuosos &lt;- defectuosos + 1\n      }\n    }\n  }\n}\ntotal_tornillos &lt;- cajas * paquetes * tornillos\nporcentaje &lt;- round(defectuosos / total_tornillos * 100)\ncat(\"El porcentaje de tornillos defectuosos es\", porcentaje, \"%\")",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Actividad de autoevaluación 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_actividad_autoevaluativa.html#pregunta-4",
    "href": "capitulos/02_actividad_autoevaluativa.html#pregunta-4",
    "title": "Actividad de autoevaluación 2",
    "section": "Pregunta 4",
    "text": "Pregunta 4\nA partir del siguiente fragmento de código, responder las siguientes preguntas:\n\nvar &lt;- 0\nn &lt;- 1\n\nwhile (n &lt;= 5) {\n    var &lt;- var + n * n\n    n &lt;- n + 1\n}\n\n\n¿Qué valor almacena la variable n al finalizar?\nRespuesta: \n¿Qué valor almacena la variable var al finalizar?\nRespuesta: \n¿Cuántas veces se ejecutó el bloque de código encerrado en la estructura iterativa?\nRespuesta:  veces.\nSi en lugar de asignar al inicio n &lt;- 1, se hubiese asignado n &lt;- 6, ¿cuál sería el valor de var al finalizar?\nRespuesta: \n\n\n\nExplicación\n\nEste código usa un bucle while que se repite mientras la condición n &lt;= 5 se cumpla. Arranca con n en 1 e incrementa de a uno en cada vuelta. En cada iteración, suma el cuadrado de n a var. Entonces, lo que estamos haciendo es calcular la suma de los cuadrados de los números del 1 al 5. Al finalizar, n vale 6 porque ya no cumple la condición para seguir. var vale 55 porque es 1² + 2² + 3² + 4² + 5². El bloque se ejecuta 5 veces, una por cada valor de n de 1 a 5. Y si hubiéramos empezado con n &lt;- 6, como no se cumple la condición desde el principio, el bucle no se ejecuta y var queda en 0.",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Actividad de autoevaluación 2</span>"
    ]
  },
  {
    "objectID": "capitulos/02_actividad_autoevaluativa.html#pregunta-5",
    "href": "capitulos/02_actividad_autoevaluativa.html#pregunta-5",
    "title": "Actividad de autoevaluación 2",
    "section": "Pregunta 5",
    "text": "Pregunta 5\nAnalizar el código y determinar si las siguientes afirmaciones son verdaderas o falsas:\n\nstock &lt;- 7\ntipo_producto &lt;- \"alimento\"\n\nwhile (stock &gt; 0) {\n  if (stock &gt;= 5 && tipo_producto == \"alimento\") {\n    cat(\"¡OFERTA EN ALIMENTOS!\", \"\\n\")\n  } else if (stock &lt;= 3 && tipo_producto == \"alimento\") {\n    cat(\"¡QUEDAN POCAS UNIDADES!\", \"\\n\")\n  }\n  stock &lt;- stock - 1\n}\n\ncat(\"Producto no disponible\", \"\\n\")\n\n\nEl mensaje \"¡QUEDAN POCAS UNIDADES!\" se imprimirá 3 veces.\n\n Verdadero Falso\n\nSi tipo_producto &lt;- \"limpieza\" el código no se ejecutará.\n\n Verdadero Falso\n\nEl bucle while se ejecuta 6 veces.\n\n Verdadero Falso\n\nEl valor final de stock al terminar el bucle es 1.\n\n Verdadero Falso\n\nSi stock &lt;- 0 se imprime \"Producto no disponible\".\n\n Verdadero Falso\n\nSi las condiciones que evalúan el if y else if se invirtieran en posición la salida del programa cambiaría.\n\n Verdadero Falso\n\n\n\n\nExplicación\n\nEste ejercicio muestra cómo el orden de las condiciones y el valor de las variables iniciales afectan la ejecución:\n\nEl mensaje \"¡QUEDAN POCAS UNIDADES!\" se imprime 3 veces porque eso pasa cuando stock baja de 3 a 1, cumpliendo la condición del else if.\nEl bucle se ejecuta 7 veces en total, porque empieza en 7 y termina cuando stock baja a 0.\nSi tipo_producto tuviese el valor \"limpieza\", el bucle sí se ejecuta, pero no se imprime ninguno de los mensajes dentro del if o else if, ya que esas condiciones no se cumplen.\nEl valor final de stock es 0, no 1, porque en cada vuelta se resta 1 hasta llegar a cero.\nSi arrancáramos con stock &lt;- 0, el bucle no se ejecuta pero igual se imprime \"Producto no disponible\", porque esa línea está fuera del while.\nPor último, invertir el orden de if y else if no cambia el resultado en este caso porque las condiciones nunca se solapan; o se cumple una o la otra, pero nunca ambas al mismo tiempo (son excluyentes).",
    "crumbs": [
      "Unidad 2. Estructuras de control",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Actividad de autoevaluación 2</span>"
    ]
  },
  {
    "objectID": "capitulos/03.html",
    "href": "capitulos/03.html",
    "title": "Unidad 3. Descomposición algorítmica",
    "section": "",
    "text": "En este capítulo exploraremos un concepto fundamental en la programación: la creación de nuevas funciones. A medida que los programas crecen en tamaño y complejidad, escribir el mismo código repetidas veces no solo es ineficiente, sino que también aumenta el riesgo de cometer errores. Para solucionar esto, podemos encapsular bloques de código en funciones reutilizables, mejorando la claridad y la organización de nuestros programas.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica"
    ]
  },
  {
    "objectID": "capitulos/03_1_crear_funciones.html",
    "href": "capitulos/03_1_crear_funciones.html",
    "title": "14  Creación de nuevas funciones en R",
    "section": "",
    "text": "14.1 La importancia de la descomposición algorítmica\nUn principio clave en la resolución de problemas es la descomposición algorítmica, es decir, dividir un problema complejo en partes más pequeñas y manejables. En programación, esto se traduce en la creación de subalgoritmos: fragmentos de código que resuelven una parte específica del problema. Este enfoque, también conocido como descomposición modular, facilita la comprensión del código y permite reutilizar soluciones ya escritas.\nEn R, los subalgoritmos se implementan a través de funciones. Una función encapsula una serie de instrucciones y puede ser invocada desde distintos puntos del código cada vez que se necesite, sin necesidad de reescribir esas instrucciones encapsuladas una y otra vez. Esto aporta varios beneficios fundamentales:\nLas funciones son fundamentales para organizar y estructurar programas, ya que permiten dividir un problema en partes más pequeñas y reutilizar código en diferentes puntos del programa sin necesidad de repetirlo.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Creación de nuevas funciones en R</span>"
    ]
  },
  {
    "objectID": "capitulos/03_1_crear_funciones.html#la-importancia-de-la-descomposición-algorítmica",
    "href": "capitulos/03_1_crear_funciones.html#la-importancia-de-la-descomposición-algorítmica",
    "title": "14  Creación de nuevas funciones en R",
    "section": "",
    "text": "Mejor legibilidad del código: si el programa es muy largo porque las mismas instrucciones aparecen muchas veces, encerrarlas dentro de una función que es invocada en una sola línea cada vez que se necesita hace que el código se vuelva más corto. Además, al dar a una función un nombre descriptivo, el propósito de la línea de código que la invoca se vuelve más claro. Todo esto resulta en código más comprensible para las personas.\nFacilidad de mantenimiento: si hay que modificar una funcionalidad, basta con actualizar la función sólo en el lugar donde está definida, en lugar de hacerlo en múltiples fragmentos de código copiados y pegados.\nReducción de errores: copiar y pegar código manualmente puede dar lugar a errores accidentales, como olvidar cambiar un nombre de variable en alguna de las copias.\n\nMayor eficiencia y reutilización: una vez definida, una función puede utilizarse muchas veces, en el mismo o en otros proyectos, ahorrando tiempo y esfuerzo.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Creación de nuevas funciones en R</span>"
    ]
  },
  {
    "objectID": "capitulos/03_1_crear_funciones.html#definición-de-una-función",
    "href": "capitulos/03_1_crear_funciones.html#definición-de-una-función",
    "title": "14  Creación de nuevas funciones en R",
    "section": "14.2 Definición de una función",
    "text": "14.2 Definición de una función\n\nEn R, una función es un bloque de código reutilizable que realiza una tarea específica. Las funciones toman argumentos de entrada, ejecutan una serie de instrucciones y pueden devolver un resultado.\n\nPara ejemplificar, podemos decir que la noción de función en programación se asemeja a la idea matemática de función de una o más variables. Pensemos en la función \\(f(x, y) = x^2 + 3y\\) (ejemplo 1). Si queremos saber cuál es el valor numérico de la función \\(f\\) cuando \\(x\\) toma el valor \\(4\\) e \\(y\\) toma el valor \\(5\\), reemplazamos en la expresión anterior las variables por los valores mencionados y obtenemos: \\(f(4, 5) = 4^2 + 3 \\times 5 = 31\\).\nPodemos definir dicha función en R de la siguiente manera:\n\nf &lt;- function(x, y) {\n    resultado &lt;- x^2 + 3 * y\n    return(resultado)\n}\n\nLa estructura general de la definición de una función consta de tres componentes:\nnombre &lt;- function(argumentos) {\n  cuerpo\n}\n\nNombre: elegido por nosotros, respetando las reglas para la elección de nombres para objetos y buscando que provea una buena descripción del propósito de la función. Usamos el operador de asignación (&lt;-) para asociar ese nombre a la definición de la función, señalada con la palabra clave function.\nArgumentos o parámetros: listado de piezas de información que la función necesita para operar y que pueden variar cada vez que es invocada. Se listan entre paréntesis y separados por comas, a la derecha de la palabra clave function.\nCuerpo: conjunto de instrucciones de programación que la función ejecuta cada vez que es invocada, encerrado por un par de llaves. Generalmente finaliza con la función return(), que indica el fin de la ejecución y provee el objeto que la función devuelve.\n\n\n\n\n\n\n\nFigura 14.1: Estructura de una función en R.\n\n\n\nUna vez que la definición de la función es ejecutada, pasa a formar parte de los objetos que conforman al ambiente global, como se puede apreciar al verla listada en el panel Environment de RStudio. A partir de este momento, podemos utilizarla, como parte de otro programa. Para invocarla, escribimos el nombre de la función y entre paréntesis los valores que nos interesan para el cálculo:\n\n# Ejemplos de uso de la función f\nf(4, 5)\n\n[1] 31\n\nf(6, -5)\n\n[1] 21\n\nf(0, 0)\n\n[1] 0\n\n\nLos parámetros o argumentos constituyen el input o información de entrada con la cual se realizarán las operaciones. Considerando el ejemplo, decimos que \\(x\\) e \\(y\\) son los parámetros formales o ficticios, ya que son símbolos que permiten expresar de manera general las acciones que la función ejecuta. Describen lo que uno diría en palabras: “hay que tomar a \\(x\\), elevarlo al cuadrado y sumarle la \\(y\\) multiplicada por 3”.\nLos valores en los cuales se quiere evaluar la función se llaman parámetros actuales o reales. Por ejemplo, si nos interesa calcular \\(f(4, 5)\\), los valores \\(4\\) y \\(5\\) son los parámetros actuales y se establece una correspondencia entre el parámetro formal \\(x\\) y el actual \\(4\\), así como entre la \\(y\\) y el \\(5\\). El resultado que se obtiene, como observamos antes, es \\(31\\) y este es el valor que la función devuelve.\nRecordando lo discutido en Sección 2.6, podemos apreciar que los siguientes usos de la función f() son equivalentes:\n\nf(4, 5)\n\n[1] 31\n\nf(x = 4, y = 5)\n\n[1] 31\n\nf(y = 5, x = 4)\n\n[1] 31\n\n\nSin embargo, no son equivalentes los siguientes:\n\n# Siguiendo el orden de definición, x recibe el valor 4 e y recibe el 5:\nf(4, 5)\n\n[1] 31\n\n# Siguiendo el orden de definición, x recibe el valor 5 e y recibe el 4:\nf(5, 4)\n\n[1] 37\n\n\nA continuación, podemos ver casos que generan error por hacer un uso incorrecto de la función:\n\n# Error por omitir un argumento de uso obligatorio (x recibe 4, falta y)\nf(4)\n\nError in f(4): argument \"y\" is missing, with no default\n\n\n\n# Error por proveer más argumentos de los declarados en la definición\nf(4, 5, 6)\n\nError in f(4, 5, 6): unused argument (6)",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Creación de nuevas funciones en R</span>"
    ]
  },
  {
    "objectID": "capitulos/03_1_crear_funciones.html#función-return",
    "href": "capitulos/03_1_crear_funciones.html#función-return",
    "title": "14  Creación de nuevas funciones en R",
    "section": "14.3 Función return()",
    "text": "14.3 Función return()\nLa instrucción return() provoca la inmediata finalización de la ejecución de la función e indica cuál es el objeto que la misma devuelve como resultado. Aunque generalmente lo encontramos al final de la definición de la función, es posible incluir más de un return() para que el resultado dependa de alguna condición, aunque sólo uno llegue a ejecutarse.\n\nUso de dos instrucciones return() en la definición de una función que devuelve cuál es el mayor entre dos números:\n\nmaximo &lt;- function(num1, num2) {\n    if (num1 &gt; num2) {\n        return(num1)\n    } else {\n        return(num2)\n    }\n}\n\nmaximo(0, 10)\n\n[1] 10\n\nmaximo(0, -10)\n\n[1] 0\n\n\n\nLa función return() puede omitirse, ya que si no está presente se devuelve el resultado de la última expresión analizada. Por eso, las siguientes funciones son equivalentes:\n\n# return explícito\nsumar1 &lt;- function(x, y) {\n    resultado &lt;- x + y\n    return(resultado)\n}\n\n# return implícito\nsumar2 &lt;- function(x, y) {\n    x + y\n}\n\nsumar1(4, 5)\n\n[1] 9\n\nsumar2(4, 5)\n\n[1] 9\n\n\nNo obstante, es aconsejable usar return() para evitar ambigüedades y ganar en claridad. Además, en funciones más complejas, su uso puede ser indispensable para indicar el término de la evaluación de la función.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Creación de nuevas funciones en R</span>"
    ]
  },
  {
    "objectID": "capitulos/03_1_crear_funciones.html#argumentos-con-valores-asignados-por-defecto",
    "href": "capitulos/03_1_crear_funciones.html#argumentos-con-valores-asignados-por-defecto",
    "title": "14  Creación de nuevas funciones en R",
    "section": "14.4 Argumentos con valores asignados por defecto",
    "text": "14.4 Argumentos con valores asignados por defecto\nHemos visto que algunos argumentos de las funciones predefinidas de R tienen valores asignados por defecto, como es el caso de la función log(), que a menos que indiquemos otra cosa opera con la base natural. Cuando definimos nuestras propias funciones, también es posible asignarle un valor por defecto a uno o más de sus argumentos.\nRecordemos la definición de la función f:\n\nf &lt;- function(x, y) {\n    resultado &lt;- x^2 + 3 * y\n    return(resultado)\n}\n\nEsta función también podría ser definida así:\n\nnueva_f &lt;- function(x, y = 100) {\n    resultado &lt;- x^2 + 3 * y\n    return(resultado)\n}\n\nEsto significa que si no proveemos un valor para el argumento y, se le asignará por default el valor 100. Luego:\n\nnueva_f(4)\n\n[1] 316\n\n\nEn el caso anterior se hace corresponder el 4 al primer argumento de la función, x, y como no proveemos ningún otro parámetro actual, y recibe por defecto el valor 100 y se calcula: x^2 + 3 * y = 16 + 300 = 316.\nPor supuesto, podemos proveer cualquier otro valor para y, de modo que no se use el valor asignado por default:\n\nnueva_f(4, 5)\n\n[1] 31\n\n\nComo x no tiene valor asignado por default en la función nueva_f(), siempre debemos pasarle uno. En caso contrario, recibiremos un error:\n\nnueva_f(y = 5)\n\nError in nueva_f(y = 5): argument \"x\" is missing, with no default\n\nnueva_f()\n\nError in nueva_f(): argument \"x\" is missing, with no default",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Creación de nuevas funciones en R</span>"
    ]
  },
  {
    "objectID": "capitulos/03_1_crear_funciones.html#sec-donde-escribir",
    "href": "capitulos/03_1_crear_funciones.html#sec-donde-escribir",
    "title": "14  Creación de nuevas funciones en R",
    "section": "14.5 ¿Dónde escribimos el código que define nuestras funciones?",
    "text": "14.5 ¿Dónde escribimos el código que define nuestras funciones?\nEl código que define una función tiene que ser ejecutado antes que el código que pretende usarla, de modo que la función aparezca entre los objetos disponibles del Global Environment. No podemos usar una función cuya definición no haya sido ejecutada, puesto que produciremos un error que indica que tal objeto no existe. Esto nos obliga a pensar dónde escribimos el código para crear nuevas funciones y en qué momento es ejecutado.\nEn proyectos de pequeña extensión, donde todo el problema se resuelve en un único y acotado script y sólo se definen unas pocas nuevas funciones, podemos incluirlas al comienzo del archivo, para que sean evaluadas antes del código que las invoca.\n\nA continuación se presenta el contenido de un breve script de código que comienza con la definición de dos funciones, usadas posteriormente.\n\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf &lt;- function(x, y) {\n    resultado &lt;- x^2 + 3 * y\n    return(resultado)\n}\n\nmaximo &lt;- function(num1, num2) {\n    if (num1 &gt; num2) {\n        return(num1)\n    } else {\n        return(num2)\n    }\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA\n# ---------------------------------------------------------------\n\nrtdo1 &lt;- f(2, 5)\nrtdo2 &lt;- f(3, 10)\nrtdo3 &lt;- maximo(rtdo1, rtdo2) + 20\ncat(\"El resultado es\", rtdo3)\n\n\n\n¿Cuál es el mensaje que emite la última línea del script del ejemplo?\n.\n\nCuanto más grande o complejo es el problema a resolver, más funciones deben ser programadas. Por eso, con el objetivo de tener un mayor orden en nuestro código, podemos escribir nuestras funciones en uno o más archivos separados, creados específicamente para esto (“scripts de funciones”). Si lo hacemos, al comienzo del script en el que estamos resolviendo un problema que involucra el uso de las funciones creadas, debemos incluir una instrucción para que el script de funciones sea evaluado, de modo que las funciones ahí definidas sean ejecutadas y pasen a formar parte del Global Environment. Esta instrucción es la función source(), que toma como único argumento el nombre del script de funciones.\nPara ilustrar esto, vamos a recordar que en el ejercicio 6 de la Práctica 2 escribimos un programa para el cálculo de factoriales. Dado que los mismos son muy útiles en variadas aplicaciones, podemos definir una nueva función se encargue de obtenerlos. Escribimos la definición en un script llamado funciones.R, cuyo contenido es:\n\nfact &lt;- function(n) {\n    resultado &lt;- 1\n    if (n &gt; 0) {\n        for (i in 1:n) {\n            resultado &lt;- resultado * i\n        }\n    }\n    return(resultado)\n}\n\nLuego, en cualquier script donde se presente un problema que requiera el cálculo de factoriales, vamos a pedirle a R que ejecute el código guardado en funciones.R con la sentencia source(), como paso inicial. Por ejemplo, en el script mis_factoriales.R se usa la función fact() para calcular el factorial de los primeros diez números naturales. Su contenido es:\n\n# ---------------------------------------------------------------\n# PROGRAMA: Mostrar los factoriales de los 10 primeros naturales\n# ---------------------------------------------------------------\n\nsource(\"funciones.R\")\n\nfor (j in 1:10) {\n    cat(\"El factorial de\", j, \"es igual a\", fact(j), \"\\n\")\n}\n\n\n\nEl factorial de 1 es igual a 1 \nEl factorial de 2 es igual a 2 \nEl factorial de 3 es igual a 6 \nEl factorial de 4 es igual a 24 \nEl factorial de 5 es igual a 120 \nEl factorial de 6 es igual a 720 \nEl factorial de 7 es igual a 5040 \nEl factorial de 8 es igual a 40320 \nEl factorial de 9 es igual a 362880 \nEl factorial de 10 es igual a 3628800 \n\n\nGracias a source() todas las funciones definidas en el archivo funciones.R aparecerán en el entorno y no hay necesidad ni siquiera de abrirlo. Esto funcionará siempre que este archivo esté guardado en el directorio de trabajo. En caso contrario, se debe indicar en source() el path completo hacia el script de funciones (por ejemplo, C:/Documentos/Facultad/funciones.R), pero esto no es recomendable. Es preferible que todos los archivos estén correctamente organizados en la carpeta principal de nuestro proyecto y, en caso de necesitarlo, usemos rutas relativas con respecto a la misma, tal como mencionamos en Sección 5.3.\nMás adelante veremos una forma mejor de guardar y distribuir las funciones que inventamos: podemos crear un nuevo paquete de R que las almacene.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Creación de nuevas funciones en R</span>"
    ]
  },
  {
    "objectID": "capitulos/03_2_ambito.html",
    "href": "capitulos/03_2_ambito.html",
    "title": "15  Alcance de las variables",
    "section": "",
    "text": "15.1 Pasaje de parámetros\nLas funciones y los programas desde los que se invocan comunican información entre sí a través de los parámetros. Esta comunicación recibe el nombre de pasaje de argumentos y se puede realizar de distintas formas, siendo las más comunes por valor o por referencia. Algunos lenguajes de programación trabajan con uno u otro sistema, mientras que otros lenguajes permiten el uso de ambos.\nEn R, el pasaje de argumentos es por valor. Esto quiere decir que los argumentos representan valores que se transmiten desde el programa que invoca la función hacia la misma. Los objetos del Global Environment provistos como argumentos en la llamada a la función no serán modificados por su ejecución. Este sistema funciona de la siguiente forma:",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Alcance de las variables</span>"
    ]
  },
  {
    "objectID": "capitulos/03_2_ambito.html#pasaje-de-parámetros",
    "href": "capitulos/03_2_ambito.html#pasaje-de-parámetros",
    "title": "15  Alcance de las variables",
    "section": "",
    "text": "Se evalúan los argumentos actuales usados en la invocación a la función.\nLos valores obtenidos se copian en los argumentos formales dentro de la función.\nLos argumentos formales se usan como variables dentro de la función. Aunque los mismos sean modificados (por ejemplo, se les asignen nuevos valores), no se modifican los argumentos actuales en el Global Environment, sólo sus copias dentro de la función.\n\n\nAnalicemos el siguiente bloque de código para apreciar cómo es el pasaje de la información a través de los argumentos:\n\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nfun &lt;- function(x, y) {\n    x &lt;- x + 1\n    y &lt;- y * 2\n    return(x + y)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA\n# ---------------------------------------------------------------\n\na &lt;- 3\nb &lt;- 5\nd &lt;- fun(a, b)\ncat(a, b, d)\n\n3 5 14\n\ncat(x, y)\n\nError in cat(x, y): object 'x' not found\n\n\nSi el pasaje de argumentos se hace por valor, los cambios producidos en el cuerpo de la función sobre los parámetros formales no son transmitidos a los parámetros actuales en el Global Environment. Esto significa que los formales son una “copia” de los actuales. Los pasos que se siguen:\n\nEn el Global Environment, se asignan los valores: a = 3, b = 5.\nAl invocar la función, se establece la correspondencia entre a y x (que recibe el valor 3) y entre b e y que recibe el valor 5.\nDentro del cuerpo de la función, se ejecuta su primera línea, resultando en la siguiente asignación de valor: x = 3 + 1 = 4.\nSegunda línea de la función: y = 5 * 2 = 10.\nLa función devuelve el valor x + y = 4 + 10 = 14.\nEl valor 14 es asignado a la variable d del Global Environment.\nSe escribe: 3 5 14.\nSe produce un error porque en el Global Environment no han sido definidos objetos con el nombre x o y.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Alcance de las variables</span>"
    ]
  },
  {
    "objectID": "capitulos/03_2_ambito.html#ambiente-global",
    "href": "capitulos/03_2_ambito.html#ambiente-global",
    "title": "15  Alcance de las variables",
    "section": "15.2 Ambiente global",
    "text": "15.2 Ambiente global\nEl ejemplo anterior nos permite darnos cuenta que los objetos que definimos pueden “vivir” en distintos lugares… es decir, existen distintos entornos, ambientes o environments.\nEn Sección 3.5 presentamos al Global Environment, que es el espacio de trabajo principal donde se almacenan los objetos creados durante una sesión de R. Es el nivel más alto en la jerarquía de entornos y es donde se guardan variables, funciones y otros elementos definidos por el usuario. A los objetos definidos en este ambiente se les suele decir variables globales.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Alcance de las variables</span>"
    ]
  },
  {
    "objectID": "capitulos/03_2_ambito.html#ambiente-local-de-una-función",
    "href": "capitulos/03_2_ambito.html#ambiente-local-de-una-función",
    "title": "15  Alcance de las variables",
    "section": "15.3 Ambiente local de una función",
    "text": "15.3 Ambiente local de una función\nEl ambiente o entorno local para una función en particular es el espacio donde existen las variables creadas en su cuerpo. Este ambiente es temporal y solo es accesible mientras la función está en ejecución. El entorno local se crea cuando se invoca a la función y en él se almacenan los valores de los argumentos de la función y las variables definidas dentro de la misma. Una vez que la función termina su ejecución, el ambiente local desaparece, y todas las variables dentro de él se eliminan automáticamente (a menos que sean devueltas como resultado mediante return()).\nA los objetos definidos en este ambiente se les suele decir variables locales. El uso de variables locales tiene muchas ventajas. Permiten independizar el trabajo que realiza una función de las instrucciones de programación escritas en el script que la invoca, ya que las variables definidas localmente en una función no son reconocidas fuera de ella. La comunicación entre el ambiente global y el ambiente local de la función debe establecerse a través de la lista de parámetros y del objeto devuelto por la función. Esta característica hace posible dividir grandes trabajos de programación en piezas más pequeñas y que, por ejemplo, diferentes programadores puedan trabajar independientemente en un mismo proyecto, al encargarse del desarrollo de algunas de las funciones.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Alcance de las variables</span>"
    ]
  },
  {
    "objectID": "capitulos/03_2_ambito.html#variables-locales-vs-variables-globales",
    "href": "capitulos/03_2_ambito.html#variables-locales-vs-variables-globales",
    "title": "15  Alcance de las variables",
    "section": "15.4 Variables locales vs variables globales",
    "text": "15.4 Variables locales vs variables globales\nLas variables locales sólo pueden ser usadas por las instrucciones que están dentro de esa función, mientras que el Global Environment desconoce su existencia. Las variables locales a una función no tienen nada que ver con las variables que puedan ser declaradas con el mismo nombre en otros ambientes, ya sea el global o ambientes locales de otras funciones.\n\nDecimos que z es una variable global porque ha sido definida por el programa en el Global Environment. Por otro lado, las variables a y b son locales a la función f1 y no se pueden usar desde el Global Environment, porque dejan de existir una vez que termina la ejecución de f1. El error se genera porque el programa quiere usar a la variable a, que no existe en el Global Environment.\n\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf1 &lt;- function(x) {\n    a &lt;- x - 10\n    b &lt;- x + 10\n    return(a + b)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA\n# ---------------------------------------------------------------\n\nz &lt;- f1(50)\nz\n\n[1] 100\n\nz + a\n\nError: object 'a' not found\n\n\n\nUna variable local no puede ser usada en el Global Environment, pero una variable global sí puede ser usada en el ambiente local de una función.\n\nEn el siguiente caso, la función f2 puede hacer uso de la variable global y sin habérsela compartido a través de los argumentos. Cuando en el cuerpo de una función se quiere hacer uso de una variable (y), R primero la busca en el ambiente local. Si existe allí, opera con el valor que tiene almacenado. Si no existe, en lugar de producir un error, la busca en un ambiente superior, desde el cual la función fue invocada, en este caso, el Global Environment. Si existe allí, opera con el valor que tiene almacenado. Si no existe, R produce un error.\n\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf2 &lt;- function(x) {\n    a &lt;- x * y\n    return(a)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA\n# ---------------------------------------------------------------\n\ny &lt;- 20\nf2(2)\n\n[1] 40\n\ny &lt;- 18\nf2(2)\n\n[1] 36\n\n\n\n\nLa práctica anterior no es recomendable: si bien evaluemos f2(2) dos veces, el resultado no fue el mismo, porque depende de cuánto vale y en el ambiente global en el momento que f2 es invocada. Además de ser confuso, esto es una violación al principio de transparencia referencial: una función idealmente sólo debe utilizar objetos mencionados en la lista de argumentos o definidos localmente, sin emplear variables globales. En particular, si hablamos de una función donde el pasaje de parámetros es por valor, esta práctica garantiza que la misma siempre devuelva el mismo resultado cada vez que sea invocada con los mismos valores en los argumentos de entrada, sin producir ningún efecto secundario en el Global Environment. El uso de variables globales dentro de los ambientes locales de las funciones permite escribir programas que carecen de transparencia referencial.\n\nSe puede usar el mismo nombre para variables locales y globales, pero dentro del ambiente local de una función toma precedencia la variable local. Esto se conoce como name masking, porque la variable definida dentro de la función “enmascara” nombres definidos fuera de ella.\n\nEn el siguiente caso hay una variable global a en el Global Environment que recibe el valor 70 y otra variable a que es local a la función f3. Cuando f3 calcula a + b, lo hace con el valor de su variable local (x - 10) y no con el valor de la variable global (70):\n\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES\n# ---------------------------------------------------------------\n\nf3 &lt;- function(x) {\n    a &lt;- x - 10\n    b &lt;- x + 10\n    cat(\"Acá, dentro de la f3, el valor de a es\", a)\n    return(a + b)\n}\n\n# ---------------------------------------------------------------\n# PROGRAMA\n# ---------------------------------------------------------------\n\na &lt;- 70\nz &lt;- f3(50)\nz\ncat(\"Acá, en el programa principal, el valor de a es\", a)\na + z\n\nAcá, dentro de la f3, el valor de a es 40[1] 100\nAcá, en el programa principal, el valor de a es 70[1] 170\n\n\nSe debe prestar atención que con la función cat() en R se muestra en pantalla un mensaje en el momento en el que se ejecuta esa acción. Si el mensaje incluye mostrar valores guardados en objetos, se mostrarán los valores que los mismos tienen dentro del ambiente que está activo en ese momento. Por otro lado, lo devuelto por return() es el resultado de la ejecución de la función: el valor que la función entrega puede ser asignado a otro objeto en el Global Environment, como ocurre en la línea de z &lt;- f3(50).\n\n\nDado el siguiente código, determinar, sin ejecutarlo en R, el resultado devuelto por cada llamada a la función calcular() presentada debajo.\n\ncalcular &lt;- function(a, b = 50) {\n  x &lt;- a + b\n  return(x)\n}\n\nx &lt;- 10\nb &lt;- 100\n\n\ncalcular(5, 3): 8145260110150200Error\ncalcular(2): 8145260110150200Error\ncalcular(4, x): 8145260110150200Error\ncalcular(b, x): 8145260110150200Error\ncalcular(a = x): 8145260110150200Error\ncalcular(a = b): 8145260110150200Error\ncalcular(a = b, b = b): 8145260110150200Error\ncalcular(b = x): 8145260110150200Error",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Alcance de las variables</span>"
    ]
  },
  {
    "objectID": "capitulos/03_3_varios.html",
    "href": "capitulos/03_3_varios.html",
    "title": "16  Más allá de la definición de funciones",
    "section": "",
    "text": "16.1 El objeto NULL\nGeneralmente los lenguajes de programación poseen un elemento conocido como NULO, para representar un objeto vacío, sin información. En R, NULL representa la ausencia total de un objeto o valor. Es un objeto en sí mismo y no pertenece a ningún tipo de objeto básico (como numérico, lógico o carácter). Se usa para indicar que una variable o un elemento de una estructura de datos no existe. Suele ser usado como el objeto devuelto por funciones cuando no hay un resultado válido para retornar.\nHay funciones que devuelven el objeto NULL de forma invisible. Esto quiere decir que, si bien lo devuelven, no se imprime en la consola. Este es el caso de la función cat() que usamos para construir mensajes:\nnombre &lt;- \"Andrea\"\n\n# Esribe un mensaje, aparentemente no devuelve nada...\ncat(\"Hola,\", nombre)\n\nHola, Andrea\n\n# Asignamos su resultado a una variable:\nresultado &lt;- cat(\"Hola,\", nombre)\n\nHola, Andrea\n\n# Imprimimos en la consola y nos encontramos que cat() devuelve NULL, \n# pero de forma invisible\nresultado\n\nNULL\nEntonces si definimos una función con el objetivo de generar un mensaje, podemos prescindir del uso de return() y la función devolverá de forma invisible el objeto NULL, aunque no lo notemos ni nos interese usarlo:\nsaludar &lt;- function(nombre) {\n  cat(\"¡Hola, \", nombre, \"! ¿En qué puedo ayudarte hoy?\", sep = \"\")\n}\n\nsaludar(\"Andrea\")\n\n¡Hola, Andrea! ¿En qué puedo ayudarte hoy?\n\nsaludar(\"Gonzalo\")\n\n¡Hola, Gonzalo! ¿En qué puedo ayudarte hoy?\n\nsaludar(\"Lucía\")\n\n¡Hola, Lucía! ¿En qué puedo ayudarte hoy?\nTerminamos esta sección mencionando que en R, existen otros valores especiales que representan diferentes tipos de información ausente, indefinida o nula. Aunque parezcan similares, tienen diferencias fundamentales en cuanto a su significado, uso y comportamiento en operaciones y no deben confundirse con el objeto NULL:",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Más allá de la definición de funciones</span>"
    ]
  },
  {
    "objectID": "capitulos/03_3_varios.html#el-objeto-null",
    "href": "capitulos/03_3_varios.html#el-objeto-null",
    "title": "16  Más allá de la definición de funciones",
    "section": "",
    "text": "Definimos una función para calcular el perímetro de un cuadrado en base a la longitud de uno de sus lados. Este cálculo sólo tiene sentido si el argumento lado es un valor positivo. Si no lo es, la función devuelve NULL.\n\nperimetro_cuadrado &lt;- function(lado) {\n  if (lado &gt; 0) {\n    return(lado * 4)\n  } else {\n    return(NULL)\n  }\n}\n\nperimetro_cuadrado(10)\n\n[1] 40\n\nperimetro_cuadrado(-2)\n\nNULL\n\n# podemos guardar el resultado en una nueva variable\nx &lt;- perimetro_cuadrado(-2)\ntypeof(x)\n\n[1] \"NULL\"\n\nis.numeric(x)\n\n[1] FALSE\n\nis.null(x)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nLa mayoría de las funciones devuelven valores de forma visible: si se ejecutan en un entorno interactivo como la consola de R, el resultado se muestra automáticamente en pantalla. Este es el comportamiento por defecto de las funciones que escribimos. Recordemos la función f:\n\nf &lt;- function(x, y) {\n    resultado &lt;- x^2 + 3 * y\n    return(resultado)\n}\n\nf(4, 5)\n\n[1] 31\n\n\nPodemos “invisibilizar” el resultado devuelto por una función, así:\n\nf_invisible &lt;- function(x, y) {\n    resultado &lt;- x^2 + 3 * y\n    return(invisible(resultado))\n}\n\nf_invisible(4, 5)\n\nLa función devuelve un resultado, pero no se ve en la consola. Para usarlo o verlo, debemos guardarlo en una nueva variable:\n\nresultado &lt;- f_invisible(4, 5)\nresultado\n\n[1] 31\n\n\n\n\n\nNA son las siglas de Not Available y es un tipo especial valor lógico que generalmente representa datos faltantes o desconocidos. No es un objeto en sí mismo. Propaga su presencia en operaciones matemáticas y lógicas, ya que cualquier operación con NA generalmente devuelve NA.\n\ny &lt;- 100\nz &lt;- NA\ny + z\n\n[1] NA\n\n\nNaN son las siglas de Not a Number y es un valor numérico que generalmente surge como resultado de operaciones aritméticas imposibles de calcular, como indeterminaciones, raíces negativas, etc.\n\n0 / 0\n\n[1] NaN\n\nlog(-1)\n\nWarning in log(-1): NaNs produced\n\n\n[1] NaN\n\nsqrt(-1)\n\nWarning in sqrt(-1): NaNs produced\n\n\n[1] NaN",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Más allá de la definición de funciones</span>"
    ]
  },
  {
    "objectID": "capitulos/03_3_varios.html#manejo-de-errores-y-mensajes",
    "href": "capitulos/03_3_varios.html#manejo-de-errores-y-mensajes",
    "title": "16  Más allá de la definición de funciones",
    "section": "16.2 Manejo de errores y mensajes",
    "text": "16.2 Manejo de errores y mensajes\nYa hemos visto en varias ocasiones que cuando no usamos las funciones de R como deberíamos, obtenemos un mensaje de error. Las funciones que creamos nosotros también pueden contar con esta característica. Si la función no puede completar su tarea, debe lanzar un error utilizando stop(), que interrumpe inmediatamente su ejecución, o bien emitir un mensaje o advertencia.\n\nLos mecanismos de manejo de errores, advertencias y mensajes nos permiten:\n\nDetectar y comunicar problemas de manera clara al usuario.\nEvitar que el programa continúe ejecutándose con resultados incorrectos.\nManejar el error sin interrumpir el flujo de ejecución general (no lo veremos en este material).\n\nR proporciona varias herramientas para estos fines, siendo las más comunes stop(), warning() y message().\n\n\n16.2.1 stop(): para errores críticos\nLa función stop() se usa para detener inmediatamente la ejecución de una función cuando ocurre una situación que impide que pueda continuar correctamente. El texto proporcionado como argumento se muestra al usuario como un error.\n\nControlamos que el argumento nombre sea de tipo carácter para poder emitir un saludo de manera adecuada:\n\nsaludar &lt;- function(nombre) {\n  if (!is.character(nombre)) {\n    stop(\"Debe proveer una cadena de texto con el nombre de la persona.\")\n  }\n  cat(\"¡Hola, \", nombre, \"! ¿En qué puedo ayudarte hoy?\", sep = \"\")\n}\n\nsaludar(\"Eli\")\n\n¡Hola, Eli! ¿En qué puedo ayudarte hoy?\n\nsaludar(100)\n\nError in saludar(100): Debe proveer una cadena de texto con el nombre de la persona.\n\n\n\n\n\n16.2.2 warning(): para advertencias no fatales\nLa función warning() se utiliza cuando hay algo que podría estar mal, pero no impide continuar con la ejecución. La función sigue adelante, pero el usuario recibe una advertencia.\n\nVerificamos que el argumento b que seré el divisor en la cuenta no sea igual a cero.\n\ndivision &lt;- function(a, b) {\n  if (b == 0) {\n    warning(\"El divisor es 0. El resultado es una indefinición.\")\n  }\n  return(a / b)\n}\n\ndivision(10, 2)\n\n[1] 5\n\ndivision(10, 0)\n\nWarning in division(10, 0): El divisor es 0. El resultado es una indefinición.\n\n\n[1] Inf\n\n\n\n\n\n16.2.3 message(): para informar sin interrumpir\nCuando se quiere comunicar algo al usuario sin que se considere un error o advertencia, se puede usar message(). Es útil para brindar información adicional, como el progreso de una operación.\n\n\ncuadrado &lt;- function(x) {\n  if (!is.numeric(x)) {\n    stop(\"x debe ser un valor numérico.\")\n  }\n  message(\"Calculando el cuadrado del número...\")\n  resultado &lt;- x^2\n  message(\"Cálculo finalizado.\")\n  return(resultado)\n}\n\ncuadrado(4)\n\nCalculando el cuadrado del número...\n\n\nCálculo finalizado.\n\n\n[1] 16\n\n\n\n\n\n¿Por qué no se emite el mensaje \"Calculando el cuadrado del número...\" en el siguiente caso?\n\ncuadrado(\"cuatro\")\n\n¿Por qué no se emite el mensaje \"Cálculo finalizado\" en el siguiente caso?\n\ncuadrado_otra &lt;- function(x) {\n  if (!is.numeric(x)) {\n    stop(\"x debe ser un valor numérico.\")\n  }\n  message(\"Calculando el cuadrado del número...\")\n  resultado &lt;- x^2\n  return(resultado)\n  message(\"Cálculo finalizado.\")\n}\n\ncuadrado_otra(4)\n\n\n\n\nLas siguientes son algunas buenas prácticas al manejar errores:\n\nInformar claramente qué salió mal y, si es posible, cómo corregirlo.\nValidar los argumentos de entrada antes de realizar operaciones.\nUsar stop() para errores que impiden continuar y warning() para situaciones potencialmente problemáticas pero no fatales.\nRecordar que una buena función no solo produce un resultado correcto, sino que también falla de manera informativa cuando algo no está bien.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Más allá de la definición de funciones</span>"
    ]
  },
  {
    "objectID": "capitulos/03_3_varios.html#sec-factorial",
    "href": "capitulos/03_3_varios.html#sec-factorial",
    "title": "16  Más allá de la definición de funciones",
    "section": "16.3 Documentación de las funciones",
    "text": "16.3 Documentación de las funciones\nEn el contexto de la programación, documentar significa escribir indicaciones para que otras personas puedan entender lo que queremos hacer en nuestro código o para que sepan cómo usar nuestras funciones. Como vimos en Sección 2.6, todas las funciones predefinidas de R están documentadas para que podamos buscar orientación sobre su uso en el panel de ayuda si lo necesitamos. Cuando estamos creando nuestras propias funciones, es importante que también incluyamos comentarios para guiar a otras personas (y a nosotros mismos en el futuro, si nos olvidamos) para qué y cómo se usa lo que estamos desarrollando.\nEstas aclaraciones pueden incluirse antes de la definición de la función mediante líneas comentadas con # o podemos hacerlo siguiendo estándares ya establecidos por la comunidad de desarrolladores. Si lo hacemos, gozaremos de la ventaja de que las páginas de ayuda sobre nuestras funciones se puedan generar automáticamente cuando las incluimos en la creación de nuevo paquete de R, como veremos en la última unidad de la asignatura.\nRStudio ofrece ayuda para escribir la documentación de una función bajo el sistema Roxygen, que provee pautas para escribir comentarios con un formato especial, incluyendo toda la información requerida para describir qué hace una función justo antes de su definición. Podemos usar este sistema para desarrollar la costumbre de escribir la documentación al mismo tiempo que creamos la función, sin que se vuelva una carga pesada para más adelante.\nPara ejemplificar, retomemos la función que escribimos para calcular factoriales. Ya que aprendimos a originar errores, le agregamos la verificación para el argumento n:\n\nfact &lt;- function(n) {\n  if (n &lt; 0 || n != floor(n)) {\n    stop(\"n debe ser entero no negativo.\")\n  }\n    resultado &lt;- 1\n    if (n &gt; 0) {\n        for (i in 1:n) {\n            resultado &lt;- resultado * i\n        }\n    }\n    return(resultado)\n}\n\nAl trabajar en el editor de scripts y con el cursor posicionado dentro del cuerpo de la función, vamos al menú Code y elegimos la opción Insert Roxygen Skeleton. Por encima de la función se incluirá un “esqueleto” o “plantilla” para que podamos comenzar a escribir la documentación:\n\n#' Title\n#'\n#' @param n \n#'\n#' @return\n#' @export\n#'\n#' @examples\nfact &lt;- function(n) {\n  if (n &lt; 0 || n != floor(n)) {\n    stop(\"n debe ser entero no negativo.\")\n  }\n  resultado &lt;- 1\n  if (n &gt; 0) {\n    for (i in 1:n) {\n      resultado &lt;- resultado * i\n    }\n  }\n  return(resultado)\n}\n\nPresentamos algunas pautas generales para entender la estructura de los comentarios Roxygen:\n\nUn bloque Roxygen es una secuencia de líneas que comienzan con #' (opcionalmente precedido por un espacio en blanco).\nLa primera línea es el título de la función, que no tiene que coincidir con su nombre. En este caso, podemos poner: “Cálculo de factoriales”.\nLuego se especifican los distintos campos de la documentación, haciendo uso de etiquetas (tags) que comienzan con @, aparecen al principio de una línea y su contenido se extiende hasta el inicio de la siguiente etiqueta o el final del bloque. Sirven para señalar qué tipo de información vamos a escribir (por ejemplo, qué hace cada argumento, qué devuelve la función, etc.). Algunas de las etiquetas más importantes a incluir son:\n\n@description: es lo que aparece primero en la documentación y debe describir brevemente qué hace la función.\n@details: esta sección proporciona cualquier otro detalle importante sobre el funcionamiento de la función.\n@param: se detalla para qué sirve cada parámetro de la función. Debe proporcionar un resumen conciso del tipo de parámetro (por ejemplo, es un character o un numeric). Es una oración, por lo que debe comenzar con mayúscula y terminar con punto. Puede abarcar varias líneas (o incluso párrafos) si es necesario. Todos los parámetros deben estar documentados, cada uno con su propia etiqueta. RStudio automáticamente incluye tanta etiquetas como parámetros formales hayamos definido.\n@return: explica qué objeto devuelve la función.\n@examples: incluye ejemplos del uso de la función.\nEn el esqueleto se incluye también la etiqueta @export, que sólo es relevante en el contexto del desarrollo de nuevos paquetes, por lo cual por ahora la eliminamos.\n\n\nTeniendo en cuenta lo anterior, completamos la documentación para nuestra función:\n\n#' Cálculo de factoriales\n#' \n#' @description\n#' Calcula el factorial de números enteros no negativos.\n#'\n#' @details \n#' Produce un error si se quiere calcular el factorial de un número negativo.\n#' \n#' @param n Número entero no negativo para el cual se calcula el factorial.\n#'\n#' @return El factorial de n.\n#'\n#' @examples\n#' fact(5)\n#' fact(0)\n#' \nfact &lt;- function(n) {\n  if (n &lt; 0 || n != floor(n)) {\n    stop(\"n debe ser entero no negativo.\")\n  }\n  resultado &lt;- 1\n  if (n &gt; 0) {\n    for (i in 1:n) {\n      resultado &lt;- resultado * i\n    }\n  }\n  return(resultado)\n}",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Más allá de la definición de funciones</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html",
    "href": "capitulos/03_practica.html",
    "title": "Práctica de la Unidad 3",
    "section": "",
    "text": "Ejercicio 1",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-1",
    "href": "capitulos/03_practica.html#ejercicio-1",
    "title": "Práctica de la Unidad 3",
    "section": "",
    "text": "Definir una nueva función f1(x1, x2, x3) que calcule y devuelva la siguiente expresión matemática:\n\\[\n\\frac{x_1}{x_2} + x_3^2 + x_2 * x_3\n\\]\nEjemplo de su uso:\n&gt; f1(5, 2, 3)\n[1] 17.5\nModificar el código de f1 para crear una función f2(x1, x2, x3) que realiza el mismo cálculo, pero asumiendo que los argumentos x2 y x3 son opcionales. Si el usuario de la función no provee un valor para ellos, deben tomar el valor 1. Chequear que el resultado coincide con los siguientes ejemplos y analizar por qué se originan:\n&gt; f2(5, 2, 3)\n[1] 17.5\n\n&gt; f2(5)\n[1] 7\n\n&gt; f2(5, 2)\n[1] 5.5\n\n&gt; f2(5, x3 = 3)\n[1] 17\n\n&gt; f2(x2 = 2, x3 = 3)\nError in f2(x2 = 2, x3 = 3) : argument \"x1\" is missing, with no default\nModificar el código de f2 para crear una función f3(x1, x2, x3) que realiza el mismo cálculo, con los mismos valores por defecto para x2 y x3, pero que devuelve -100 si alguno de los argumentos es un valor negativo. Ejemplos de su uso:\n&gt; f3(5, 2, 3)\n[1] 17.5\n\n&gt; f3(-5, 2, 3)\n[1] -100\n\n&gt; f3(-5)\n[1] -100\n\n&gt; f3(5, x3 = -3)\n[1] -100",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-2",
    "href": "capitulos/03_practica.html#ejercicio-2",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nDados dos números enteros a y b que pueden ser negativos o positivos, crear una función llamada suma_secuencia(a, b) para calcular la suma de todos los números enteros entre a y b, incluyéndolos. Si estos números son iguales, la función debe devolver el valor que comparten. Ejemplos de su uso:\n&gt; suma_secuencia(1, 3)\n[1] 6\n&gt; suma_secuencia(30, 40)\n[1] 385\n&gt; suma_secuencia(5, 2)\n[1] 14\n&gt; suma_secuencia(-2, 3)\n[1] 3\n&gt; suma_secuencia(-7, -5)\n[1] -18\n&gt; suma_secuencia(-3, -3)\n[1] -3\n&gt; suma_secuencia(3, 3)\n[1] 3\n&gt; suma_secuencia(-3, -5)\n[1] -12",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-3",
    "href": "capitulos/03_practica.html#ejercicio-3",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nEscribir un programa en R para la creación de la función triangulos(a, b, c) que a partir de la longitud de los tres lados de un triángulo a, b y c (valores positivos) lo clasifica con los siguientes resultados posibles:\n\nNo forman un triángulo (un lado mayor que la suma de los otros dos).\nTriángulo equilátero (tres lados iguales).\nTriángulo isósceles (dos lados iguales).\nTriángulo escaleno (tres lados distintos).\n\nComo resultado, la función devuelve uno de estos valores de tipo carácter, según corresponda: “no es triángulo”, “equilátero”, “isósceles” o “escaleno”.\nEjemplos de uso:\ntriangulos(2, 3, 4)\n[1] \"escaleno\"\ntriangulos(2, 3, 10)\n[1] \"no es triángulo\"",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-4",
    "href": "capitulos/03_practica.html#ejercicio-4",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nEscribir un programa en R para la creación de la función elipse(x, y) que permite determinar si un punto de coordenadas \\((x, y)\\) está dentro o no de la elipse definida por la ecuación:\n\\[\\frac{(x - 6) ^ 2}{36} + \\frac{(y + 4) ^ 2}{16} = 1\\]\nSi el punto está contenido en la elipse, la función devuelve el valor lógico TRUE y en caso contrario, FALSE. En caso de que sea invocada sin valores para los argumentos x e y, la función realiza la misma evaluación pero para el origen, es decir, para el punto \\((0, 0)\\).\nObservación: si un punto se encuentra exactamente sobre la curva definida por la elipse, la fórmula anterior evaluada en las coordenadas \\((x, y)\\) del punto es exactamente igual a 1. Si el punto está dentro de la elipse, da menor que 1. Si está fuera, da mayor que 1. A continuación se presenta la representación gráfica de la elipse en cuestión:\n\n\n\n\n\nEjemplos del uso de la función:\nelipse(3, 7)\n[1] FALSE\nelipse(6, -4)\n[1] TRUE\nelipse()\n[1] FALSE",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-5",
    "href": "capitulos/03_practica.html#ejercicio-5",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nImaginemos que con los números impares podemos crear una pirámide como la que se muestra a continuación:\n             1\n          3     5\n       7     9    11\n   13    15    17    19\n21    23    25    27    29\nUna pirámide puede tener cualquier cantidad de líneas. Definir una función llamada suma_piramide(n) que calcule la suma de los números impares en alguna la fila número n. Por ejemplo:\n&gt; suma_piramide(1)\n[1] 1\n&gt; suma_piramide(2)\n[1] 8\n&gt; suma_piramide(3)\n[1] 27\n\n# Evaluamos la suma de cada una de las primeras 10 filas\nfor (n in 1:10) {\n   suma &lt;- suma_piramide(n)\n   cat(\"Los impares de la fila\", n, \"suman\", suma, \"\\n\")\n}\n\nLos impares de la fila 1 suman 1 \nLos impares de la fila 2 suman 8 \nLos impares de la fila 3 suman 27 \nLos impares de la fila 4 suman 64 \nLos impares de la fila 5 suman 125 \nLos impares de la fila 6 suman 216 \nLos impares de la fila 7 suman 343 \nLos impares de la fila 8 suman 512 \nLos impares de la fila 9 suman 729 \nLos impares de la fila 10 suman 1000",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-6",
    "href": "capitulos/03_practica.html#ejercicio-6",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\n\nSin utilizar la computadora, indique cuál es el valor devuelto por g(a, b) luego de que este programa sea evaluado:\n\nf &lt;- function(a = 10) {\na &lt;- (a - 10) * (a + 10)\n  return(a)\n}\n\ng &lt;- function(x, y) {\n  b &lt;- x - y * 2\n  c &lt;- b * f(b)\n  d &lt;- f() - c\n  return(d)\n}\n\na &lt;- 6\nb &lt;- 1\ng(a, b)\n\nSin utilizar la computadora, indique cuál es el valor de z que se muestra el algoritmo y explique por qué se indica que la última línea produce un error:\n\nf1 &lt;- function(a, b) {\n  x &lt;- a + b\n  y &lt;- x + 2\n  return(y)\n}\n\nf2 &lt;- function(x) {\n  return(x^2)\n}\n\n# PROGRAMA: Ejemplo de ámbito de las variables\nx &lt;- 3\ny &lt;- 5\na &lt;- f1(x, y)\nz &lt;- x + f2(a)\nprint(z)\nprint(a + b) # esta línea produce un error\n\nSin usar la computadora, indique cuál es el resultado de evaluar a + b + c + d en la última línea del siguiente código:\n\nf = function(x, y = 5, z = x + y) {\n  u = z - x - y\n  return(u)\n}\n\na = f(10)\nb = f(10, 10)\nc = f(10, 10, 10)\nd = f(10, z = 10)\n\na + b + c + d",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#sec-resolvente",
    "href": "capitulos/03_practica.html#sec-resolvente",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\nEscribir un programa en R para la creación de la función resolvente(a, b, c) que muestra las soluciones de la ecuación de segundo grado \\(a x^2 + b x + c = 0\\), empleando la fórmula resolvente:\n\\[x_{1, 2} = \\frac{-b \\pm \\sqrt{(b^2 - 4ac)}}{2a}\\]\nObservaciones:\n\nEl programa debe emitir mensajes aclaratorios si hay una solución real doble o dos soluciones complejas (en este caso, no las calcula).\nLa función escribe en pantalla las soluciones de la ecuación y no es necesario que devuelva ningún objeto en particular.\nPara calcular una raíz cuadrada, podemos usar la función sqrt().\nSi a es igual a cero, usar la función stop() para devolver un error informativo.\n\nEjemplos de uso:\n&gt; resolvente(1, -1, -2)\nHay dos soluciones reales -1 y 2 \n\n&gt; resolvente(1, 2, 1)\nHay una solución real doble: -1 \n\n&gt; resolvente(1, 1, 1)\nLas soluciones son complejas.\n\n&gt; resolvente(0, 1, 1)\nError in resolvente(0, 1, 1) : (a) debe ser distinto de cero",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-8",
    "href": "capitulos/03_practica.html#ejercicio-8",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 8",
    "text": "Ejercicio 8\nEscribir un programa en R para la creación de la función es_primo(n) que devuelve el valor lógico TRUE si el natural n es un número primo o FALSE en caso contrario. Recordar la siguiente definición:\n\nUn número primo es un número natural mayor que 1, que tiene únicamente dos divisores positivos distintos: él mismo y el 1.\n\nSi el argumento de entrada no es un natural mayor que 1, la función debe imprimir un warning y devolver FALSE como en estos ejemplos:\n&gt; es_primo(47)\n[1] TRUE\n\n&gt; es_primo(253)\n[1] FALSE\n\n&gt; es_primo(2)\n[1] TRUE\n\n&gt; es_primo(7.18)\n[1] FALSE\nWarning message:\nIn es_primo(7.18) : (n) no es entero\n\n&gt; es_primo(0)\n[1] FALSE\nWarning message:\nIn es_primo(0) : (n) no es mayor que 1",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-9",
    "href": "capitulos/03_practica.html#ejercicio-9",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 9",
    "text": "Ejercicio 9\nEscribir un programa en R para la creación de la función cociente(dividendo, divisor) que permite obtener cociente entero y resto en la división de dos números naturales (llamados dividendo y divisor) empleando únicamente operaciones aritméticas de suma y resta. La función escribe un mensaje en pantalla con los valores del dividendo, divisor, cociente y resto, mientras que devuelve el valor del cociente.\nEjemplos de su uso:\ncociente(1253, 4)\n\nDividendo: 1253   # mensajes escritos\nDivisor: 4 \nCociente: 313 \nResto: 1 \n[1] 313           # valor devuelto\n\ncociente(3, 4)\n\nDividendo: 3      # mensajes escritos\nDivisor: 4 \nCociente: 0 \nResto: 3 \n[1] 0             # valor devuelto",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-10",
    "href": "capitulos/03_practica.html#ejercicio-10",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 10",
    "text": "Ejercicio 10\nEscribir un programa en R para la creación de la función max_com_div(a, b) que permite calcular el máximo común divisor (mcd) de los números naturales a y b, empleando el algoritmo de Euclides, que propone:\n\nDividir al mayor por el menor.\nSi el resto es cero, el divisor es el máximo común divisor.\nSi el resto no es cero, dividir el divisor por el resto.\nEvaluar el nuevo resto de la misma forma y repetir hasta hallar un resto igual a cero. Cuando esto ocurre, el último divisor es el mcd.\n\nEjemplos de uso:\nmax_com_div(100, 24)\n4\n\nmax_com_div(25, 100)\n25\n\nmax_com_div(24, 24)\n24",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-11",
    "href": "capitulos/03_practica.html#ejercicio-11",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 11",
    "text": "Ejercicio 11\n\nDescargar el archivo funciones_unidad3.R en el que se encuentra ya definida la función fact() tal como se presentó en Documentación de las funciones. Guardar este archivo en la carpeta del proyecto de esta unidad.\nAgregar en ese script código para crear una nueva función combinatorio(m, n) que calcula el número combinatorio m tomado de a n (también llamado coeficiente binomial), siendo estos números naturales tales que m &gt;= n. La función combinatorio() debe invocar a la función fact() ya provista, teniendo en cuenta que un número combinatorio se define como:\n\\[\nC(m, n) = {m \\choose n} = \\frac{m!}{(m-n)!n!}\n\\]\nCrear otro script llamado ejercicio_11.R, en el cual escribiremos ejemplos de uso de la función combinatorio(m, n). En primera instancia, incluir en este script la sentencia source(funciones_unidad3.R) para que el contenido del script de funciones sea ejecutado y las mismas sean creadas en el ambiente global. Luego, utilizar la función combinatorio(m, n) para ejemplificar las siguientes propiedades de los números combinatorios:\n\n\\({m \\choose 0} = 1\\)\n\\({m \\choose m} = 1\\)\n\\({m \\choose 1} = m\\)\n\\({m \\choose n} = {m \\choose m - n}\\)\n\\({m \\choose n} = {m - 1 \\choose n - 1} + {m - 1 \\choose n}\\)\n\nEs importante recordar que los números combinatorios sólo están definidos para m &gt;= n. Probar qué ocurre pasando un valor de n mayor que m.\nEl número combinatorio m tomado de a n con reposición se define como:\n\\[\n\\bar{C}(m, n) = {m + n - 1 \\choose n} = \\frac{(m+n-1)!}{(m-1)!n!}\n\\]\nEn base a lo realizado anteriormente, crear la función combinatorio2(m, n, r) para generalizar el cálculo de números combinatorios, siendo r un argumento adicional que toma el valor lógico TRUE si el cálculo es con reposición, y FALSE en caso contrario.\nConsideraciones:\n\nUsar la función combinatorio(m, n) para implementar esta nueva función.\nPor defecto, la función debe hacer el cálculo del número combinatorio sin reposición.\nPara m = 5 y n = 2, pruebe si el número de combinaciones posibles es mayor con o sin resposición.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_practica.html#ejercicio-12",
    "href": "capitulos/03_practica.html#ejercicio-12",
    "title": "Práctica de la Unidad 3",
    "section": "Ejercicio 12",
    "text": "Ejercicio 12\nEscribir la documentación de cada una de las funciones creadas en esta unidad, siguiendo el formato Roxygen.",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_actividad_autoevaluativa.html",
    "href": "capitulos/03_actividad_autoevaluativa.html",
    "title": "Actividad de autoevaluación 3",
    "section": "",
    "text": "Pregunta 1\n¿Qué problema/s tiene la siguiente definición de una función en R?\nf0 &lt;- function(a b) {\n  x &lt;- a + b\n  x * 100\n}\nFalta una sentencia de tipo return()Falta una comaLas dos anterioresNingún problema",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Actividad de autoevaluación 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_actividad_autoevaluativa.html#pregunta-2",
    "href": "capitulos/03_actividad_autoevaluativa.html#pregunta-2",
    "title": "Actividad de autoevaluación 3",
    "section": "Pregunta 2",
    "text": "Pregunta 2\nConsiderar la siguiente función:\n\nf1 &lt;- function(x, y) {\n  if(y == \"operar\") {\n    x &lt;- x * 2\n    rtdo &lt;- x + 100\n  } else {\n    rtdo &lt;- x\n  }\n  return(rtdo)\n}\n\n¿Qué valor se obtiene si se evalúa f1(2, \"operar\")? 24102104\n¿Qué valor se obtiene si se evalúa f1(2, \"no operar\")? 24102104\n¿Qué valor se obtiene si se evalúa f1(\"operar\", 2)? 24102104Tira errorDevuelve una cadena de texto\n¿Qué valor se obtiene si se evalúa f1(2)? 24102104Tira errorDevuelve una cadena de texto\n¿Qué valor se obtiene si se evalúa f1(\"2\", \"operar\")? 24102104Tira errorDevuelve una cadena de texto\n¿Qué valor se obtiene si se evalúa f1(\"2\", \"jaja\")? 24102104Tira errorDevuelve una cadena de texto",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Actividad de autoevaluación 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_actividad_autoevaluativa.html#pregunta-3",
    "href": "capitulos/03_actividad_autoevaluativa.html#pregunta-3",
    "title": "Actividad de autoevaluación 3",
    "section": "Pregunta 3",
    "text": "Pregunta 3\nConsiderando la función f1 anterior junto con la función f2 y el programa que se muestran a continuación, indicar si cada una de las siguientes afirmaciones es VERDADERA o FALSA o elegir la respuesta correcta:\n\n# Definición de funciones\nf1 &lt;- function(x, y) {\n  if(y == \"operar\") {\n    x &lt;- x * 2\n    rtdo &lt;- x + 100\n  } else {\n    rtdo &lt;- x\n  }\n  return(rtdo)\n}\n\nf2 &lt;- function(z) {\n  return(z + b)\n}\n\n# Programa\nx &lt;- 10\npalabra &lt;- \"operar\"\na &lt;- f1(x, palabra)\ncat(\"Mensaje 1: el valor encontrado es \", a, \"y la variable x vale \", x, \"\\n\")\nb &lt;- 12\nc &lt;- f2(15)\ncat(\"Mensaje 2: el valor encontrado es \", c, \"\\n\")\nd &lt;- f1(5, \"no operar\") + f1(5, \"operar\")\ncat(\"Mensaje 3: el valor encontrado es\", d, \"\\n\")\n\nLa variable d es local a f1: VerdaderoFalso\nLa variable c es global: VerdaderoFalso\nLa función f2 respeta el principio de transparencia referencial: VerdaderoFalso\nLa función f2 puede devolver distintos resultados aunque le pasemos siempre el mismo valor para el parámetro formal z: VerdaderoFalso\nLa variable rtdo existe en el ambiente global del programa: VerdaderoFalso\nLa variable rtdo es local a la función f1: VerdaderoFalso\nEl texto mostrado por el primer mensaje será: Mensaje 1: el valor encontrado es 10 y la variable x vale 10Mensaje 1: el valor encontrado es 10 y la variable x vale 120Mensaje 1: el valor encontrado es 120 y la variable x vale 10Mensaje 1: el valor encontrado es 120 y la variable x vale 20\nEl texto mostrado por el segundo mensaje será: Mensaje 2: el valor encontrado es 12Mensaje 2: el valor encontrado es 15Mensaje 2: el valor encontrado es 27No se muestra un mensaje porque se produce error\nEl texto mostrado por el tercer mensaje será: Mensaje 3: el valor encontrado es 5Mensaje 3: el valor encontrado es 110Mensaje 3: el valor encontrado es 115No se muestra un mensaje porque se produce error",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Actividad de autoevaluación 3</span>"
    ]
  },
  {
    "objectID": "capitulos/03_actividad_autoevaluativa.html#pregunta-4",
    "href": "capitulos/03_actividad_autoevaluativa.html#pregunta-4",
    "title": "Actividad de autoevaluación 3",
    "section": "Pregunta 4",
    "text": "Pregunta 4\nSeleccionar la opción correcta:\nwarning() Muestra un mensaje que detiene inmediatamente la ejecución de la función.Muestra un mensaje que no detiene la ejecución del programa pero advierte al usuario de un posible error.Muestra un mensaje en la consola sin que sea considerado un error o advertencia.\nmessage() Muestra un mensaje que detiene inmediatamente la ejecución de la función.Muestra un mensaje que no detiene la ejecución del programa pero advierte al usuario de un posible error.Muestra un mensaje en la consola sin que sea considerado un error o advertencia.\nstop() Muestra un mensaje que detiene inmediatamente la ejecución de la función.Muestra un mensaje que no detiene la ejecución del programa pero advierte al usuario de un posible error.Muestra un mensaje en la consola sin que sea considerado un error o advertencia.\nNULL, NA y NaN son tres objetos que tienen comportamientos semejantes en las operaciones. VerdaderoFalso",
    "crumbs": [
      "Unidad 3. Descomposición algorítmica",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Actividad de autoevaluación 3</span>"
    ]
  },
  {
    "objectID": "capitulos/04.html",
    "href": "capitulos/04.html",
    "title": "Unidad 4. Uso de la terminal",
    "section": "",
    "text": "En esta unidad nos adentraremos en el uso de la terminal, una herramienta poderosa que permite interactuar directamente con el sistema operativo a través de comandos de texto. Aprenderemos a utilizarla en el entorno Windows para realizar tareas básicas como crear carpetas o ejecutar programas. También aprenderemos a correr scripts de R desde la terminal y a desarrollar programas que interactúen con el usuario, recibiendo información y reaccionando en consecuencia.",
    "crumbs": [
      "Unidad 4. Uso de la terminal"
    ]
  },
  {
    "objectID": "capitulos/04_1_terminal.html",
    "href": "capitulos/04_1_terminal.html",
    "title": "19  La terminal",
    "section": "",
    "text": "19.1 Introducción\nCuando encendemos nuestra computadora, normalmente interactuamos con el sistema operativo a través de una interfaz gráfica (GUI), utilizando ventanas, menús, íconos, el mouse, el teclado o incluso pantallas táctiles. Sin embargo, existe otra forma de comunicarse con la computadora: escribiendo comandos en una ventana especial llamada terminal. La terminal interpreta estos comandos y los traduce en instrucciones que la computadora puede ejecutar. Aunque hoy en día la mayoría de los usuarios utilizan la interfaz gráfica, años atrás este método era la única forma disponible para operar un sistema.\n¿Por qué aprender a usar la terminal si contamos con una interfaz gráfica que parece más sencilla? La razón principal es la eficiencia: muchas tareas tediosas y repetitivas se pueden realizar de manera mucho más rápida mediante comandos. Por ejemplo, copiar decenas de archivos que cumplen ciertos criterios de nombre puede hacerse con un solo comando en lugar de seleccionar manualmente uno por uno. Además, muchas herramientas de diagnóstico y administración de sistemas, especialmente en el ámbito de redes y servidores, solo están disponibles a través de la terminal. El uso de la terminal también permite la automatización de tareas.\nSi bien al principio puede parecer intimidante, no es un mundo completamente desconocido: ya estamos acostumbrados a escribir comandos en la consola de R, interpretando respuestas y corrigiendo errores. Aprender a usar la terminal en Windows será un paso natural que te permitirá tener un mayor control sobre nuestro entorno de trabajo y nos abrirá nuevas posibilidades para automatizar y optimizar tareas cotidianas.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>La terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_1_terminal.html#conceptos-relacionados",
    "href": "capitulos/04_1_terminal.html#conceptos-relacionados",
    "title": "19  La terminal",
    "section": "19.2 Conceptos relacionados",
    "text": "19.2 Conceptos relacionados\nEn el mundo de la programación y la informática, hay muchos términos relacionados con la interacción textual con la computadora que a veces se usan como sinónimos sin demasiada preocupación, como si fuesen distintas formas de llamar a lo mismo: una ventanita donde puedo escribir comandos y hacer que sucedan cosas en la computadora. Si bien está aceptado usar cualquiera de estas palabras, hay pequeñas diferencias entre los conceptos, que acá tratamos de resumir:\n\nLínea de comandos (Command Line Interface, CLI). La línea de comandos es una forma de interactuar con el sistema operativo escribiendo comandos, en lugar de usar ventanas y botones (interfaz gráfica o Graphical User Interface, GUI). La línea de comandos no es un programa, sino un modo de interacción. Para usarla, necesitamos programas específicos como las terminales y las shells.\nShell. Una shell es un programa que interpreta los comandos que escribimos y los traduce en instrucciones que el sistema operativo puede ejecutar. Cada shell tiene su propio lenguaje de comandos y sus propias capacidades. Algunas de las más comunes son:\n\n\n\n\n\n\n\n\nShell\nSistema\nCaracterísticas principales\n\n\n\n\nCMD.exe\nWindows\nShell clásica de Windows. Limitada, pero simple.\n\n\nPowerShell\nWindows\nMás moderna y poderosa. Permite automatizar tareas.\n\n\nBash\nLinux, macOS, WSL\nMuy usada en sistemas Unix y entornos Linux en Windows. Potente y versátil.\n\n\nsh, zsh, fish\nUnix-like\nOtras shells populares, con distintos niveles de funcionalidad y facilidad de uso.\n\n\n\nTerminal (o emulador de terminal). Una terminal (o emulador de terminal) es un programa que permite enviar comandos a una shell y mostrar sus respuestas. Es como una “ventana” desde la cual nos comunicamos con la computadora usando solo texto. Se llama emulador porque hoy en día normalmente se abre desde una interfaz gráfica, simulando las terminales físicas antiguas. La terminal no ejecuta directamente los comandos, sino que los pasa a la shell que esté configurada. Ejemplos de terminales:\n\nEn Windows: CMD, PowerShell, Windows Terminal\nEn Linux/macOS: GNOME Terminal, Konsole, Terminal.app\n\nConsola. La palabra consola tiene varios usos:\n\nHistóricamente, se refería a un dispositivo físico (un teclado y una pantalla conectados directamente a una computadora o servidor).\nActualmente, en el lenguaje cotidiano, muchas veces se usa como sinónimo de terminal.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>La terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_1_terminal.html#comandos-básicos-para-el-uso-de-la-terminal-en-windows",
    "href": "capitulos/04_1_terminal.html#comandos-básicos-para-el-uso-de-la-terminal-en-windows",
    "title": "19  La terminal",
    "section": "19.3 Comandos básicos para el uso de la terminal en Windows",
    "text": "19.3 Comandos básicos para el uso de la terminal en Windows\nEn este curso utilizaremos CMD.exe para trabajar con la terminal en Windows. CMD es más sencillo y directo que la otra opción disponible (PowerShell) y nos permitirá concentrarnos en aprender los comandos básicos sin distracciones.\nSe puede abrir la terminal CMD.exe así:\n\nHacer clic en el botón de Inicio (el ícono de Windows en la esquina inferior izquierda).\n\nEscribir cmd en el cuadro de búsqueda.\n\nAparecerá una aplicación llamada Símbolo del sistema o Command Prompt.\n\nHacer clic en ella para abrirla.\n\nAl igual que R, una terminal siempre tiene un directorio de trabajo, cuya ruta se muestra al comienzo de cada línea, antes del prompt &gt;, que señala que podemos escribir un comando. También se puede abrir la terminal desde el Explorador de archivos. En este caso, el directorio de trabajo será la carpeta desde la que se abrió la terminal.\n\n\n\n\n\n\n\nLínea de comandos de Windows. El directorio de trabajo es C:\\Users\\profesor.\n\n\nA continuación, se presentan algunos comandos esenciales que pueden usarse en CMD:\n\n\n\n\n\n\n\nComando\nDescripción\n\n\n\n\ndir\nLista los archivos y carpetas en el directorio actual.\n\n\ncd\nMuestra el directorio de trabajo actual\n\n\ncd nombre_carpeta\nCambia al directorio especificado.\n\n\ncd ..\nSube un nivel en el árbol de directorios.\n\n\nmkdir nombre\nCrea una nueva carpeta.\n\n\ndel nombre\nElimina un archivo.\n\n\nrmdir nombre\nElimina una carpeta (debe estar vacía).\n\n\ncopy archivo1.txt archivo2.txt\nCopia archivo1.txt y crea una copia llamada archivo2.txt.\n\n\nmove archivo1.txt carpeta\\\nMueve archivo1.txt a una carpeta.\n\n\nrename nombre_viejo.txt nombre_nuevo.txt\nCambia el nombre de un archivo.\n\n\ncls\nLimpia la pantalla.\n\n\necho texto\nImprime “texto” en la terminal.\n\n\necho primer texto &gt; archivo.txt\nEscribe “primer texto” en el archivo archivo.txt\n\n\necho segundo texto &gt;&gt; archivo.txt\nAgrega “segundo texto” en el archivo archivo.txt, como nueva línea, sin que se borre lo anterior.\n\n\ntype archivo.txt\nMuestra el contenido de un archivo de texto.\n\n\nhelp\nVer la ayuda de los comandos.\n\n\nexit\nCerrar la terminal.\n\n\n\n\n\n\n\n\n\n\nEjemplo del uso de los comandos cd y dir para cambiar de carpeta y mostrar el contenido.\n\n\n\nRealicemos la siguiente lista de actividades:\n\nIr al directorio de nuestra asignatura (escribí un path adecuado para tu computadora:\ncd Documents\\facultad\\anio_1\\programacion_1\nListar las carpetas y archivos allí guardados:\ndir\nCrear una nueva carpeta para la Unidad 4 (no será un RStudio Project porque no es creado desde RStudio, pero no importa):\nmkdir unidad_4\nCrear un archivo de texto simple, llamado archivo1.txt y con el contenido “Este es mi primer archivo”&gt;\necho Este es mi primer archivo &gt; archivo1.txt\nCopiar el archivo:\ncopy archivo1.txt copia_archivo1.txt\nAhora tenemos dos archivos: archivo1.txt y copia_archivo1.txt.\nRenombrar el archivo copiado:\nrename copia_archivo1.txt archivo2.txt\nCrear una subcarpeta llamada textos:\nmkdir textos\nMover el segundo archivo a la subcarpeta:\nmove archivo2.txt textos\nVerificar que los archivos se movieron:\ncd textos\ndir\nMostrar en la terminal el contenido de archivo2.txt:\ntype archivo2.txt",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>La terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_2_programas_de_R.html",
    "href": "capitulos/04_2_programas_de_R.html",
    "title": "20  Ejecución de scripts de R desde la terminal",
    "section": "",
    "text": "20.1 Requisitos\nPara poder ejecutar scripts de R desde la terminal de Windows, necesitamos:\n1. Editar la variable de entorno PATH\nCuando queramos correr un programa de R usaremos el comando Rscript. Por default, la terminal lo desconoce, porque se trata de un programa que se agregó en nuestra computadora el día que instalamos R. Por eso necesitamos indicarle al sistema operativo que Rscript es un comando que se instaló con R y que lo puede encontrar en la carpeta de los archivos de instalación del programa R. Esto hay que hacerlo una sola vez por computadora editando las variables de entorno de Windows, que son cadenas de texto que contienen información acerca del sistema. Se logra siguiendo estos pasos:\n2. Abrir la terminal y cambiar el directorio de trabajo\nA la hora de ejecutar un script desde la terminal, tenemos que cambiar el directorio de trabajo a la carpeta en la cual está guardado, con el comando cd. Luego, ejecutamos el comando Rscript nombre_archivo.R. Si no queremos cambiar el directorio de trabajo, debemos escribir el path completo hacia el script, pero esto es menos cómodo (por ejemplo: Rscript C:\\Users\\Documents\\nombre_archivo.R).\nLos scripts utilizados en los ejemplos de esta unidad pueden ser descargados desde este archivo comprimido y ubicados de forma ordenada en algún lugar de la computadora, idealmente en la carpeta destinada para esta unidad, como se muestra en la siguiente imagen.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ejecución de *scripts* de R desde la terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_2_programas_de_R.html#requisitos",
    "href": "capitulos/04_2_programas_de_R.html#requisitos",
    "title": "20  Ejecución de scripts de R desde la terminal",
    "section": "",
    "text": "Fijarse en qué carpeta de la computadora está instalado R. Seguramente lo encuentres si, abriendo el explorador de archivo, vas siguiendo este camino: Este equipo &gt; Windows (C:) &gt; Archivos de programa &gt; R &gt; R-version &gt; bin. En esta carpeta tiene que haber dos archivos, llamados R.exe y Rscript.exe. Si es así, hacé clic con el botón derecho del mouse sobre cualquiera de ellos, luego en “Propiedades” y copiá el path que aparece en “Ubicación” (deberías copiar algo como C:\\Program Files\\R\\R-4.4.3\\bin). También podés copiar el path que se ve arriba en la barra de navegación.\n\n\n\n\n\n\n\nArchivos de instalación de R en Windows.\n\n\nHacer clic en “Inicio” (logo de Windows de la barra de tareas) o presionar la tecla Windows del teclado, escribir “Entorno” y hacer clic en la opción “Editar las variables de entorno del sistema”.\nHacer clic en el botón “Variables de entorno” (abajo).\nEn el cuadro “Variables del sistema” (abajo), hacer clic en la variable “Path” y luego en “Editar”.\n\n\n\n\n\n\n\nVariables de entorno de Windows.\n\n\nHacer clic en “Nuevo”, pegar la dirección copiada antes (por ejemplo, C:\\Program Files\\R\\R-4.4.3\\bin) y dar Enter.\n\n\n\n\n\n\n\nEditar variable de entorno.\n\n\nLuego, hacer clic en “Aceptar” tres veces para confirmar y cerrar todo.\n\n\n\n\n\n\n\n\n\n\n\nCambio del directorio de trabajo a la carpeta que contiene los scripts de R.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ejecución de *scripts* de R desde la terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_2_programas_de_R.html#ejecución-de-programas-sin-interacción-del-usuario",
    "href": "capitulos/04_2_programas_de_R.html#ejecución-de-programas-sin-interacción-del-usuario",
    "title": "20  Ejecución de scripts de R desde la terminal",
    "section": "20.2 Ejecución de programas sin interacción del usuario",
    "text": "20.2 Ejecución de programas sin interacción del usuario\nEmpezaremos con el ejemplo propuesto por el script mi_programa.R que tiene este contenido:\n\na &lt;- \"¡Hola, Mundo!\"\nb &lt;- 3\nd &lt;- 5\ncat(\"==========================================\\n\")\ncat(\"                 RESULTADOS               \\n\")\ncat(\"==========================================\\n\\n\")\ncat(\"El valor de b es \", b, \", mientras que d vale \", d, \".\\n\\n\", sep = \"\")\ncat(\"La suma entre ellos es igual a \", b + d, \".\\n\\n\", sep = \"\")\ncat(\"Este es un saludo:\", a)\n\nTodo lo que en el programa está encerrado en una llamada a la función cat() es lo que se mostrará como mensajes en la terminal cuando el script sea ejecutado. En una terminal abierta y habiendo cambiado el directorio hacia la carpeta donde está guardado el script, utilizamos el comando Rscript mi_programa.R y veremos el siguiente resultado:\n\n\n\n\n\n\n\nCorrer el script mi_programa.R desde la terminal.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ejecución de *scripts* de R desde la terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_2_programas_de_R.html#ejecución-de-programas-interactivos",
    "href": "capitulos/04_2_programas_de_R.html#ejecución-de-programas-interactivos",
    "title": "20  Ejecución de scripts de R desde la terminal",
    "section": "20.3 Ejecución de programas interactivos",
    "text": "20.3 Ejecución de programas interactivos\nCorrer scripts desde la terminal nos permite crear programas interactivos, que soliciten información al usuario y actúen en función de esa entrada. Este enfoque es particularmente útil cuando necesitamos que el usuario proporcione datos específicos o haga elecciones durante la ejecución del programa, sin depender de interfaces gráficas complejas. Al usar funciones de R como scan(), podemos diseñar scripts que personalicen su comportamiento según las respuestas del usuario.\nPor ejemplo, el script saludo.R preguntará al usuario “¿Cómo te llamás?” y luego responderá con un saludo. Su contenido es:\n\ncat(\"***************************************\\n\")\ncat(\"¿Cómo te llamás?\\n&gt; \")\nnombre &lt;- scan(file = \"stdin\", what = character(), n = 1, quiet = TRUE)\ncat(\"¡Hola, \", nombre, \"!\\n\", sep = \"\")\ncat(\"***************************************\\n\")\n\nLa función scan() es la que permite escanear o leer valores que los usuarios ingresen por la terminal. Sus argumentos incluyen:\n\nfile: especifica desde donde se lee la información. Debemos setearlo como file = \"stdin\" porque vamos a leer información desde la terminal.\nwhat: determina el tipo de dato a leer, generalmente un valor numérico o una cadena de texto. Si queremos leer un número, no es necesario usarlo, ya que por default se tiene what = double() y hace eso. En cambio, si queremos leer texto, como en este ejemplo, debemos indicar what = character().\nn: cantidad de valores a leer (uno solo en el ejemplo).\nquiet: valor lógico que determina si la función opera escribiendo detalles adicionales en la consola (FALSE, valor por defecto, no lo desemos) o de forma silenciosa, sin escribir nada adicional (TRUE, es lo que queremos).\n\nCuando ejecutamos este script, vemos:\n\n\n\n\n\n\n\nCorrer el script saludo.R desde la terminal.\n\n\nPasamos a otro ejemplo. El siguiente script le pide a la persona que lo esté usando que indique cualquier número y luego le comunica si es par o impar:\n\ncat(\"==========================================\\n\")\ncat(\"           PARIDAD DE UN NÚMERO           \\n\")\ncat(\"==========================================\\n\\n\")\ncat(\"Ingrese un número entero y presione enter:\\n\")\nn &lt;- scan(file = \"stdin\", n = 1, quiet = TRUE)\nif (n %% 2 == 0) {\n  cat(n, \"es par\\n\")\n} else {\n  cat(n, \"es impar\\n\")\n}\n\nEsto es lo que ocurre en la terminal:\n\n\n\n\n\n\n\nCorrer el script paridad.R desde la terminal.\n\n\nAhora recordemos el ejercicio de la práctica 2 en el que escribimos un programa para calcular salarios, en función del día de la semana, el turno y las horas trabajadas. Podemos adaptarlo para esta información de la que depende el cálculo final se tome desde la terminal:\n\n# PROGRAMA: \"Determinar salario\"\n\n# Valores fijados\nvalor_hora &lt;- 4000\nvalor_adicional_noche &lt;- 2000\nvalor_adicional_domingo &lt;- 1000\n\n# Pedir valores para calcular el salario\ncat(\"Ingrese la cantidad de horas trabajadas:\\n\")\nhoras &lt;- scan(\"stdin\", n = 1, quiet = TRUE)\ncat(\"\\nIngrese el día de la semana (DOM LUN MAR MIE JUE VIE SAB):\\n\")\ndia &lt;- scan(\"stdin\", what = \"\", n = 1, quiet = TRUE)\ncat(\"\\nIngrese el turno (M T N):\\n\")\nturno &lt;- scan(\"stdin\", what = \"\", n = 1, quiet = TRUE)\n\n# Cálculo para el pago de ese día a ese empleado\nsalario &lt;- horas * valor_hora\nif (turno == \"N\") {\n  salario &lt;- salario + horas * valor_adicional_noche\n}\nif (turno == \"DOM\") {\n  salario &lt;- salario + horas * valor_adicional_domingo\n}\ncat(\"\\nEl salario que se debe abonar es $\", salario, \"\\n\", sep = \"\")\n\nEjecutamos el script salario.R:\n\n\n\n\n\n\n\nCorrer el script salario.R desde la terminal.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ejecución de *scripts* de R desde la terminal</span>"
    ]
  },
  {
    "objectID": "capitulos/04_3_opcional.html",
    "href": "capitulos/04_3_opcional.html",
    "title": "21  Uso de argumentos en la línea de comandos al ejecutar código de R",
    "section": "",
    "text": "En este capítulo de lectura opcional exploraremos ejemplos más avanzados de interacción entre R y la terminal, centrándonos en el uso de argumentos que se pasan al ejecutar scripts con Rscript. Aprenderemos cómo capturar y procesar estos argumentos con la función commandArgs(), cómo validar su cantidad y contenido, y cómo convertirlos a otros tipos de datos cuando sea necesario. También veremos ejemplos prácticos y mencionaremos herramientas adicionales que permiten gestionar opciones de manera más sofisticada.\n\nEn ejemplos anteriores hemos visto cómo capturar distintas piezas de información de forma interactiva mediante la función scan() mientras estamos ejecutando un programa de R desde la terminal. En otras ocasiones, en lugar de pausar la ejecución del programa a la espera de que el usuario ingrese algún valor, es conveniente especificar algunas opciones directamente en la línea de comando, al lado instrucción Rscript que ejecuta el código.\nPor ejemplo, imaginemos que tenemos un programa llamado resumen.R que se encarga de hacer un análisis descriptivo de un conjunto de datos, guardados en algún archivo cuyo nombre debe especificar el usuario para que el programa lo lea. Supongamos también que el nombre del archivo de datos es mayo.txt. El usuario puede mandar a correr el programa que hace el análisis sobre este archivo de datos indicando su nombre como un argumento adicional de esta forma:\nRscript resumen.R mayo.txt\nAhora pensemos que este mismo tipo de análisis se repite todos los meses con datos nuevos. En lugar de modificar nuestro script resumen.R para que lea un archivo con otro nombre, ejecutamos lo anterior con el nombre del archivo que corresponda y listo:\nRscript resumen.R junio.txt\nRscript resumen.R julio.txt\nRscript resumen.R agosto.txt\nPara que esto funcione, el programa que está guardado en resumen.R debe ser capaz de capturar el nombre del archivo que tiene leer y que el usuario se lo está pasando como un argumento adicional en la instrucción Rscript.\nLa función que se encarga de capturar los argumentos adicionales que enviamos desde la terminal es commandArgs(). Toma todos los elementos que escribamos al final de la línea de Rscript y los reúne en un vector atómico de tipo carácter.\n\nEn la Unidad 1 mencionamos que los vectores atómicos pueden contener más de un valor, pero hasta acá no los usamos de esa forma. Lo veremos recién en la próxima unidad. Los ejemplos que siguen hacen uso de vectores con varios elementos, que se corresponden con todos los argumentos que un usuario envía desde la terminal. Por esta razón, es recomendable que sigas leyendo si ya sabés usar vectores con más de un elemento, o que vuelvas a ver estos ejemplos más adelante, después de que hayas estudiado la unidad 5.\nLos scripts utilizados en los ejemplos pueden ser descargados desde este archivo comprimido.\n\nEn primer lugar vamos a analizar al script ejemplo1.R, con el siguiente contenido:\n\n# Capturar los argumentos pasados desde la terminal en un vector\nargs &lt;- commandArgs(trailingOnly = TRUE)\n\n# Contar cuántos argumentos nos pasaron\ncat(\"Nos pasaron\", length(args), \"argumentos.\\n\\n\")\n\n# Mostrar los argumentos que nos pasaron\ncat(\"Los argumentos que nos pasaron son:\\n\")\ncat(args, \"\\n\")\n\n# Aunque los argumentos sean números, son tomados como carácter\ncat(\"\\nLos argumentos se toman como valores de tipo:\\n\")\ntypeof(args)\n\nVamos a ejecutarlo desde la terminal con los argumentos “hola”, “chau” y “4”. Obtenemos:\n\nRscript ejemplo1.R hola chau 4\n\n\n\nNos pasaron 3 argumentos.\n\nLos argumentos que nos pasaron son:\nhola chau 4 \n\nLos argumentos se toman como valores de tipo:\n[1] \"character\"\n\n\nSi lo ejecutamos sin argumentos:\n\nRscript ejemplo1.R\n\n\n\nNos pasaron 0 argumentos.\n\nLos argumentos que nos pasaron son:\n \n\nLos argumentos se toman como valores de tipo:\n[1] \"character\"\n\n\nAhora vamos a suponer que el programa ejemplo2.R tiene como objetivo contar un chiste o decir un refrán, según lo que se le pida en el único argumento que se le pasa al correrlo desde la terminal. Si el argumento es igual a “chiste”, se cuenta el chiste; si es igual a “refran” se cuenta el refrán; y en otro caso no se hace nada. El contenido del archivo es:\n\n# Capturar los argumentos pasados desde la terminal en un vector\nargs &lt;- commandArgs(trailingOnly = TRUE)\n\nif (args[1] == \"chiste\") {\n  cat(\"- Juan, cómo has cambiado.\\n- Yo no soy Juan.\\n- Más a mi favor.\\n\\n\")\n} else if (args[1] == \"refran\") {\n  cat(\"No por mucho madrugar amanece más temprano.\\n\\n\")\n} else {\n  # Genero un error para que el programa se detenga, avisando lo que pasa\n  stop(\"El argumento provisto debe ser igual a chiste o refran.\\n\")\n}\n\nEjecutamos este archivo pasando distintos valores para su argumento:\n\nRscript ejemplo2.R refran\n\n\n\nNo por mucho madrugar amanece más temprano.\n\n\n\nRscript ejemplo2.R chiste\n\n\n\n- Juan, cómo has cambiado.\n- Yo no soy Juan.\n- Más a mi favor.\n\n\n\nRscript ejemplo2.R hola\n\n\n\nError: El argumento provisto debe ser igual a chiste o refran.\nExecution halted\n\n\nPodemos controlar la cantidad de argumentos admitidos generando errores en el código para aquellas situaciones donde el usuario envíe menos o más que la cantidad deseada. Por ejemplo, en el caso anterior, es obligatorio enviar uno y sólo un argumento. Modificamos el script para que lo tenga en cuenta, dando lugar al programa ejemplo3.R:\n\n# Capturar los argumentos pasados desde la terminal en un vector\nargs &lt;- commandArgs(trailingOnly = TRUE)\n\n# Controlar la cantidad de argumentos\nif (length(args) == 0 || length(args) &gt; 1) {\n  stop(\"Debe proveer exactamente un argumento, que debe ser igual a chiste o refran.\\n\")\n}\n\nif (args[1] == \"chiste\") {\n  cat(\"- Juan, cómo has cambiado.\\n- Yo no soy Juan.\\n- Más a mi favor.\\n\\n\")\n} else if (args[1] == \"refran\") {\n  cat(\"No por mucho madrugar amanece más temprano.\\n\\n\")\n} else {\n  # Genero un error para que el programa se detenga, avisando lo que pasa\n  stop(\"El argumento provisto debe ser igual a chiste o refran.\\n\")\n}\n\nVeamos lo que pasa si cumplimos o no con la cantidad exacta de argumentos que hay que pasarle al código de R:\n\nRscript ejemplo3.R\n\n\n\nError: Debe proveer exactamente un argumento, que debe ser igual a chiste o refran.\nExecution halted\n\n\n\nRscript ejemplo3.R chiste refran\n\n\n\nError: Debe proveer exactamente un argumento, que debe ser igual a chiste o refran.\nExecution halted\n\n\n\nRscript ejemplo3.R chiste\n\n\n\n- Juan, cómo has cambiado.\n- Yo no soy Juan.\n- Más a mi favor.\n\n\nImaginemos por último que es obligatorio pasar un primer argumento (“chiste” o “refran”) y que opcionalmente se puede pasar un segundo argumento, que se va a tratar de un número para indicar cuántas veces queremos que el chiste o el refrán se repita. Como todos los argumentos se pasan como datos de tipo carácter, para poder usar el número tendremos que convertirlo a dato de tipo numérico. Añadimos esta característica en el script ejemplo4.R:\n\n# Capturar los argumentos pasados desde la terminal en un vector\nargs &lt;- commandArgs(trailingOnly = TRUE)\n\n# Si no proveyó argumentos, generar un error y que se detenga el programa\nif (length(args) == 0) {\n  stop(\"Debe proveer al menos un argumento (chiste o refran).\")\n}\n\n# Si proveyó más de 2 argumentos, generar un error y que se detenga el programa\nif (length(args) &gt; 2) {\n  stop(\"No debe proveer más de 2 argumentos. El primero es obligatorio (chiste o refran) y el segundo es opcional (un número que indica la cantidad de veces a repetir el chiste o el refrán).\")\n}\n\n# Si no hay segundo argumento, args[2] es NA\nif (is.na(args[2])) {\n  n &lt;- 1\n} else {\n  n &lt;- as.numeric(args[2])\n}\n\n# Repetir n veces\nfor (i in 1:n) {\n  if (args[1] == \"chiste\") {\n    cat(\"- Juan, cómo has cambiado.\\n- Yo no soy Juan.\\n- Más a mi favor.\\n\\n\")\n  } else if (args[1] == \"refran\") {\n    cat(\"No por mucho madrugar amanece más temprano.\\n\\n\")\n  } else {\n    # Genero un error para que el programa se detenga, avisando lo que pasa\n    stop(\"El argumento provisto debe ser igual a chiste o refran.\\n\")\n  }\n}\n\nVeamos ahora cómo funciona:\n\nRscript ejemplo4.R refran 5\n\n\n\nNo por mucho madrugar amanece más temprano.\n\nNo por mucho madrugar amanece más temprano.\n\nNo por mucho madrugar amanece más temprano.\n\nNo por mucho madrugar amanece más temprano.\n\nNo por mucho madrugar amanece más temprano.\n\n\n\nRscript ejemplo4.R chiste 3\n\n\n\n- Juan, cómo has cambiado.\n- Yo no soy Juan.\n- Más a mi favor.\n\n- Juan, cómo has cambiado.\n- Yo no soy Juan.\n- Más a mi favor.\n\n- Juan, cómo has cambiado.\n- Yo no soy Juan.\n- Más a mi favor.\n\n\n\nRscript ejemplo4.R refran\n\n\n\nNo por mucho madrugar amanece más temprano.\n\n\n\nRscript ejemplo4.R\n\n\n\nError: Debe proveer al menos un argumento (chiste o refran).\nExecution halted\n\n\nAdemás de la función commandArgs() existen paquetes de R para poder trabajar con argumentos y opciones de formas mucho más elaboradas, como los paquetes argparse y optparse, entre otros.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Uso de argumentos en la línea de comandos al ejecutar código de R</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html",
    "href": "capitulos/04_practica.html",
    "title": "Práctica de la Unidad 4",
    "section": "",
    "text": "Ejercicio 1\nEl equipo de administración de usuarios de un sistema de ventas debe organizar los datos de los usuarios registrados y temporales. Para hacerlo, se necesita realizar las siguientes acciones desde la terminal:",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html#ejercicio-1",
    "href": "capitulos/04_practica.html#ejercicio-1",
    "title": "Práctica de la Unidad 4",
    "section": "",
    "text": "Crear una carpeta principal llamada organizacion_usuarios.\nDentro de ella, crear tres subcarpetas: registrados, temporales_abril e historial.\nAgregar información ficticia de al menos tres usuarios registrados y tres usuarios temporales. Cada usuario debe tener un archivo propio, cuyo nombre debe ser un código alfanumérico de 8 caracteres que finalice con _T para los usuarios temporales y _R para los usuarios registrados (por ejemplo: ABC1234X_R.txt). Se puede inventar cualquier código. El contenido de los archivos debe ser:\n\nUsuarios registrados: dirección IP, nombre de usuario y correo electrónico.\nUsuarios temporales: dirección IP y nombre de invitado (ejemplo: “invitado01”)\n\nAsegurarse de que cada archivo esté guardado en la carpeta correspondiente.\nUno de los usuarios temporales se ha registrado oficialmente en el sistema. Se deben seguir los siguientes pasos para actualizar la información:\n\nCopiar el archivo de ese usuario desde temporales_abril a la carpeta registrados.\nEditar el archivo del usuario para agregar el nombre de usuario y el correo electrónico correspondiente.\nRenombrar el archivo para que su nombre termine en _R en lugar de _T.\nMostrar el contenido del archivo actualizado por pantalla para asegurarse que la información fue correctamente registrada.\nFinalmente, eliminar el archivo original de la carpeta temporales_abril.\n\nAdemás, se debe considerar que los archivos temporales se borran mensualmente, pero se guarda un respaldo en la carpeta historial. Para lograr esto:\n\nCopiar a la carpeta historial historial cada uno de los archivos de la carpeta temporales_abril.\nBorrar la carpeta temporales_abril y crear el directorio para el próximo mes, temporales_mayo.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html#ejercicio-2",
    "href": "capitulos/04_practica.html#ejercicio-2",
    "title": "Práctica de la Unidad 4",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nCrear un script en R llamado menu.R que muestre un menú de opciones en la terminal, lea la opción elegida por el usuario y ejecute una acción diferente según la opción seleccionada. El menú debe contener al menos tres opciones: “1. Saludar”, “2. Mostrar fecha” y “3. Salir”. El programa debe:\n\nMostrar el menú al usuario.\nLeer la opción ingresada.\nResponder con una acción distinta para cada opción:\n\nSi elige “1”, pedirle al usuario que ingrese su nombre, mostrar un saludo personalizado (por ejemplo: “¡Hola, Pepito!”) y mostrar otra vez el menú principal.\nSi elige “2”, mostrar la hora actual (para obtenerla se puede usar el comando de R format(Sys.time(), \"%H:%M:%S\")) y mostrar otra vez el menú principal.\nSi elige “3”, pedirle al usuario que ingrese su nombre, mostrar un saludo personalizado, por ejemplo: “¡Chau, Pepito!” y finalmente finalizar su ejecución.\n\n\nSi el usuario ingresa una opción no válida, se debe mostrar un mensaje como “Opción inválida” y solicitar nuevamente que ingrese su elección.\nRscript menu.R\n\n=== MENÚ PRINCIPAL ===\n\n1. Saludar\n2. Mostrar hora actual\n3. Salir\n\nElegí una opción: 2\n\nLa hora actual es: 11:44:30 \n\n=== MENÚ PRINCIPAL ===\n\n1. Saludar\n2. Mostrar hora actual\n3. Salir\n\nElegí una opción: 3\n\nIngresá tu nombre para despedirte: Eugenia\n¡Chau, Eugenia!",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html#ejercicio-3",
    "href": "capitulos/04_practica.html#ejercicio-3",
    "title": "Práctica de la Unidad 4",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nSe desea desarrollar un programa que calcule la calificación promedio otorgada a una película por un grupo de jueces de cine. En primer lugar, el programa debe preguntar cuántos jueces integran el grupo, que debe tener un mínimo de 3 y un máximo de 6. Si el número ingresado no cumple con esta condición, el programa debe mostrar un mensaje adecuado y no continuar con el resto de las instrucciones.\nSi el número de jueces está dentro del intervalo aceptado, el programa debe:\n\nSolicitar al usuario que ingrese el nombre de la película.\nSolicitar las calificaciones otorgadas por cada uno de los jueces. Las calificaciones deben ser ingresadas una por una y se debe chequear que cada una esté dentro del rango válido de 0 a 10. En caso contrario, debe mostrar un mensaje de error y solicitar nuevamente esa calificación.\nCalcular el promedio de los puntajes ingresados.\nMostrar el nombre de la película y su puntaje promedio.\n\nEjemplo del uso del script\nRscript evaluar_pelicula.R\n\n===============================================\n\n      SISTEMA DE EVALUACIÓN DE PELÍCULAS\n\n===============================================\n\nIngrese la cantidad de jueces en el grupo:\n3\n\nIngrese el nombre de la película:\nShrek 1\n\nIngrese la calificación del juez 1:\n8.7\n\nIngrese la calificación del juez 2:\n9\n\nIngrese la calificación del juez 3:\n9.2\n\nLa clasificación promedio para la película &lt;Shrek&gt; es 8.97 puntos.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html#ejercicio-4",
    "href": "capitulos/04_practica.html#ejercicio-4",
    "title": "Práctica de la Unidad 4",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nEn el campus virtual de una universidad, los usuarios pueden acceder a diferentes salas, cada una correspondiente a una materia específica (por ejemplo, Programación 1, Laboratorio de Datos 1, Estadística 1). Cada sala está protegida por una contraseña única. Para acceder, el usuario debe ingresar la contraseña correcta. En caso de error, debe intentarlo nuevamente hasta lograrlo o hasta que se alcance un límite máximo de intentos, tras lo cual la cuenta será bloqueada.\nPara el caso de la sala de Programación 1, la contraseña es “amoprogramar”. Vamos a suponer que un usuario quiere ingresar a esta sala. Escribir un programa que:\n\nMuestre un mensaje solicitando el ingreso de la contraseña.\nLea el valor ingresado por el usuario.\nInicie un proceso de verificación:\n\nSi la contraseña ingresada es incorrecta, debe mostrar:\n\"Contraseña incorrecta. Ingrésela nuevamente.\"\ny permitir un nuevo intento.\nSi la contraseña es correcta, debe mostrar:\n\"¡Contraseña correcta! Puede continuar con sus estudios.\"\n\n\nA partir de este escenario, se deben proponer dos versiones del programa, considerando los siguientes casos:\n\nEl usuario puede intentar indefinidamente hasta ingresar la contraseña correcta.\nEl usuario tiene un máximo de cinco intentos. Por cada intento fallido, el mensaje emitido debe indicar la cantidad de intentos restantes. Si no ingresa la contraseña correcta en ese número de intentos, se debe mostrar el mensaje:\n\"Demasiados intentos fallidos. Su cuenta ha sido bloqueada.\"",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html#ejercicio-5",
    "href": "capitulos/04_practica.html#ejercicio-5",
    "title": "Práctica de la Unidad 4",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nEn el ejercicio 7 de la practica 3 se tuvo que crear una función llamada resolvente(a, b, c), que muestra las soluciones de la ecuación de segundo grado \\(a x^2 + b x + c = 0\\), empleando la fórmula resolvente:\n\\[x_{1, 2} = \\frac{-b \\pm \\sqrt{(b^2 - 4ac)}}{2a}\\] Modificar el código e incluirlo en un script que pueda ser ejecutado desde la terminal de manera que se cumplan los siguientes requisitos:\n\nPedir al usuario que ingrese los coeficientes a, b y c uno por uno.\nSi el coeficiente a es cero, mostrar un mensaje de error y finalice el programa.\nMostrar la ecuación ingresada en formato legible (ejemplo: x² - 5x + 6 = 0).\nCalcular el discriminante (D = b^2 - 4 * a * c) y mostrar su valor.\nClasificar las soluciones de acuerdo al resultado de D:\n\nSi D &gt; 0: mostrar las dos soluciones reales distintas con un mensaje descriptivo como: “Existen dos soluciones reales distintas: x₁ = 2, x₂ = 3”.\nSi D = 0: mostrar la única solución real (doble) con un mensaje descriptivo como “Existe una única solución real: x = 2 (raiz doble)”.\nSi D &lt; 0: indicar que las soluciones son complejas (sin calcularlas).\n\nMejorar la experiencia del usuario incluyendo:\n\nMensaje de bienvenida y despedida.\nNúmeros que se muestren redondeados para facilitar su lectura.\n\n\nEl uso de la función debe ser semejante al siguiente ejemplo:\nRscript resolvente.R\n\n========================================\n  Calculadora de ecuaciones cuadráticas\n========================================\n\nIngrese el valor del coeficiente 'a':\n1\nIngrese el valor del coeficiente 'b':\n-1\nIngrese el valor del coeficiente 'c':\n2\n\nEcuación ingresada:  1x²-1x+2=0 \nDiscriminante (D): -7 \nLas soluciones son complejas (no reales).\n\nGracias por usar la calculadora de ecuaciones cuadráticas.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_practica.html#ejercicio-6-opcional",
    "href": "capitulos/04_practica.html#ejercicio-6-opcional",
    "title": "Práctica de la Unidad 4",
    "section": "Ejercicio 6 (opcional)",
    "text": "Ejercicio 6 (opcional)\nReescribir el programa anterior de forma que, en lugar de solicitar al usuario que ingrese los valores de a, b y c uno por uno desde la terminal, estos se ingresen directamente como argumentos del sistema al momento de ejecutar el script. Para ello, utilizar commandArgs(trailingOnly = TRUE) para capturar los valores y adaptar el código en consecuencia. Asegurarse de incluir validaciones adecuadas para verificar que los argumentos sean numéricos y que a no sea igual a cero.\nEjemplo de ejecución desde la terminal:\n\nRscript resolvente_args.R 1 -1 -2\n\n\n\n=========================================\n  Calculadora de ecuaciones cuadráticas\n=========================================\n\nEcuación ingresada:  1x²-1x-2=0 \nDiscriminante (D): 9 \nExisten dos soluciones reales distintas:\nx₁ = -1 , x₂ = 2 \n\nGracias por usar la calculadora de ecuaciones cuadráticas.\n\n\n\nRscript resolvente_args.R 1 2 1\n\n\n\n=========================================\n  Calculadora de ecuaciones cuadráticas\n=========================================\n\nEcuación ingresada:  1x²+2x+1=0 \nDiscriminante (D): 0 \nExiste una única solución real (raíz doble):\nx = -1 \n\nGracias por usar la calculadora de ecuaciones cuadráticas.\n\n\n\nRscript resolvente_args.R 1 1 1\n\n\n\n=========================================\n  Calculadora de ecuaciones cuadráticas\n=========================================\n\nEcuación ingresada:  1x²+1x+1=0 \nDiscriminante (D): -3 \nLas soluciones son complejas (no reales).\n\nGracias por usar la calculadora de ecuaciones cuadráticas.\n\n\n\nRscript resolvente_args.R 0 1 1\n\n\n\n=========================================\n  Calculadora de ecuaciones cuadráticas\n=========================================\nError: Error: el coeficiente 'a' debe ser distinto de cero. Fin del programa.\nExecution halted\n\n\n\nRscript resolvente_args.R 2 hola 1\n\n\n\n=========================================\n  Calculadora de ecuaciones cuadráticas\n=========================================\nWarning message:\nNAs introduced by coercion \nError: Los argumentos ingresados no son valores numéricos.\nExecution halted",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/04_actividad_autoevaluativa.html",
    "href": "capitulos/04_actividad_autoevaluativa.html",
    "title": "Actividad de autoevaluación 4",
    "section": "",
    "text": "El contenido estará disponible a la brevedad.",
    "crumbs": [
      "Unidad 4. Uso de la terminal",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Actividad de autoevaluación 4</span>"
    ]
  },
  {
    "objectID": "capitulos/05.html",
    "href": "capitulos/05.html",
    "title": "Unidad 5. Estructuras de datos",
    "section": "",
    "text": "Una parte fundamental de la programación consiste en organizar y manipular conjuntos de datos. En esta unidad vamos a introducir las principales estructuras que R utiliza para almacenar y procesar datos, comenzando con aquellas más simples y homogéneas, como los vectores y las matrices, hasta llegar a otras más complejas y heterogéneas. Primero trabajaremos con estas estructuras mediante operaciones explícitas, elemento por elemento, para consolidar la lógica que subyace a su uso. Más adelante, exploraremos las operaciones vectorizadas que R ofrece, las cuales permiten escribir programas más eficientes, legibles y compactos.",
    "crumbs": [
      "Unidad 5. Estructuras de datos"
    ]
  },
  {
    "objectID": "capitulos/05_1_arreglos.html",
    "href": "capitulos/05_1_arreglos.html",
    "title": "24  Arreglos",
    "section": "",
    "text": "24.1 Vectores\nHasta ahora todos los programas que hemos desarrollado hacen uso de objetos que guardan datos individuales, los cuales representan un número, una cadena de texto o un valor lógico. Sin embargo, la verdadera utilidad de la computación radica en poder trabajar con muchos datos a la vez, organizados de acuerdo a ciertas reglas que permitan su manipulación y acceso.\nHay muchos tipos de estructuras de datos y cada lenguaje de programación propone los suyos propios. Sin embargo, las estructuras más sencillas se conocen como arreglos y de una u otra forma están presentes en todos los lenguajes, permitiendo generalizar su definición.\nLos arreglos son muy útiles para almacenar información en la memoria de la computadora, organizando valores que estén relacionados entre sí de alguna manera, por ejemplo, un conjunto de precios, los meses del año, el listado de calificaciones de estudiantes en distintos parciales, etc.\nPara indicar qué posición ocupa cada elemento en el arreglo se emplean uno o más índices. Dependiendo de cuántos índices se deban utilizar para acceder a cada elemento dentro de los arreglos, estos se clasifican en unidimensionales (vectores), bidimensionales (matrices) o multidimensionales.\nLa homogeneidad de los arreglos no solo simplifica las operaciones sobre los elementos, sino que también permite al lenguaje de programación realizar una gestión más eficiente de la memoria. En los arreglos clásicos, los elementos se almacenan en posiciones contiguas de memoria, lo que posibilita un acceso rápido a cualquier valor. Esta propiedad se mantiene en muchos lenguajes, incluyendo R.\nUn vector es la estructura de datos más simple y fundamental en R. Se trata de un arreglo unidimensional que, como tal, sólo posee elementos del mismo tipo: todos numéricos, todos de texto, todos lógicos, etc. Por ejemplo, el siguiente es un vector de tipo numérico llamado x con 5 elementos:\nEn R, los vectores se construyen con la función c() (de combine), que reúne una serie de valores en una única estructura. Para guardar un vector en nuestro ambiente global, necesitamos elegir un nombre y utilizar el operador de asignación &lt;-:\nx &lt;- c(-4.5, 12, 2.71, -6, 25)\nCuando ejecutamos la línea anterior, se crea en el ambiente global el objeto x, como podemos notar en la pestaña Environment de RStudio. Es decir, los arreglos son objetos que constituyen entidades en sí mismas y que pueden ser manipulados al hacer referencia a sus nombres. Además, RStudio nos muestra en la pestaña mencionada qué tipo de vector es cada uno (en este caso dice num), cuántos elementos tiene (pone [1:5]) y una previsualización de sus primeros elementos. También podemos chequear el tipo de vector y la cantidad de elementos que tiene en la consola:\ntypeof(x)\n\n[1] \"double\"\n\nlength(x)\n\n[1] 5\nCada uno de los elementos ocupa una posición determinada en el vector. Por ejemplo, el elemento 3 del vector x es el numéro 2.71. Se puede acceder o hacer referencia (indexar) a cada elemento mediante el uso de un índice, expresado con un número entero entre corchetes al lado del nombre del vector. De esta forma, si escribimos x[3] hacemos referencia a la tercera posición del vector, que actualmente guarda al valor 2.71. Como podemos ver, sólo hace falta un índice para hacer referencia a cada elemento de un vector.\nx[1]\n\n[1] -4.5\n\nx[3]\n\n[1] 2.71\n\nx[2] + x[5]\n\n[1] 37\n\nx[4] * 2\n\n[1] -12\nEn R, este tipo de estructura se denomina técnicamente vector atómico o atomic vector, concepto que ya presentamos en la Unidad 1. En aquella oportunidad, dijimos que este es el nombre que R le da al tipo de objeto más simple y básico; que hay seis tipos de vectores atómicos según los datos que guardan (doubles, characters, logicals, etc.); y que por el momento trabajaríamos con vectores atómicos que sólo contenían un valor almacenado. Ahora ha llegado el momento de sacarle más provecho a estas estructuras de datos, sabiendo que pueden guardar uno o más valores. Como ya sabemos, cuando definimos una variable que sólo guarda un valor, también estamos creando un vector atómico, con la particularidad de que su largo es igual a 1 y, por lo tanto, el uso del índice [1] se puede omitir:\n# Defino una variable numérica: es un objeto simple, llamado \"vector atómico\"\nprecio &lt;- 100\nis.vector(precio)\n\n[1] TRUE\n\n# Es un vector de tipo double\ntypeof(precio)\n\n[1] \"double\"\n\n# Es un vector de largo 1, tien un solo dato\nlength(precio)\n\n[1] 1\n\n# Por comodidad, no usamos un índice para operar con el único valor almacenado\nprecio * 1.10\n\n[1] 110\n\n# Pero podríamos hacerlo y sería lo mismo\nprecio[1] * 1.10\n\n[1] 110\nDesde ahora usaremos vectores atómicos para guardar cualquier cantidad de elementos. Veamos ejemplos de vectores atómicos de tipo carácter y lógico, con distintos largos:\nLos definimos en R:\ny &lt;- c(\"ARG\", \"correo@gmail.com\", \"Ok\", \"chau\")\nz &lt;- c(TRUE, TRUE, FALSE)\nInspeccionamos su tipo y contenido, y vemos que podemos hacer algunas operaciones con ellos:\ntypeof(y)\n\n[1] \"character\"\n\nlength(y)\n\n[1] 4\n\nnchar(y[2])\n\n[1] 16\n\ntypeof(z)\n\n[1] \"logical\"\n\nlength(z)\n\n[1] 3\n\nz[1] && z[2]\n\n[1] TRUE\nPodemos emplear estructuras iterativas para recorrer todas las posiciones de un vector y realizar operaciones con ellas, por ejemplo:\nsuma &lt;- 0\nfor (i in 1:5) {\n  cat(\"La posición\", i, \"de x está ocupada por el valor\", x[i], \"\\n\")\n  cat(x[i], \"al cuadrado es igual a\", x[i]^2, \"\\n\")\n  suma &lt;- suma + x[i]\n}\ncat(\"La suma de los elementos del vector x es igual a\", suma)\n\nLa posición 1 de x está ocupada por el valor -4.5 \n-4.5 al cuadrado es igual a 20.25 \nLa posición 2 de x está ocupada por el valor 12 \n12 al cuadrado es igual a 144 \nLa posición 3 de x está ocupada por el valor 2.71 \n2.71 al cuadrado es igual a 7.3441 \nLa posición 4 de x está ocupada por el valor -6 \n-6 al cuadrado es igual a 36 \nLa posición 5 de x está ocupada por el valor 25 \n25 al cuadrado es igual a 625 \nLa suma de los elementos del vector x es igual a 29.21\nAntes comentamos que en R los vectores se crean con expresiones como x &lt;- c(-4.5, 12, 2.71, -6, 25), donde sus elementos están listados de forma literal. También podemos crear vectores de un largo determinado dejando que cada posición quede ocupada por algún valor asignado por defecto. Por ejemplo, el siguiente código crea un vector de tipo numérico con 10 posiciones, uno carácter con 7 y otro lógico con 2. En cada caso, R rellena todas las posiciones con el mismo valor: ceros, caracteres vacíos \"\" y valores FALSE, respectivamente:\na &lt;- numeric(10)\nb &lt;- character(7)\nd &lt;- logical(2)\n\na\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\nb\n\n[1] \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n\nd\n\n[1] FALSE FALSE",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Arreglos</span>"
    ]
  },
  {
    "objectID": "capitulos/05_1_arreglos.html#vectores",
    "href": "capitulos/05_1_arreglos.html#vectores",
    "title": "24  Arreglos",
    "section": "",
    "text": "Ejemplo de un vector numérico.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjemplo de un vector numérico: se necesita de un solo índice para señalar cada posición.\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjemplo de un vector carácter y un vector lógico.\n\n\n\n\n\n\n\n\n\n\n\nCreación de vectores en R.\n\n\n\n\n\n\n\nEn el ejemplo anterior, se estableció que i itere entre 1 y 5 (i in 1:5) para recorrer desde el primer al último elemento de x. Es mucho mejor establecer el recorrido de la variable de iteración en función del largo de x, para que el código sirva sea cual sea la cantidad de elementos en este vector:\n\nsuma &lt;- 0\nfor (i in 1:length(x)) {\n  cat(\"La posición\", i, \"de x está ocupada por el valor\", x[i], \"\\n\")\n  cat(x[i], \"al cuadrado es igual a\", x[i]^2, \"\\n\")\n  suma &lt;- suma + x[i]\n}\ncat(\"La suma de los elementos del vector x es igual a\", suma)\n\n\n\nEn relación al comentario anterior, hay otra recomendación para tener en cuenta: las buenas prácticas recomiendan reemplazar 1:length(x) por seq_along(x). Ambas formas producen el mismo resultado, un vector de valores entre 1 y la cantidad de elementos de x, pero la segunda es más segura, porque puede prevenir de cometer errores, especialmente cuando existe la posibilidad de que x sea un vector vacío.\nSupongamos que x &lt;- c(), es decir, un vector vacío. Si calculamos length(x), da 0. Entonces, 1:length(x) se convierte en 1:0, que es una secuencia numérica descendente: 1, 0 y el bucle for (i in 1:length(x)) se ejecuta con valores 1 y 0, que no son índices válidos para x. Esto puede llevar a errores sutiles o comportamientos inesperados, como:\n\n# Vector vacío\nx &lt;- c()\n# Largo del vector\nlength(x)\n\n[1] 0\n\n# Valores para i\n1:length(x)\n\n[1] 1 0\n\n# Comportamiento no deseado: se ejecuta e imprime NULL\nfor (i in 1:length(x)) {\n  print(x[i])\n}\n\nNULL\nNULL\n\n\nEn cambio, seq_along(x) da una secuencia vacía si x está vacío, y el bucle no se ejecuta, que es el comportamiento esperado:\n\n# Vector vacío\nx &lt;- c()\n# Largo del vector\nlength(x)\n\n[1] 0\n\n# Valores para i: ninguno\nseq_along(x)\n\ninteger(0)\n\n# Comportamiento deseado: no se ejecuta\nfor (i in seq_along(x)) {\n  print(x[i])\n}\n\nseq_along(x) comunica de manera clara que vamos a recorrer los índices válidos de x. Es una función pensada específicamente para este uso. Asegura que el código se comporte correctamente tanto si x tiene muchos elementos, como si tiene uno solo o está vacío.\n\n\n\n\nSin ejecutar el código, determinar cuál será el contenido del vector a al finalizar:\n\na &lt;- numeric(10)\nfor (i in 1:length(a)) {\n    if (i %% 3 == 0) {\n        a[i] &lt;- i * 100\n    }\n}\na\n\n\n\nInvertir de lugar los elementos de un vector\nNos planteamos el problema de dar vuelta los elementos pertenecientes a un vector, de manera que el primer elemento pase a ser el último, el segundo pase al penúltimo lugar, etc. Por ejemplo, dado el vector de tipo carácter v:\n\n\n\n\n\n\n\nVector v.\n\n\nqueremos modificarlo para obtener:\n\n\n\n\n\n\n\nResultado buscado.\n\n\nSi bien podemos pensar en distintas formas para resolver este problema, probablemente la más sencilla requiere que intercambiemos de a dos los valores en ciertas posiciones del vector, empezando por intercambiar el primero con el último. Para esto podemos emplear una variable auxiliar que guarde el valor de alguna de las celdas temporalmente (por eso lo vamos a llamar tmp):\n\n\n\n\n\n\n\nPasos para intercambiar los valores entre la primera y última posición.\n\n\nAhora sólo resta realizar el mismo procedimiento para los valores de las posiciones 2 y 4. Como el número de elementos en el vector es impar, el valor en la posición central queda en su lugar. Podemos definir el siguiente programa para resolver este problema de manera general, para vectores de cualquier largo n:\n\nv &lt;- c(\"Datos\", \"de\", \"Análisis\", \"el\", \"Aguante\")\nn &lt;- length(v)\nfor (i in 1:(n %/% 2)) {\n    tmp &lt;- v[i]\n    v[i] &lt;- v[n - i + 1]\n    v[n - i + 1] &lt;- tmp\n}\nv\n\n[1] \"Aguante\"  \"el\"       \"Análisis\" \"de\"       \"Datos\"   \n\n\n\n\nEn R, la indexación de los elementos de un vector comienza en 1, lo que significa que el primer elemento se accede con x[1]. Este enfoque se conoce como indexación basada en uno o 1-indexed. Sin embargo, muchos otros lenguajes de programación populares (como C, C++, Java, Python y JavaScript) utilizan indexación basada en cero (0-indexed), donde el primer elemento se accede con x[0]. Este detalle es importante al aprender R, en especial si tenés experiencia en otros lenguajes. Confundir estos sistemas puede llevar a errores difíciles de detectar.",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Arreglos</span>"
    ]
  },
  {
    "objectID": "capitulos/05_1_arreglos.html#matrices",
    "href": "capitulos/05_1_arreglos.html#matrices",
    "title": "24  Arreglos",
    "section": "24.2 Matrices",
    "text": "24.2 Matrices\nUn arreglo bidimensional representa lo que habitualmente conocemos en matemática como matriz y por eso también lo llamamos de esa forma. Podemos imaginar que en una matriz los elementos están organizados en filas y columnas formando una tabla. Por ejemplo, la siguiente es una matriz llamada x:\n\n\n\n\n\n\n\nEjemplo de una matriz numérica.\n\n\nA diferencia de los vectores, las matrices requieren dos índices para señalar la posición de cada elemento, el primero para indicar la fila y el segundo para indicar la columna. Los mismos se colocan entre corchetes, separados por una coma, al lado del identificador de la matriz. De esta forma, si hablamos de x[1, 3] hacemos referencia a la posición ocupada por el valor 18, mientras que si mencionamos x[3, 1] nos referimos al valor 14.\n\n\n\n\n\n\n\nEjemplo de una matriz numérica: se usan dos índices para señalar cada posición.\n\n\nAl tamaño de una matriz, es decir, cuántas filas y columnas tiene, se le dice dimensión. La matriz anterior es de dimensión \\(3 \\times 4\\).\nPara crear una matriz en R, usamos la función matrix(). Su primer argumento, data, es un vector con todos los elementos que queremos guardar en la matriz. Luego, se indica la cantidad de filas para la misma con nrow o la cantidad de columnas con ncol:\n\nx &lt;- matrix(data = c(8, 11, 14, 13, 16, 19, 18, 21, 24, 23, 26, 29), nrow = 3)\nx\n\n     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29\n\n\nEl siguiente código es equivalente:\n\nx &lt;- matrix(data = c(8, 11, 14, 13, 16, 19, 18, 21, 24, 23, 26, 29), ncol = 4)\n\nNotar que R ubica a los valores provistos en el vector llenando primero la columna 1, luego la 2, etc. Ese comportamiento puede ser modificado con el argumento byrow, que por default es FALSE. Si lo cambiamos a TRUE los elementos son ubicados por fila. Además, podemos usar saltos de líneas en el código para imaginar mejor el aspecto final de la matriz. Esto no tiene ningún impacto en R, sólo sirve para que el código sea más fácil de leer. Las siguiente sentencia es equivalente a las anteriores:\n\nx &lt;- matrix(c(\n              8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29\n            ), \n            nrow = 3,\n            byrow = TRUE)\n\nSi colocamos un único valor como primer argumento en la función matrix(), el mismo se repetirá en todas las posiciones. En este caso sí o sí tenemos que indicar cuántas filas y columnas deseamos:\n\ny &lt;- matrix(0, nrow = 2, ncol = 5)\ny\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n\n\nTenemos las siguientes funciones para analizar el tamaño de las matrices:\n\ndim(x) # devuelve un vector con la cantidad de filas y columnas\n\n[1] 3 4\n\nnrow(x)\n\n[1] 3\n\nncol(x)\n\n[1] 4\n\n\nPodemos recorrer todas las posiciones de una matriz con una estructura iterativa doble: nos situamos en la primera fila y recorremos cada columna, luego en la segunda fila y recorremos todas las columnas y así sucesivamente:\n\nfor (i in 1:3) {\n  for (j in 1:4) {\n    ...hacer algo con x[i, j]...\n  }\n}\n\n\n\n\n\n\n\n\nRecorrer todas las posiciones de una matriz fila por fila.\n\n\nTambién se puede recorrer la matriz por columna, si modificamos ligeramente las estructuras iterativas:\n\nfor (j in 1:4) {\n  for (i in 1:3) {\n    ...hacer algo con x[i, j]...\n  }\n}\n\n\n\n\n\n\n\n\nRecorrer todas las posiciones de una matriz columna por columna.\n\n\nSe puede usar cualquier letra o palabra como variables iteradoras, pero el uso de i para las filas y de j para las columnas es bastante común.\nTambién podemos asignar valores en cada celda mientras recorremos la matriz. De hecho, la matriz x del ejemplo puede ser generada así, donde los índices i y j no sólo señalan una posición en particular dentro de la matriz, sino que además se usan para hacer el cálculo del valor a asignar:\n\nx &lt;- matrix(0, nrow = 3, ncol = 4)\nfor (i in 1:nrow(x)) {\n    for (j in 1:ncol(x)) {\n        x[i, j] &lt;- 3 * i + 5 * j\n    }\n}\nx\n\n     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29\n\n\n\nTrasponer una matriz\nEn Álgebra, una matriz traspuesta es una nueva matriz obtenida al intercambiar las filas por las columnas de una matriz original. En otras palabras, la primera fila de la matriz original se convierte en la primera columna de la matriz traspuesta, y así sucesivamente. Si la matriz original es de dimensión \\(m \\times n\\), su matriz transpuesta es de dimensión \\(n \\times m\\):\n\n\n\n\n\n\n\nLa matriz x y su traspuesta.\n\n\nPodemos escribir un programa para generar la matriz traspuesta, teniendo en cuenta que cada elemento que originalmente ocupa la posición [i, j] en la matriz original, debe pasar a ocupar la posición [j, i] en la matriz traspuesta:\nDado que en R vamos a asignar valores en la matriz de manera literal, primero la creamos y luego usamos nrow() y ncol() para obtener los correspondientes valores de nf y nc. En el siguiente ejemplo, además, todas las posiciones de la matriz traspuesta son iniciadas con el valor NA.\n\n# Matriz original\nx &lt;- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            nrow = 3, byrow = TRUE)\n\n# Cantidad de filas y columnas de la original\nnf &lt;- nrow(x)\nnc &lt;- ncol(x)\n\n# Definimos la traspuesta, inicialmente llena de valores NA\ntraspuesta &lt;- matrix(NA, nrow = nc, ncol = nf)\n\n# Generamos la matriz traspuesta\nfor (i in 1:nf) {\n    for (j in 1:nc) {\n        traspuesta[j, i] &lt;- x[i, j]\n    }\n}\n\ncat(\"Matriz original:\\n\")\nx\ncat(\"\\nMatriz traspuesta:\\n\")\ntraspuesta\n\nMatriz original:\n     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29\n\nMatriz traspuesta:\n     [,1] [,2] [,3]\n[1,]    8   11   14\n[2,]   13   16   19\n[3,]   18   21   24\n[4,]   23   26   29\n\n\n\n\nLas matrices no deben confundirse con otras estructuras como los data.frames de R. Un data.frame permite almacenar datos tabulares, es decir, organizados en filas y columnas, de forma similar a una hoja de cálculo o una tabla de base de datos. Aunque las matrices y los data.frames pueden parecer similares porque ambos organizan datos en filas y columnas, existe una diferencia fundamental entre ellos: en una matriz todos los elementos deben ser del mismo tipo (por ejemplo, todos numéricos), mientras que un data.frame puede contener columnas de distintos tipos (por ejemplo, números, texto y otras cosas a la vez). En esta asignatura no trabajaremos con data.frames, ya que no aprendemos sobre análisis o manejo de datos, pero sí lo harán en Laboratorio de Datos 1.",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Arreglos</span>"
    ]
  },
  {
    "objectID": "capitulos/05_1_arreglos.html#atributos",
    "href": "capitulos/05_1_arreglos.html#atributos",
    "title": "24  Arreglos",
    "section": "24.3 Atributos",
    "text": "24.3 Atributos\n\nEn R, un atributo o attribute es información adicional que se puede asociar a un objeto, como un vector atómico, sin modificar los valores que contiene. Es decir, los atributos actúan como metadatos: datos sobre los datos. Estos no cambian el contenido del objeto, no se muestran cuando lo imprimimos directamente, y no suelen influir en operaciones básicas. Sin embargo, algunas funciones de R pueden utilizar atributos específicos para tratar los objetos de una manera especial.\n\nPodemos averiguar si un objeto tiene atributos con la función attributes(). Si el objeto no tiene ninguno, la función devuelve NULL.\n\nv &lt;- c(10, -9, 9, 1, 7, 2)\nattributes(v)\n\nNULL\n\n\nEn este ejemplo, el vector atómico v de tipo numérico no tiene atributos asociados. Aunque un vector atómico común no tiene atributos por defecto, R construye muchas estructuras de datos más complejas, como matrices, otros arrays, factores, fechas, etc.) agregando atributos a vectores simples.\nA continuación, veremos algunos atributos fundamentales.\n\n24.3.1 names (nombres)\nUno de los atributos más comunes es el de los names. Se usa para asignar una etiqueta a cada elemento de un vector. Esto puede ayudar a interpretar los datos o acceder a elementos por nombre.\nPor ejemplo, en el vector cantidades vamos a anotar cuántas frutas (manzanas, naranjas, bananas y peras) tenemos que comprar:\n\ncantidades &lt;- c(3, 7, 2, 1)\ncantidades\n\n[1] 3 7 2 1\n\nnames(cantidades)\n\nNULL\n\n\nSeguramente es más cómodo si usamos el atributo names para anotar ponerle a cada valor un nombre que indique la fruta correspondiente:\n\nnames(cantidades) &lt;- c(\"manzanas\", \"naranjas\", \"bananas\", \"peras\")\ncantidades\n\nmanzanas naranjas  bananas    peras \n       3        7        2        1 \n\n\nEl contenido del vector no cambia, pero al imprimirlo ahora se muestran las etiquetas junto a los valores. Estas etiquetas no afectan a las operaciones que queramos hacer:\n\n# Mejor compro 4 manzanas más\ncantidades[1] &lt;- cantidades[1] + 4\ncantidades\n\nmanzanas naranjas  bananas    peras \n       7        7        2        1 \n\n\nAlgo muy interesante de tener nombres, es que los podemos usar para indexar:\n\ncantidades[3]\n\nbananas \n      2 \n\ncantidades[\"bananas\"]\n\nbananas \n      2 \n\n\nPodemos eliminar todas las etiquetas asignando NULL al atributo names():\n\nnames(cantidades) &lt;- NULL\ncantidades\n\n[1] 7 7 2 1\n\n\nTambién se pueden nombrar los elementos de un vector directamente cuando lo creamos:\n\ncantidades &lt;- c(manzanas = 3, naranjas = 7, bananas = 2, peras = 1)\ncantidades\n\nmanzanas naranjas  bananas    peras \n       3        7        2        1 \n\n\nEn el caso de las matrices, se le puede asignar nombres a sus filas y columnas. Esto se puede hacer después de crear la matriz\n\nx &lt;- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            nrow = 3, byrow = TRUE)\nrownames(x) &lt;- c(\"A\", \"B\", \"C\")\ncolnames(x) &lt;- c(\"grupo1\", \"grupo2\", \"grupo3\", \"grupo4\")\nx\n\n  grupo1 grupo2 grupo3 grupo4\nA      8     13     18     23\nB     11     16     21     26\nC     14     19     24     29\n\n\no al crearla dentro de la función matrix():\n\nx &lt;- matrix(c( 8, 13, 18, 23, \n              11, 16, 21, 26, \n              14, 19, 24, 29), \n            nrow = 3, byrow = TRUE,\n            dimnames = list(Categorias = c(\"A\", \"B\", \"C\"), \n                            Grupos = c(\"grupo1\", \"grupo2\", \"grupo3\", \"grupo4\")))\nx\n\n          Grupos\nCategorias grupo1 grupo2 grupo3 grupo4\n         A      8     13     18     23\n         B     11     16     21     26\n         C     14     19     24     29\n\n\nEn este último ejemplo, se han elegido arbitrariamente los nombres Categorias y Grupos para llamar al conjunto completo de las filas y de las columnas, respectivamente. Esos nombres pueden ser cambiados por otros. Además, los nombres fueron encerrados en una lista, una estructura de datos que estudiaremos en los próximos capítulos.\nAl igual que con los vectores, podemos usar los nombres de filas y columnas para indexar:\n\nx[\"B\", \"grupo2\"]\n\n[1] 16\n\n\n\n\n24.3.2 dim (dimensiones)\nEl atributo dim en R define las dimensiones de un objeto, y permite transformar un vector atómico en una estructura multidimensional, como una matriz o un array. De hecho, una matriz es, en realidad, un vector atómico con un atributo adicional: dim, que define sus dimensiones. Por ejemplo, para crear una matriz de 3 filas y 2 columnas a partir de un vector de longitud 6, basta con asignar el atributo correspondiente:\n\n# Creamos un vector atómico numérico\nx &lt;- c(8, 11, 14, 13, 16, 19, 18, 21, 24, 23, 26, 29)\nx\n\n [1]  8 11 14 13 16 19 18 21 24 23 26 29\n\nlength(x)\n\n[1] 12\n\ntypeof(x)\n\n[1] \"double\"\n\nis.vector(x)\n\n[1] TRUE\n\nis.matrix(x)\n\n[1] FALSE\n\ndim(x)\n\nNULL\n\n# Una matriz es un vector al que se le asigna un atributo \"dim\"\ndim(x) &lt;- c(3, 4)\nx\n\n     [,1] [,2] [,3] [,4]\n[1,]    8   13   18   23\n[2,]   11   16   21   26\n[3,]   14   19   24   29\n\nlength(x)\n\n[1] 12\n\ntypeof(x)\n\n[1] \"double\"\n\nis.vector(x)\n\n[1] FALSE\n\nis.matrix(x)\n\n[1] TRUE\n\ndim(x)\n\n[1] 3 4\n\n\nAl asignar dim, R reorganiza internamente los datos del vector sin modificar sus valores, pero cambia su forma y la manera en que se imprimen o manipulan. Lo anterior nos enseña que para crear una matriz podemos usar la función matrix() como vimos antes, o agregarle un atributo dim a un vector. Podemos cambiar el atributo dim para organizar los valores en otra disposición:\n\ndim(x) &lt;- c(2, 6)\nx\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    8   14   16   18   24   26\n[2,]   11   13   19   21   23   29\n\n\n\n\n24.3.3 class (clase)\nEl atributo class indica de qué clase es un objeto y esto le sirve a R para saber cómo debe comportarse y qué métodos (funciones) deben aplicarse sobre él. Dependiendo de la clase de objeto, R hace algo distinto al imprimirlo, al indexarlo o al aplicar funciones.\nA continuación, tomamos la matriz x del ejemplo anterior. Vemos que es una estructura de datos numérica, ya que así lo indica typeof(). Pero además, vemos que no es un vector atómico numérico común y corriente, sino que se trata de una matriz, como indica class(). Los objetos de clase matrix tienen particularidades propias, como el atributo dim que indica en cuántas filas y columnas se organiza su contenido.\n\nx\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    8   14   16   18   24   26\n[2,]   11   13   19   21   23   29\n\ntypeof(x)\n\n[1] \"double\"\n\nclass(x)\n\n[1] \"matrix\" \"array\" \n\n\nCualquier lenguaje permite crear nuevas clases a partir de objetos más simples. Los objetos pertenecientes a una determinada clase tiene sus propios atributos, particularidades y formas de funcionar. Muchas funciones en R se comportan de forma distinta dependiendo de la clase de un objeto.",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Arreglos</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html",
    "href": "capitulos/05_2_operaciones_vectorizadas.html",
    "title": "25  Operaciones vectorizadas",
    "section": "",
    "text": "25.1 Operaciones aritméticas vectorizadas\nCon los conocimientos compartidos hasta aquí en esta unidad somos capaces de escribir interesantes algoritmos y programas para operar con vectores y matrices (por ejemplo: ordenar, buscar el mínimo, realizar cálculos algebraicos, etc.). No obstante, son tareas para las que generalmente los lenguajes ya ofrecen una respuesta, entre el conjunto de funciones que ofrecen. Es decir, en este proceso de aprendizaje, hemos trabajado de más, resolviendo problemas que ya tienen solución, ¡pero fue para poder aprender! Ahora vamos a mencionar algunas funcionalidades que evitan que tengamos que trabajar tanto. En R, el uso de vectores y matrices es muy sencillo gracias a la vectorización.\nPor ejemplo, si tenemos un vector numérico y queremos sumar 1 a cada elemento, no necesitamos escribir una estructura for. Basta con:\nEl resultado es un nuevo vector, también de tres elementos. Internamente, R realiza la operación 1 + 1, 2 + 1 y 3 + 1, pero nosotros no tenemos que preocuparnos por escribir esa lógica paso a paso. Esto nos ahorra tiempo, reduce la cantidad de código y disminuye las posibilidades de cometer errores. Comparemos este enfoque con una versión que usa un for:\nLo mismo ocurre con las matrices. Supongamos que queremos sumar las matrices m1 y m2:\nPodemos hacer la suma celda por celda con dos estructuras for anidadas:\nNo obstante, gracias a la vectorización, todo lo anterior puede ser reemplazado sencillamente por:\nLas formas vectorizadas, además, suelen ser más eficientes porque internamente R delega estas operaciones al lenguaje C, lo que las hace mucho más rápidas. El concepto de vectorización es uno de los pilares del lenguaje R y se aplica a operaciones aritméticas, comparaciones, funciones matemáticas, transformaciones de datos, entre muchas otras tareas.\nUna de las formas más comunes de vectorización en R ocurre con las operaciones aritméticas básicas como suma (+), resta (-), multiplicación (*), división (/) y exponenciación (^), entro otras. Estas operaciones se aplican elemento a elemento cuando los operandos son vectores o matrices del mismo largo o dimensión (como en el caso visto recién).\nAcá R realiza las siguientes sumas: 1+10, 2+20, 3+30:\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(10, 20, 30)\n\nv1 + v2\n\n[1] 11 22 33\nEn este caso, R toma cada valor de m1 y lo divide por el valor de m2 que está en la misma posición:\nm1 / m2\n\n           [,1] [,2]\n[1,]        Inf 2.00\n[2,] -8.0000000 1.50\n[3,]  0.6666667 0.25",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#operaciones-entre-un-arreglo-y-un-escalar",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#operaciones-entre-un-arreglo-y-un-escalar",
    "title": "25  Operaciones vectorizadas",
    "section": "25.2 Operaciones entre un arreglo y un escalar",
    "text": "25.2 Operaciones entre un arreglo y un escalar\nTambién podemos realizar operaciones entre una matriz o vector y un vector con un único valor (un escalar), como en el primer ejemplo de este capítulo. En ese caso, R recicla automáticamente el escalar para que tenga la misma longitud que el vector:\n\na &lt;- c(1, 2, 3)\na * 10\n\n[1] 10 20 30\n\n\nEs como si R hubiera hecho:\n\na * c(10, 10, 10)\n\n[1] 10 20 30\n\n\no bien:\n\nc(1 * 10, 2 * 10, 3 * 10)\n\n[1] 10 20 30\n\n\nLo mismo ocurre con las matrices. En los siguientes caso, R toma cada valor de m2 y lo eleva al cuadrado:\n\nm2^2\n\n     [,1] [,2]\n[1,]    0    1\n[2,]    1    4\n[3,]    9   16",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#operaciones-entre-vectores-de-distinto-largo",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#operaciones-entre-vectores-de-distinto-largo",
    "title": "25  Operaciones vectorizadas",
    "section": "25.3 Operaciones entre vectores de distinto largo",
    "text": "25.3 Operaciones entre vectores de distinto largo\nSi los vectores tienen diferente longitud, R intentará reciclar el más corto, repitiendo sus elementos hasta alcanzar la longitud del más largo:\n\nv1 &lt;- c(1, 2, 3, 4)\nv2 &lt;- c(10, 20)\n\nv1 + v2\n\n[1] 11 22 13 24\n\n\nEn este caso, R realiza:\n1 + 10\n2 + 20\n3 + 10\n4 + 20\nSi la longitud del más largo no es múltiplo exacto de la del más corto, R emitirá una advertencia:\n\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(10, 20)\n\nv1 + v2\n\nWarning in v1 + v2: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 11 22 13\n\n\nSi bien este comportamiento parece práctico, puede provocar errores difíciles de detectar si no se controla con cuidado, en especial cuando se trabaja con matrices. Es preferible siempre chequear que las dimensiones de los elementos con los que operamos sean los esperados y no hacer uso de esta posibilidad.",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#funciones-vectorizadas",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#funciones-vectorizadas",
    "title": "25  Operaciones vectorizadas",
    "section": "25.4 Funciones vectorizadas",
    "text": "25.4 Funciones vectorizadas\nEn R, muchas funciones están diseñadas para operar de manera vectorizada. Esto quiere decir que si pasamos como argumento un vector o matriz, R aplica la función matemática a cada uno de sus elementos. Por ejemplo, si tenemos un vector de números, podemos obtener la raíz cuadrada de cada uno con una sola línea:\n\nv1 &lt;- c(1, 4, 9, 16)\nsqrt(v1)\n\n[1] 1 2 3 4\n\n\nSi tenemos un vector de cadenas de texto, podemos ver cuántos caracteres hay en cada uno:\n\nv2 &lt;- c(\"hola\", \"mundo\")\nnchar(v2)\n\n[1] 4 5\n\n\nOtros ejemplos de funciones matemáticas vectorizadas aplicadas a vectores numéricos:\n\nv1 &lt;- c(2.5, 3.7, -1.2)\n\nround(v1)    # Redondeo al entero más cercano\n\n[1]  2  4 -1\n\nceiling(v1)  # Techo (entero inmediato superior)\n\n[1]  3  4 -1\n\nfloor(v1)    # Piso (entero inmediato inferior)\n\n[1]  2  3 -2\n\nabs(v1)      # Valor absoluto\n\n[1] 2.5 3.7 1.2\n\nsin(v1)      # Seno\n\n[1]  0.5984721 -0.5298361 -0.9320391\n\n\nEs análogo con matrices:\n\nm1 &lt;- matrix(c(5, 8, 2, 2, 3, 1), nrow = 3)\nm1\n\n     [,1] [,2]\n[1,]    5    2\n[2,]    8    3\n[3,]    2    1\n\nlog(m1)\n\n          [,1]      [,2]\n[1,] 1.6094379 0.6931472\n[2,] 2.0794415 1.0986123\n[3,] 0.6931472 0.0000000\n\nsqrt(m1)\n\n         [,1]     [,2]\n[1,] 2.236068 1.414214\n[2,] 2.828427 1.732051\n[3,] 1.414214 1.000000\n\n\nPor supuesto, R proporciona muchas funciones estadísticas que trabajan de forma vectorizada, es decir, que procesan todos los elementos de un vector en una sola llamada. Estas funciones son muy eficientes y permiten escribir código compacto para obtener resúmenes estadísticos básicos. Si bien la exploración estadística de datos no es objeto de esta asignatura, mencionamos algunas de estas funciones:\n\nsum(v1): suma todos los elementos del vector v1.\nmean(v1): calcula el promedio (media aritmética).\nmedian(v1): calcula la mediana.\nmin(v1), max(v1): devuelven el mínimo y el máximo.\nrange(v1): devuelve un vector con el mínimo y el máximo.\nsd(v1), var(v1): calculan el desvío estándar y la variancia.\nquantile(x, probs = c(0.25, 0.5, .75)): calcula los cuartiles.\nIQR(v1): calcula el rango intercuartil.\nprod(v1): multiplica todos los elementos.\n\n\nv1 &lt;- c(2, 4, 6, 8)\nrange(v1)\n\n[1] 2 8\n\nmean(v1)\n\n[1] 5\n\nmedian(v1)\n\n[1] 5\n\nsd(v1)\n\n[1] 2.581989\n\nquantile(v1, probs = c(0.25, 0.5, .75))\n\n25% 50% 75% \n3.5 5.0 6.5 \n\nprod(v1)\n\n[1] 384\n\n\nTambién pueden ser aplicadas a matrices, por ejemplo:\n\nsum(m1)\n\n[1] 21\n\nsum(m1) / (nrow(m1) * ncol(m2))\n\n[1] 3.5\n\nmean(m1)\n\n[1] 3.5\n\nsd(m1)\n\n[1] 2.588436\n\n\nEn lugar de aplicar estas funciones estadísticas sobre todos los valores de una matriz, es más común hacerlo sobre vectores, ya que los mismos suelen representar datos observados de alguna variable. En cambio, suele ser más común calcular estos resúmenes numéricos para cada una de las filas o columnas de una matriz:\n\nSuma y media de los elementos de cada fila:\n\nrowSums(m1)\n\n[1]  7 11  3\n\nrowMeans(m1)\n\n[1] 3.5 5.5 1.5\n\nrowSums(m1) / ncol(m1)\n\n[1] 3.5 5.5 1.5\n\n\nSuma y media de los elementos de cada columna:\n\ncolSums(m1)\n\n[1] 15  6\n\ncolMeans(m1)\n\n[1] 5 2\n\ncolSums(m1) / nrow(m1)\n\n[1] 5 2",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#búsqueda-de-mínimos-y-máximos-en-arreglos-numéricos",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#búsqueda-de-mínimos-y-máximos-en-arreglos-numéricos",
    "title": "25  Operaciones vectorizadas",
    "section": "25.5 Búsqueda de mínimos y máximos en arreglos numéricos",
    "text": "25.5 Búsqueda de mínimos y máximos en arreglos numéricos\nDe esta forma podemos encontrar el valor mínimo y su ubicación en un vector numérico:\n\nx &lt;- c(40, 70, 20, 90, 20)\nmin(x)\n\n[1] 20\n\nwhich.min(x)       # si el mínimo se repite, esta es la posición del primero\n\n[1] 3\n\nwhich(x == min(x)) # si el mínimo se repite, esto muestra todas sus posiciones\n\n[1] 3 5\n\n\nY así, encontrar el valor máximo y su ubicación en el vector:\n\nmax(x)\n\n[1] 90\n\nwhich.max(x)       # si el máximo se repite, esta es la posición del primero\n\n[1] 4\n\nwhich(x == max(x)) # si el máximo se repite, esto muestra todas sus posiciones\n\n[1] 4\n\n\nCuando se trata de una matriz, tenemos:\n\nm1\n\n     [,1] [,2]\n[1,]    5    2\n[2,]    8    3\n[3,]    2    1\n\n# Valor máximo\nmax(m1)\n\n[1] 8\n\n# Posición (arr.ind = TRUE para que nos indique fila y columna)\nwhich(m1 == max(m1), arr.ind = TRUE)\n\n     row col\n[1,]   2   1\n\n# Valor mínimo\nmin(m1)\n\n[1] 1\n\n# Posición\nwhich(m1 == min(m1), arr.ind = TRUE)\n\n     row col\n[1,]   3   2",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#álgebra-matricial",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#álgebra-matricial",
    "title": "25  Operaciones vectorizadas",
    "section": "25.6 Álgebra matricial",
    "text": "25.6 Álgebra matricial\nComo aprenderán en Álgebra, las matrices numéricas son muy útiles en diversos campos y por eso existen distintas operaciones que se pueden realizar con las mismas. Veamos algunos ejemplos de la aplicación del álgebra matricial en R:\n\nTranspuesta de una matriz:\n\nm1\n\n     [,1] [,2]\n[1,]    5    2\n[2,]    8    3\n[3,]    2    1\n\nt(m1)\n\n     [,1] [,2] [,3]\n[1,]    5    8    2\n[2,]    2    3    1\n\n\nProducto entre dos matrices (la cantidad de columnas de la primera debe coincidir con la cantidad de filas de la segunda):\n\nm3 &lt;- matrix(1:4, nrow = 2)\nm1\n\n     [,1] [,2]\n[1,]    5    2\n[2,]    8    3\n[3,]    2    1\n\nm3\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nm1 %*% m3\n\n     [,1] [,2]\n[1,]    9   23\n[2,]   14   36\n[3,]    4   10\n\n\nInversa de la matriz:\n\nsolve(m3)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\n\nObtener los elementos de la diagonal principal:\n\ndiag(m3)\n\n[1] 1 4\n\n\nCrear una matriz identidad:\n\ndiag(5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#operaciones-lógicas-vectorizadas",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#operaciones-lógicas-vectorizadas",
    "title": "25  Operaciones vectorizadas",
    "section": "25.7 Operaciones lógicas vectorizadas",
    "text": "25.7 Operaciones lógicas vectorizadas\nAl igual que las funciones matemáticas, los operadores de comparación en R también están vectorizados. Esto significa que podemos comparar cada elemento de un vector o una matriz con un valor, o comparar dos arreglos entre sí, sin necesidad de usar bucles y obteniendo como resultado otro arreglo de valores lógicos.\n\n25.7.1 Comparaciones lógicas entre arreglos\nCuando dos vectores o matrices se vinculan a través de una comparación, se opera elemento a elemento obteniendo un vector o matriz de valores lógicos:\n\nv1 &lt;- c(40, 70, 20, 90, 20)\nv2 &lt;- c(10, 70, 30, 15, 21)\nv1 &gt; v2\n\n[1]  TRUE FALSE FALSE  TRUE FALSE\n\nv1 &lt; v2 * 5\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n\nm1 &lt;- matrix(c(5, 8, 2, 2, 3, 1), nrow = 3)\nm2 &lt;- matrix(c(0, -1, 3, 1, 2, 4), nrow = 3)\nm1\n\n     [,1] [,2]\n[1,]    5    2\n[2,]    8    3\n[3,]    2    1\n\nm2\n\n     [,1] [,2]\n[1,]    0    1\n[2,]   -1    2\n[3,]    3    4\n\nm1 != m2\n\n     [,1] [,2]\n[1,] TRUE TRUE\n[2,] TRUE TRUE\n[3,] TRUE TRUE\n\nm1 &gt; m2\n\n      [,1]  [,2]\n[1,]  TRUE  TRUE\n[2,]  TRUE  TRUE\n[3,] FALSE FALSE\n\n\nSi tenemos un vector o matriz de valores lógicos y queremos saber si todos o al menos uno de los elementos es igual a TRUE, podemos usar las funciones all() y any(), respectivamente:\n\nall(m1 != m2)\n\n[1] TRUE\n\nany(m1 != m2)\n\n[1] TRUE\n\nall(m1 &gt; m2)\n\n[1] FALSE\n\nany(m1 &gt; m2)\n\n[1] TRUE\n\n\n\n\n25.7.2 Comparaciones lógicas entre un arreglo y un valor\nLas operaciones de comparación pueden hacerse entre cada elemento de un vector o matriz y un único valor. Recordemos los vectores y matrices que estamos usando:\n\nv1\n\n[1] 40 70 20 90 20\n\nv2\n\n[1] 10 70 30 15 21\n\nm1\n\n     [,1] [,2]\n[1,]    5    2\n[2,]    8    3\n[3,]    2    1\n\nm2\n\n     [,1] [,2]\n[1,]    0    1\n[2,]   -1    2\n[3,]    3    4\n\n\nAhora veamos ejemplos de comparaciones lógicas entre ellos y un número:\n\nv1 &lt; 50\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\nm1 == 3\n\n      [,1]  [,2]\n[1,] FALSE FALSE\n[2,] FALSE  TRUE\n[3,] FALSE FALSE\n\nm2 &gt; 0\n\n      [,1] [,2]\n[1,] FALSE TRUE\n[2,] FALSE TRUE\n[3,]  TRUE TRUE\n\n\nLos operadores lógicos que se utilizan para realizar cálculos elemento a elemento con vectores y matrices son &, | y !. Ellos nos permiten crear expresiones aún más complejas:\n\nv1 &lt; 50 & v2 &gt; 50\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nm1 &lt; 0 | m2 &gt; 0\n\n      [,1] [,2]\n[1,] FALSE TRUE\n[2,] FALSE TRUE\n[3,]  TRUE TRUE\n\n!(v1 &lt;= 50)\n\n[1] FALSE  TRUE FALSE  TRUE FALSE",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_2_operaciones_vectorizadas.html#formas-de-indexación-múltiple",
    "href": "capitulos/05_2_operaciones_vectorizadas.html#formas-de-indexación-múltiple",
    "title": "25  Operaciones vectorizadas",
    "section": "25.8 Formas de indexación múltiple",
    "text": "25.8 Formas de indexación múltiple\nComo ya sabemos, indexar es hacer referencia a uno o más elementos particulares dentro de una estructura de datos. Una de las formas más potentes y expresivas de trabajar con vectores en R es a través de la indexación lógica. Esta técnica permite seleccionar elementos de un arreglo usando condiciones que generan vectores lógicos (TRUE o FALSE).\n\n25.8.1 Indexación múltiple en base a posiciones\nConocemos que para indexar a un vector, hace falta sólo un índice:\n\nv1 &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7)\nv1[3]\n\n[1] 3.1\n\n\nY que para indexar matrices, son necesarios dos índices:\n\nm1 &lt;- matrix(c(4,-2, 1, 20, -7, 12, -8, 13, 17), nrow = 3)\nm1\n\n     [,1] [,2] [,3]\n[1,]    4   20   -8\n[2,]   -2   -7   13\n[3,]    1   12   17\n\nm1[2, 3]\n\n[1] 13\n\n\nPero también podemos indexar a múltiples elementos de un vector o una matriz a la vez. Los siguientes ejemplos presentan distintas formas de seleccionar varias posiciones de un vector en simultáneo:\n\n# Vector v1\nv1\n\n[1] 10.4  5.6  3.1  6.4 21.7\n\n# Mostrar los primeros tres elementos del vector v1\nv1[1:3]\n\n[1] 10.4  5.6  3.1\n\n# Mostrar los elementos en las posiciones 2 y 4\nv1[c(2, 4)]\n\n[1] 5.6 6.4\n\n# Mostrar el último elemento\nv1[length(v1)]\n\n[1] 21.7\n\n# Bonus: Mostrar todos los elementos menos el cuarto\nv1[-4]\n\n[1] 10.4  5.6  3.1 21.7\n\n\nPara las matrices:\n\n# Matriz m1\nm1\n\n     [,1] [,2] [,3]\n[1,]    4   20   -8\n[2,]   -2   -7   13\n[3,]    1   12   17\n\n# Filas 2 y 3, columna 2\nm1[2:3, 2]\n\n[1] -7 12\n\n# Filas 1 y 3, columna 1\nm1[c(1, 3), 1]\n\n[1] 4 1\n\n# Toda la fila 3\nm1[3, ]\n\n[1]  1 12 17\n\n# Toda la columna 2\nm1[, 2]\n\n[1] 20 -7 12\n\n# Submatriz con las columnas 1 y 2\nm1[, 1:2]\n\n     [,1] [,2]\n[1,]    4   20\n[2,]   -2   -7\n[3,]    1   12\n\n# Submatriz con las columnas 1 y 3\nm1[, c(1, 3)]\n\n     [,1] [,2]\n[1,]    4   -8\n[2,]   -2   13\n[3,]    1   17\n\n# Asignar el mismo valor en toda la fila 3\nm1[3, ] &lt;- 10\nm1\n\n     [,1] [,2] [,3]\n[1,]    4   20   -8\n[2,]   -2   -7   13\n[3,]   10   10   10\n\n\n\n\n25.8.2 Indexación múltiple en base a comparaciones lógicas\nYa hemos visto que, además de utilizar enteros para señalar posiciones, también podemos indexar usando nombres si los arreglos tienen seteado su atributo names. No obstante, estas no son las únicas formas de indexar: también podemos hacerlo con valores lógicos TRUE o FALSE.\n\n# Vector v1\nv1\n\n[1] 10.4  5.6  3.1  6.4 21.7\n\n# Indexar con valores lógicos. Obtenemos sólo las posiciones indicadas con TRUE:\nv1[c(FALSE, FALSE, TRUE, TRUE, FALSE)]\n\n[1] 3.1 6.4\n\n# Sabiendo que la siguiente operación devuelve TRUE o FALSE para cada posición \n# de v1...\nv1 &gt; 10\n\n[1]  TRUE FALSE FALSE FALSE  TRUE\n\n# ...podemos usarla para quedarnos con aquellos elementos de x mayores a 10:\nv1[v1 &gt; 10]\n\n[1] 10.4 21.7\n\n\nEste tipo de expresión es muy habitual en el análisis de datos, ya que permite extraer subconjuntos en forma directa y legible. También se puede combinar con asignación de valor:\n\nv1[v1 &lt; 10] &lt;- 0\nv1\n\n[1] 10.4  0.0  0.0  0.0 21.7",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Operaciones vectorizadas</span>"
    ]
  },
  {
    "objectID": "capitulos/05_practica.html",
    "href": "capitulos/05_practica.html",
    "title": "Práctica de la Unidad 5",
    "section": "",
    "text": "Vectores",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/05_practica.html#vectores",
    "href": "capitulos/05_practica.html#vectores",
    "title": "Práctica de la Unidad 5",
    "section": "",
    "text": "Ejercicio 1\nSuma de los elementos de un vector\nDefinir una función llamada suma(v) que reciba un vector numérico v de cualquier longitud y devuelva la suma de sus elementos. Ejemplos de su uso:\n\nmi_vector &lt;- c(60, -5, 0, 12, 1)\nsuma(mi_vector)\n\n[1] 68\n\nx &lt;- 3\nsuma(x)\n\n[1] 3\n\n\n\n\nEjercicio 2\nSuma de vectores\nLa suma de dos vectores de la misma dimensión está dada por un nuevo vector donde cada elemento es igual a la suma de los elementos que ocupan la misma posición en los vectores originales. Por ejemplo:\n\\[\n\\bar{u} + \\bar{v} = \\begin{pmatrix} 5 \\\\ 8 \\\\ 2 \\end{pmatrix} +  \\begin{pmatrix} 2 \\\\ 3 \\\\ -1 \\end{pmatrix}  = \\begin{pmatrix} 7 \\\\ 11 \\\\ 1 \\end{pmatrix}\n\\]\nDefinir una función llamada sumar_vectores(u, v) que reciba dos vectores u y v de la misma dimensión y devuelva su suma. La función debe devolver un error informativo si los largos de ambos vectores no son iguales. Ejemplos de su uso:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nsumar_vectores(u, v)\n\n[1]  7 11  1\n\nx &lt;- 10\ny &lt;- 2\nsumar_vectores(x, y)\n\n[1] 12\n\nw &lt;- c(5, 8, 2)\nz &lt;- c(2, 3)\nsumar_vectores(w, z)\n\nError in sumar_vectores(w, z): Las dimensiones de los vectores no coinciden.\n\n\n\n\nEjercicio 3\nOrdenar los elementos de un vector numérico\nDefinir una función llamada ordenar_asc(v) que tome como entrada un vector numérico v de cualquier largo y lo devuelva con sus elementos ordenados en forma ascendente (de menor a mayor). La función debe cubrir el caso en el que el largo de v sea 1 (en cuyo caso devuelve el valor provisto, sin arrojar errores). Ejemplos de su uso:\n\nmi_vector &lt;- c(60, -5, 0, 12, 1)\nordenar_asc(mi_vector)\n\n[1] -5  0  1 12 60\n\nx &lt;- 1\nordenar_asc(x)\n\n[1] 1\n\n\n\n\nEjercicio 4\nHallar el máximo de un vector\nDefinir una función llamada maximo(v) que encuentre cuál es el mayor valor en un vector numérico v. La función debe devolver un vector con dos elementos, el primero es el valor del máximo y el segundo es la posición en la cual el mismo se halla en el vector v. Si dicho mayor valor estuviese repetido en el vector, se determina la posición de su primera ocurrencia. El vector devuelto debe hacer uso del atributo names. Ejemplos de su uso:\n\nmi_vector &lt;- c(60, -5, 0, 120, 1)\nmaximo(mi_vector)\n\n   mayor posicion \n     120        4 \n\nx &lt;- 6\nmaximo(x)\n\n   mayor posicion \n       6        1 \n\n\n\n\nEjercicio 5\nÁlgebra vectorial\n\nDados dos vectores \\(\\bar u = (u_1, u_2, ..., u_n)\\) y \\(\\bar v = (v_1, v_2, ..., v_n)\\), ambos \\(\\in \\mathbf{R}^n\\), se define como producto escalar al escalar: \\(\\bar u \\times \\bar v = u_1v_1+u_2v_2+....+u_nv_n\\).\nDefinir una función llamada prod_escalar(u, v) que tome dos vectores u y v de la misma dimensión y devuelva el producto escalar entre ellos. La función debe devolver un error informativo si largo de los vectores no admite esta operación. Ejemplos de su uso:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nprod_escalar(u, v)\n\n[1] 32\n\nx &lt;- 10\ny &lt;- 2\nprod_escalar(x, y)\n\n[1] 20\n\nw &lt;- c(5, 8, 2)\nz &lt;- c(2, 3)\nprod_escalar(w, z)\n\nError in prod_escalar(w, z): Las dimensiones de los vectores no coinciden.\n\n\nDados dos vectores \\(\\bar u = (u_1, u_2, u_3)\\) y \\(\\bar v = (v_1, v_2, v_3)\\), ambos \\(\\in \\mathbf{R}^3\\), se define como producto vectorial de \\(\\bar u\\) con \\(\\bar v\\) al vector de \\(\\mathbf{R}^3\\): \\(\\bar u \\wedge \\bar v = (u_2v_3-u_3v_2, u_3v_1-u_1v_3, u_1v_2-u_2v_1)\\).\nDefinir una función llamada prod_vectorial(u, v) que tome dos vectores u y v de largo 3 y devuelva el producto vectorial entre ellos. La función debe devolver un error informativo si los vectores no son de dimensión 3. Ejemplos de su uso:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nprod_vectorial(u, v)\n\n[1] -14   9  -1\n\nw &lt;- c(5, 8)\nz &lt;- c(2, 3)\nprod_vectorial(w, z)\n\nError in prod_vectorial(w, z): Los vectores no son de dimensión 3.\n\n\nDados tres vectores \\(\\bar u\\), \\(\\bar v\\) y \\(\\bar w \\in \\mathbf{R}^3\\), se llama producto mixto de \\(\\bar u\\), \\(\\bar v\\) y \\(\\bar w\\), en ese orden, al escalar: \\(\\bar u \\wedge \\bar v \\times \\bar w\\).\nHaciendo uso de las funciones definidas en los ítems anteriores, definir una función llamada prod_mixto(u, v, w) que tome tres vectores de largo 3 y devuelva el producto mixto entre ellos. Ejemplo de su uso:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nw &lt;- c(1, 2, 3)\nx &lt;- c(1, 2)\nprod_mixto(u, v, w)\n\n[1] 1\n\nprod_mixto(u, v, x)\n\nError in prod_escalar(resultado1, w): Las dimensiones de los vectores no coinciden.\n\n\nHaciendo uso de las funciones definidas en los ítems anteriores, definir una función llamada mostrar_productos(u, v, w) que tome tres vectores \\(\\bar u\\), \\(\\bar v\\) y \\(\\bar w \\in \\mathbf{R}^3\\) y calcule y muestre en la consola:\n\nel producto escalar \\(\\bar v \\wedge \\bar w\\)\nel producto mixto \\(\\bar v \\wedge \\bar w \\times \\bar u\\)\n\nAdemás, la función debe devolver un vector numérico de largo 2 con los resultados anteriores, en ese orden, con nombres. Ejemplo de su uso:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nw &lt;- c(1, 2, 3)\nx &lt;- c(1, 2)\n\nproductos &lt;- mostrar_productos(u, v, w)\n\nEl producto escalar entre v y w es: 5 \nEl producto mixto entre v, w y u es: 1 \n\nproductos\n\nprod_escalar   prod_mixto \n           5            1 \n\nproductos[1]\n\nprod_escalar \n           5 \n\nproductos[\"prod_mixto\"]\n\nprod_mixto \n         1 \n\nproductos &lt;- mostrar_productos(u, v, x)\n\nError in prod_escalar(v, w): Las dimensiones de los vectores no coinciden.\n\n\n\n\n\nEjercicio 6\nLa criba de Eratóstenes\nEn el siglo III a.C., el astrónomo griego Eratóstenes desarrolló un algoritmo para encontrar todos los números primos menores que un número natural dado n. El mismo consiste en anotar una tabla todos los naturales entre 2 y n. Por ejemplo, para n = 20, empezamos por escribir el siguiente conjunto:\n\n\n\n\n\n\n\n\n\nLuego se encierra con un círculo el primer número del conjunto, indicando que hemos encontrado un número primo. Se recorre el resto del grupo tachando cada múltiplo del valor que hemos encerrado recién, dado que esto significa que no puede ser primo. Por lo tanto, al finalizar el primer paso del algoritmo, habremos encerrado el número 2 y tachado todos los múltiplos de 2, como se ve a continuación:\n\n\n\n\n\n\n\n\n\nA partir de acá, simplemente se repite el proceso encerrando el primer número del conjunto que no está ni tachado ni encerrado y luego tachando todos sus múltiplos. Eventualmente, cada número en la lista quedará encerrado o tachado, como se muestra en el diagrama:\n\n\n\n\n\n\n\n\n\nLos números encerrados son los primos, los tachados son compuestos. Este algoritmo para generar una lista de números primos se conoce como la Criba de Eratóstenes.\nDefinir una función llamada mostrar_primos(n, enfoque) que se base en la criba de Eratóstenes y muestre todos los números primos hasta un número entero n. La función debe implementar los siguientes enfoques:\n\n\"asumir_primos\": partir de un vector lógico donde todos los números, salvo el 1, se consideran primos inicialmente. Luego, descartar los múltiplos de cada número que aún es considerado primo.\n\"tachar\": utilizar un vector llamado tachado que comience con todos los valores en FALSE, e ir marcando con TRUE a los números que se descartan por no ser primos (es decir, los tachados). Comenzar tachando el 1, y luego los múltiplos de cada número no tachado.\n\"encerrado\": partir de un vector encerrado en el que todos los números comiencen como TRUE. Cada vez que se encuentre un número primo, marcar (poner en FALSE) todos sus múltiplos, indicando que ya no están “encerrados”.\n\nEjemplos de uso:\n\nmostrar_primos(15, enfoque = \"asumir_primos\")\n\n[1] 2\n[1] 3\n[1] 5\n[1] 7\n[1] 11\n[1] 13\n\nmostrar_primos(15, enfoque = \"tachar\")\n\n[1] 2\n[1] 3\n[1] 5\n[1] 7\n[1] 11\n[1] 13\n\nmostrar_primos(15, enfoque = \"encerrado\")\n\n[1] 2\n[1] 3\n[1] 5\n[1] 7\n[1] 11\n[1] 13",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/05_practica.html#matrices",
    "href": "capitulos/05_practica.html#matrices",
    "title": "Práctica de la Unidad 5",
    "section": "Matrices",
    "text": "Matrices\n\nEjercicio 7\nSuma de dos matrices\nDadas dos matrices de igual dimensión \\(\\mathbf{A}\\) y \\(\\mathbf{B}\\):\n\\[\n\\mathbf{A} = \\begin{pmatrix} 5 & 2 \\\\ 8 & 3 \\\\ 2 & 1\\end{pmatrix} \\qquad \\qquad\n\\mathbf{B} = \\begin{pmatrix} 0 & 1 \\\\ -1 & 2 \\\\ 3 & 4\\end{pmatrix}\n\\]\nla suma entre ellas es igual a:\n\\[\n\\mathbf{A} + \\mathbf{B} = \\begin{pmatrix} 5 & 2 \\\\ 8 & 3 \\\\ 2 & 1\\end{pmatrix} +\n\\begin{pmatrix} 0 & 1 \\\\ -1 & 2 \\\\ 3 & 4\\end{pmatrix} =\n\\begin{pmatrix} 5 & 3 \\\\ 7 & 5 \\\\ 5 & 5\\end{pmatrix}\n\\]\nDefinir una función llamada sumar_matrices(A, B) que tome dos matrices A y B de la misma dimensión y devuelva su suma. La función debe devolver un error informativo si las dimensiones de las matrices no coinciden. Ejemplo de su uso:\n\nA &lt;- matrix(c(5, 8, 2, 2, 3, 1), nrow = 3)\nB &lt;- matrix(c(0, -1, 3, 1, 2, 4), nrow = 3)\nsumar_matrices(A, B)\n\n     [,1] [,2]\n[1,]    5    3\n[2,]    7    5\n[3,]    5    5\n\nB &lt;- matrix(c(0, -1, 3, 1, 2, 4), nrow = 2)\nsumar_matrices(A, B)\n\nError in sumar_matrices(A, B): Las dimensiones de las matrices no coinciden.\n\n\n\n\nEjercicio 8\nHallar mínimo en una matriz\n\nDefinir una función llamada minimo_matriz(m) que encuentre el menor valor en una matriz numérica m y lo devuelva como el primer elemento de un vector de largo 3, el cual debe tener como segundo y tercer elemento el número de fila y de columna donde se encuentra el mínimo, respectivamente. El vector devuelto debe hacer uso del atributo names. Ejemplo de uso:\n\nA &lt;- matrix(c(5, 8, 2, 7, 3, 1), nrow = 3)\nA\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    8    3\n[3,]    2    1\n\nminimo_matriz(A)\n\n minimo    fila columna \n      1       3       2 \n\n\nDefinir una función llamada minimo_matriz_fila(m, fila) que encuentre el menor valor en la fila número fila de una matriz numérica m y devuelva un vector de largo 2, donde el primer elemento sea el valor mínimo encontrado y el segundo elemento sea el número de columna en la que lo encontró. Por defecto, la búsqueda del mínimo debe hacerse en la fila 1. El vector devuelto debe hacer uso del atributo names. Ejemplo de uso:\n\nA &lt;- matrix(c(5, 8, 2, 7, 3, 1), nrow = 3)\nA\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    8    3\n[3,]    2    1\n\nminimo_matriz_fila(A, 2)\n\n minimo columna \n      3       2 \n\nminimo_matriz_fila(A)\n\n minimo columna \n      5       1 \n\n\n\n\n\nEjercicio 9\nReordenar matriz según valores en una fila o columna\n\nDefinir una función llamada ordenar_desc_col(m, col) que intercambie las filas de la matriz m de modo que la misma quede con los valores de la columna número col ordenados de forma descendente. Ejemplos de su uso:\n\nA &lt;- matrix(c( 4, 13,  9, 17,\n              20, 14, 14,  9,\n               2, 16, 12,  7,\n              16,  2,  4, 11,\n              12, 20, 16,  4), nrow = 5, byrow = TRUE)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   13    9   17\n[2,]   20   14   14    9\n[3,]    2   16   12    7\n[4,]   16    2    4   11\n[5,]   12   20   16    4\n\nordenar_desc_col(A, 3)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12   20   16    4\n[2,]   20   14   14    9\n[3,]    2   16   12    7\n[4,]    4   13    9   17\n[5,]   16    2    4   11\n\nA &lt;- matrix(c( 4, 13,  9, 17), nrow = 1)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   13    9   17\n\nordenar_desc_col(A, 3)\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   13    9   17\n\n\nDefinir la función ordenar_asc_fila(m, fila) para intercambiar las columnas de la matriz m de modo que la misma quede con los valores de la fila número fila ordenados en forma ascendente. Ejemplos de su uso:\n\nA &lt;- matrix(c( 4, 13,  9, 17,\n              20, 14, 14,  9,\n               2, 16, 12,  7,\n              16,  2,  4, 11,\n              12, 20, 16,  4), nrow = 5, byrow = TRUE)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   13    9   17\n[2,]   20   14   14    9\n[3,]    2   16   12    7\n[4,]   16    2    4   11\n[5,]   12   20   16    4\n\nordenar_asc_fila(A, 3)\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   17    9   13\n[2,]   20    9   14   14\n[3,]    2    7   12   16\n[4,]   16   11    4    2\n[5,]   12    4   16   20\n\nA &lt;- matrix(c( 4, 13,  9, 17), nrow = 1)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    4   13    9   17\n\nordenar_asc_fila(A, 1)\n\n     [,1] [,2] [,3] [,4]\n[1,]    4    9   13   17\n\n\n\n\n\nEjercicio 10\nCuadrado mágico\nUn cuadrado mágico es un arreglo bidimensional de enteros en el que las filas, columnas y diagonales suman el mismo valor. Uno de los cuadrados mágicos más famosos aparece en el grabado Melancolía I de Alberto Durero, justo debajo de la campana. En el mismo, todas las sumas dan 34, y además Durero acomodó el cuadrado de manera que en el centro en la fila de abajo se forme 1514, año en el que produjo el grabado.\n\n\n\n\n\n\n\n\n\nDefinir una función llamada cuadrado_magico(cuadrado) que devuelva TRUE si una matriz \\(n \\times n\\) contiene un cuadrado mágico, o FALSE en caso contrario. Ejemplos de su uso:\n\ncuadrado &lt;- matrix(c(16,  3,  2, 13,\n                      5, 10, 11,  8,\n                      9,  6,  7, 12,\n                      4, 15, 14,  1), nrow = 4, byrow = TRUE)\ncuadrado\n\n     [,1] [,2] [,3] [,4]\n[1,]   16    3    2   13\n[2,]    5   10   11    8\n[3,]    9    6    7   12\n[4,]    4   15   14    1\n\ncuadrado_magico(cuadrado)\n\n[1] TRUE\n\ncuadrado &lt;- matrix(c( 0,  3,  2, 13,\n                      5, 10, 11,  8,\n                      9,  6,  7, 12,\n                      4, 15, 14,  1), nrow = 4, byrow = TRUE)\ncuadrado\n\n     [,1] [,2] [,3] [,4]\n[1,]    0    3    2   13\n[2,]    5   10   11    8\n[3,]    9    6    7   12\n[4,]    4   15   14    1\n\ncuadrado_magico(cuadrado)\n\n[1] FALSE",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/05_practica.html#operaciones-vectorizadas",
    "href": "capitulos/05_practica.html#operaciones-vectorizadas",
    "title": "Práctica de la Unidad 5",
    "section": "Operaciones vectorizadas",
    "text": "Operaciones vectorizadas\nEn esta sección utilizaremos la operatoria vectorizada de R y las funciones que el software ya trae disponibles para alcanzar los mismos objetivos que en los ejercicios anteriores y, además, realizar otras tareas.\n\nEjercicio 11\nLuego de crear el vector x &lt;- c(2, 5, 8, 1, 9, 10, 4, 5):\n\nCalcular el logaritmo en base 5 de cada uno de los valores de x.\nIndicar en qué posiciones del vector hay valores mayores que 4.\nIndexar el vector para extraer los valores mayores que 4.\nContar cuántos valores del vector son mayores que 4.\nExtraer del vector los elementos que son pares.\nCalcular la suma de todos los elementos mayores que 5.\n\n\n\nEjercicio 12\nLuego de crear la matriz m &lt;- matrix(1:9, nrow = 3):\n\nSumarle 10 a todos los elementos.\nSacarle la raíz cúbica a todos los elementos.\nMultiplicar cada elemento por 2.\nDefinir una matriz cualquiera del mismo tamaño y restársela a m.\nContar cuántos elementos mayores a 5 tiene m.\nMostrar cuáles son los elementos mayores a 5.\nMostrar en qué posiciones se encuentran los elementos mayores a 5.\nCalcular la suma total de los elementos de m y su promedio general, la suma por columnas y por filas, y el promedio por columnas y por filas.\n\n\n\nEjercicio 13\nDado el vector x &lt;- 1:20:\n\nExtraer todos los elementos que sean mayores que 10 y divisibles por 3.\nExtraer los elementos que no sean múltiplos de 2 ni de 5.\nContar cuántos valores cumplen con la condición anterior\n\n\n\nEjercicio 14\nResolución alternativa de ejercicios anteriores\n\n¿Cuál es la función de R que se encarga de sumar los elementos de un arreglo numérico? Utilizarla en el mismo ejemplo presentado en el Ejercicio 1 y comparar resultados.\nEn el Ejercicio 2 escribimos una función llamada sumar_vectores(u, v) que toma dos vectores u y v de la misma dimensión y devuelve su suma. De manera similar, en el Ejercicio 7 escribimos una función para sumar dos matrices. ¿Cómo podemos obtener el mismo resultado sin tener que crear estas funciones nuevas, sabiendo que en R las funciones operan de forma vectorizada?\n¿Con qué función de R se pueden ordenar de forma ascendente los elementos de un vector numérico? Demostrarlo con los mismos ejemplos del Ejercicio 3. ¿Se puede aplicar esta función en vectores de tipo carácter?\n¿Con qué funciones de R se pueden encontrar los valores mínimos y máximos de un vector o de una matriz? Las funciones que escribimos en el Ejercicio 4 y en el Ejercicio 8a persiguen este mismo objetivo, pero además devuelven la posición del valor buscado en el arreglo. ¿Cómo se puede hacer esto en R? ¿Se pueden aplicar estas funciones en vectores de tipo carácter?\nUtilizando las funciones vectorizadas de R, ¿cómo podemos obtener de manera sencilla el producto escalar entre dos vectores, como en el Ejercicio 5a?\n¿Cómo se pueden usar las funciones de R para encontrar el valor mínimo en una fila en particular de una matriz numérica, tal como se planteó en el Ejercicio 8b ? Demostrarlo con la matriz que se define a continuación, suponiendo que deseamos encontrar cuál es el mínimo en la fila 2.\n\nA &lt;- matrix(c(5, 8, 2, 7, 3, 1), nrow = 3)\n\nPensar una nueva forma de crear la función cuadrado_magico() del Ejercicio 10 que aproveche la operatoria vectorizada de R para simplificar los cálculos.",
    "crumbs": [
      "Unidad 5. Estructuras de datos",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/90.html",
    "href": "capitulos/90.html",
    "title": "Soluciones de la Práctica",
    "section": "",
    "text": "En esta sección se presentan las respuestas a todos los ejercicios de la práctica. Al hacer uso de este material, se debe tener en cuenta:\n\nMuchos ejercicios no tienen una respuesta única y sólo se muestra una solución posible. Aún más, muchas veces elegimos mostrar una solución por ser sencilla o estar alineada con los temas desarrollados, cuando en realidad hay otras formas que tal vez sean mejores para resolver el mismo problema.\nEs importante intentar resolver los ejercicios por cuenta propia y no acercarse a la resolución como primera medida. Leer una respuesta puede darnos la falsa sensación de que entendemos, cuando en realidad enfrentar la resolución de un problema forma independiente puede ser mucho más desafiante. Este material debe servir como un apoyo después de haber trabajado en la resolución de los problemas.",
    "crumbs": [
      "Soluciones de la Práctica"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html",
    "href": "capitulos/90_soluciones_01.html",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "",
    "text": "Ejercicio 1\nPara crear un nuevo script y guardarlo, podés seguir los ejemplos vistos en #sec-scripts. El contenido del script tiene que ser:\n# Ejercicio 1\n25 + 17\n6 * 8\nsqrt(144)",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-2",
    "href": "capitulos/90_soluciones_01.html#ejercicio-2",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\n\nPara acceder a la documentación de la función round(), se puede ejecutar en la consola de R:\n\n?round\no\nhelp(round)\n\nSegún la ayuda de R, la función round() tiene los siguientes argumentos:\n\n\nx: El número o vector de números que se desea redondear.\n\ndigits: El número de cifras decimales al que se desea redondear x. Puede ser positivo (para redondear decimales) o negativo (para redondear a múltiplos de 10).\n\n...: representa el uso opcional de otros argumentos, es algo que podemos ignorar por ahora.\n\n\n\nObligatorio: x, ya que es el número a redondear.\n\nOpcional: digits, que por defecto es 0, lo que significa que la función redondeará al número entero más cercano si no se especifica un valor distinto.\n\n\n\n\nround(3.14159, digits = 0)  # Redondeo a 0 decimales → Resultado: 3\n\n[1] 3\n\nround(3.14159, digits = 1)  # Redondeo a 1 decimal → Resultado: 3.1\n\n[1] 3.1\n\nround(3.14159, digits = 2)  # Redondeo a 2 decimales → Resultado: 3.14\n\n[1] 3.14\n\n\n\n\n\n\nround(3.14159, 2)\n\n[1] 3.14\n\nround(x = 3.14159, digits = 2)\n\n[1] 3.14\n\nround(digits = 2, x = 3.14159)\n\n[1] 3.14",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-3",
    "href": "capitulos/90_soluciones_01.html#ejercicio-3",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\n\nx &lt;- 10\ny &lt;- \"Hola\"\nz &lt;- 5\n\n\nPodemos verificar el tipo de cada objeto con la función typeof():\n\n\ntypeof(x)\n\n[1] \"double\"\n\ntypeof(y)\n\n[1] \"character\"\n\ntypeof(z)\n\n[1] \"double\"\n\n\n\nEjecutamos la siguiente instrucción:\n\n\nz &lt;- x * 6\n\nAhora, z almacenará el valor:\n\nz\n\n[1] 60\n\n\n\nObtenemos un error porque x es un número (double), mientras que y es un texto (character). En R, no es posible realizar operaciones matemáticas entre objetos de tipo diferente.\n\n\nx + y\n\nError in x + y: non-numeric argument to binary operator",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-4",
    "href": "capitulos/90_soluciones_01.html#ejercicio-4",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\n\nload(\"practica1_ambiente.RData\")\n\nSe incorporaron 6 objetos al ambiente:\n\n\n\nIdentificador\nTipo de vector\nValor\n\n\n\n\nvar1\nlogical\nTRUE\n\n\nvar2\ndouble\n200.12\n\n\nvar3\ncharacter\n\"hola\"\n\n\nvar4\ncharacter\n\"chau\"\n\n\nvar5\ninteger\n-49L\n\n\nvar6\ncharacter\n\"Hola\"\n\n\n\n\ntypeof(var1)\n\n[1] \"logical\"\n\ntypeof(var2)\n\n[1] \"double\"\n\ntypeof(var3)\n\n[1] \"character\"\n\ntypeof(var4)\n\n[1] \"character\"\n\ntypeof(var5)\n\n[1] \"integer\"\n\ntypeof(var6)\n\n[1] \"character\"",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-5",
    "href": "capitulos/90_soluciones_01.html#ejercicio-5",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\n\n\n\n\nvar2 &lt; 0 || var5 &lt; 0\n\n[1] TRUE\n\n\n\n\n\n\nvar2 &lt; 0 && var5 &lt; 0\n\n[1] FALSE\n\n\n\n\n\n\nvar2 %% (var5 + 100) &lt; 10\n\n[1] FALSE\n\n\n\nNo son iguales porque uno tiene una letra mayúscula, “H” es un caracter distinto de “h” y por lo tanto son cadenas de texto diferentes.\n\n\nvar3 == var6\n\n[1] FALSE",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-6",
    "href": "capitulos/90_soluciones_01.html#ejercicio-6",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\n\n\n\n\n\n\n\n\n\nOperación\nedad &lt;- 21, altura &lt;- 1.90\nedad &lt;- 17 , altura &lt;- 1.90\nedad &lt;- 21, altura &lt;- 1.50\n\n\n\n\n(edad &gt; 18) && (altura &lt; 1.70)\nFALSE\nFALSE\nTRUE\n\n\n(edad &gt; 18)   || (altura &lt; 1.70)\nTRUE\nFALSE\nTRUE\n\n\n!(edad &gt; 18)\nFALSE\nTRUE\nFALSE\n\n\n\nVerificación en R:\n\n# Primera columna\nedad &lt;- 21\naltura &lt;- 1.90\n\n(edad &gt; 18) && (altura &lt; 1.70)\n\n[1] FALSE\n\n(edad &gt; 18) || (altura &lt; 1.70)\n\n[1] TRUE\n\n!(edad &gt; 18)\n\n[1] FALSE\n\n# Segunda columna\nedad &lt;- 17\naltura &lt;- 1.90\n\n(edad &gt; 18) && (altura &lt; 1.70)\n\n[1] FALSE\n\n(edad &gt; 18) || (altura &lt; 1.70)\n\n[1] FALSE\n\n!(edad &gt; 18)\n\n[1] TRUE\n\n# Tercera columna\nedad &lt;- 21\naltura &lt;- 1.50\n\n(edad &gt; 18) && (altura &lt; 1.70)\n\n[1] TRUE\n\n(edad &gt; 18) || (altura &lt; 1.70)\n\n[1] TRUE\n\n!(edad &gt; 18)\n\n[1] FALSE",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-7",
    "href": "capitulos/90_soluciones_01.html#ejercicio-7",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\nRazonamiento paso a paso:\n1 + 2 + (3 + 4) * ((5 * 6 %% 7 * 8) - 9) - 10\n1 + 2 + (3 + 4) * ((5 * 6 * 8) - 9) - 10\n1 + 2 + (3 + 4) * (240 - 9) - 10\n1 + 2 + 7 * 231 - 10\n1 + 2 + 1617 - 10\n1610\nVerificación en R:\n\n1 + 2 + (3 + 4) * ((5 * 6 %% 7 * 8) - 9) - 10\n\n[1] 1610",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-8",
    "href": "capitulos/90_soluciones_01.html#ejercicio-8",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 8",
    "text": "Ejercicio 8\nSiempre es verdadera porque sea cual fuere x, siempre va a ser distinta a alguno de los dos, incluso si es 4, es distinta a 17 y viceversa.\nRecordemos que:\n\n!= significa “distinto de”.\n\n|| es el operador “o” lógico (OR), que devuelve TRUE si al menos una de las condiciones es TRUE.\n\nLuego, de la única forma para que la expresión sea FALSE, es que ambas condiciones sean FALSE al mismo tiempo. Veamos si esto es posible:\n\nLa primera condición (x != 4) es FALSE solo cuando x = 4.\n\nLa segunda condición (x != 17) es FALSE solo cuando x = 17.\n\nPor lo visto, ambas condiciones no pueden ser FALSE simultáneamente, ya que un número no puede ser 4 y 17 al mismo tiempo. Dado que siempre hay al menos una condición que es TRUE, la expresión es siempre verdadera, sin importar el valor de x.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-9",
    "href": "capitulos/90_soluciones_01.html#ejercicio-9",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 9",
    "text": "Ejercicio 9\nEl primer ítem excluye a los años terminados en 00, los cuales son evaluados en la segunda regla. El segundo ítem incluye automáticamente a los divisibles por 4 porque 400 es divisible por 4. Entonces, la operación lógica que determina si un año es bisiesto es: ((año %% 4 == 0) && (año %% 100 != 0)) || (año %% 400 == 0).\nEn R:\n\naño &lt;- 2024\n((año %% 4 == 0) && (año %% 100 != 0)) || (año %% 400 == 0)\n\n[1] TRUE\n\naño &lt;- 2025\n((año %% 4 == 0) && (año %% 100 != 0)) || (año %% 400 == 0)\n\n[1] FALSE",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-10",
    "href": "capitulos/90_soluciones_01.html#ejercicio-10",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 10",
    "text": "Ejercicio 10\n\n¿Cuáles son los valores finales de a y b?\n\n\na &lt;- 10\nb &lt;- a * 2\na &lt;- a + 5\nb &lt;- b - a\na\n\n[1] 15\n\nb\n\n[1] 5\n\n\n\n¿Cuáles son los valores finales de m y n?\n\n\nm &lt;- 5\nn &lt;- 2 * m\nm &lt;- m + 3\nn &lt;- n + m\nm &lt;- n - 4\nm\n\n[1] 14\n\nn\n\n[1] 18\n\n\n\n¿Cuál es el valor final de y?\n\n\nx &lt;- 6\ny &lt;- 2\nx &lt;- x / y + x * y\ny &lt;- x^2 %% 10\ny &lt;- y * 2\ny\n\n[1] 10\n\n\n\n¿Cuál es el valor final de resultado?\n\n\na &lt;- 5\nb &lt;- 2\nc &lt;- 3\n\nresultado &lt;- a^b - (c * b) + (a %% c)\nresultado\n\n[1] 21\n\n\n\n¿Cuáles son los valores finales de x, y y z?\n\n\nx &lt;- 8\ny &lt;- 3\nz &lt;- 2\n\nx &lt;- x %% y + z^y\ny &lt;- (x + y) %/% z\nz &lt;- z + x - y\nx\n\n[1] 10\n\ny\n\n[1] 6\n\nz\n\n[1] 6",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-11",
    "href": "capitulos/90_soluciones_01.html#ejercicio-11",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 11",
    "text": "Ejercicio 11\nSe pueden cambiar los valores de a, b y h.\n\na &lt;- 5\nb &lt;- 4\nh &lt;- 3\nvolumen &lt;- a * b * h\narea &lt;- 2 * (a * b + a * h + b * h)\ncat(\"El área es igual a\", area, \"y el volumen es igual a\", volumen)\n\nEl área es igual a 94 y el volumen es igual a 60",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-12",
    "href": "capitulos/90_soluciones_01.html#ejercicio-12",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 12",
    "text": "Ejercicio 12\n\nPara identificar la ruta informática de un archivo, podés seguir los pasos mostrados en Carpetas, archivos y rutas informáticas.\nSe puede saber cuál es el working directory con:\n\n\ngetwd()",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_01.html#ejercicio-13",
    "href": "capitulos/90_soluciones_01.html#ejercicio-13",
    "title": "Soluciones de la Práctica de la Unidad 1",
    "section": "Ejercicio 13",
    "text": "Ejercicio 13\nEl resultado de crear las carpetas y subcarpetas tiene que ser similar al que se ve en la Figura 5.2. El proyecto se crea desde RStudio siguiendo los pasos de la Figura 5.4.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 1</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html",
    "href": "capitulos/90_soluciones_02.html",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "",
    "text": "Ejercicio 1\n# PROGRAMA: \"Paridad de un número\" \nx &lt;- 3\nif (x %% 2 == 0) {\n    cat(x, \"es par\")\n} else {\n    cat(x, \"es impar\")\n}\n\n3 es impar\nEn el código anterior, realizamos una asignación explícita de un valor en la variable (x &lt;- 3). Esto nos permite hacer un uso más interactivo del código, que puede ser útil para probar si anda o cuando vamos corriendo por partes para detectar posibles errores.\nOtra opción se muestra en el siguiente ejemplo. En lugar de asignarle un valor a x como parte del script, indicamos que cuando el código sea ejecutado, el usuario deberá ingresar un valor con el teclado. Para esto empleamos la función scan(). Su argumento n = 1 significa que el usuario sólo deberá ingresar un número, el cual será asignado a la variable x. Teniendo un archivo de código con el programa como se muestra a continuación, podemos ejecutarlo de forma completa mediante el botón Source de RStudio. Al llegar a la evaluación de scan(), deberemos ingresar el valor que deseemos en la consola y dar Enter para que la ejecución continúe.\n# PROGRAMA: \"Paridad de un número\"\ncat(\"Ingrese un número entero: \")\nx &lt;- scan(n = 1)\nif (x %% 2 == 0) {\n    cat(x, \"es par\")\n} else {\n    cat(x, \"es impar\")\n}",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-2",
    "href": "capitulos/90_soluciones_02.html#ejercicio-2",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\n\n# PROGRAMA: \"Mayor de tres números\"\nx &lt;- 5\ny &lt;- 5\nz &lt;- 7\nif (x &gt;= y && x &gt;= z) {\n    cat(\"El mayor es\", x)\n} else if (y &gt;= z) {\n    cat(\"El mayor es\", y)\n} else {\n    cat(\"El mayor es\", z)\n}\n\nEl mayor es 7\n\n\nObservación: se llega a la segunda evaluación lógica cuando y es mayor a x, o cuando z es mayor que x, o cuando ambos son mayores a x, por lo tanto sólo es necesario saber cuál de ellos es el mayor.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#sec-ejericio-salario",
    "href": "capitulos/90_soluciones_02.html#sec-ejericio-salario",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\n\n# PROGRAMA: \"Determinar salario\"\n\n# Valores fijados\nvalor_hora &lt;- 4000\nvalor_adicional_noche &lt;- 2000\nvalor_adicional_domingo &lt;- 1000\n\n# Valores para un cálculo particular\nhoras &lt;- 8\ndia &lt;- \"MAR\"\nturno &lt;- \"T\"\n\n# Cálculo para el pago de ese día a ese empleado\nsalario &lt;- horas * valor_hora\nif (turno == \"N\") {\n    salario &lt;- salario + horas * valor_adicional_noche\n}\nif (turno == \"DOM\") {\n    salario &lt;- salario + horas * valor_adicional_domingo\n}\ncat(\"El salario que se debe abonar es\", salario)\n\nEl salario que se debe abonar es 32000",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-4",
    "href": "capitulos/90_soluciones_02.html#ejercicio-4",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\n\n# PROGRAMA: \"Convertir temperatura\"\ntemp &lt;- 20\nmodo &lt;- \"C a F\"\nif (modo == \"C a F\") {\n    temp_nuevo &lt;- temp * 9 / 5 + 32\n    cat(temp, \"ºC equivale a\", temp_nuevo, \"ºF\")\n} else {\n    temp_nuevo &lt;- (temp - 32) * 5 / 9\n    cat(temp, \"ºF equivale a\", temp_nuevo, \"ºC\")\n}\n\n20 ºC equivale a 68 ºF",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-5",
    "href": "capitulos/90_soluciones_02.html#ejercicio-5",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\na.\n\n# PROGRAMA: \"Suma de los n primeros números naturales\"\nn &lt;- 10\nsuma &lt;- 0\nfor (i in 1:n) {\n    suma &lt;- suma + i\n}\ncat(\"La suma de los primeros\", n, \"números naturales es\", suma)\n\nLa suma de los primeros 10 números naturales es 55\n\n\nb.\n\n# PROGRAMA: \"Suma de los cuadrados de los n primeros números naturales\" -----\nn &lt;- 10\nsuma &lt;- 0\nfor (i in 1:n) {\n    suma &lt;- suma + i^2\n}\ncat(\"La suma de los primeros\", n, \"números naturales al cuadrado es\", suma)\n\nLa suma de los primeros 10 números naturales al cuadrado es 385\n\n\nc.\nSabemos el número de iteraciones, n, por eso usamos for. Por ejemplo, para n = 4, los primeros impares son:\n1 = 2 * 1 - 1\n3 = 2 * 2 - 1\n5 = 2 * 3 - 1\n7 = 2 * 4 - 1\nDe forma general, los primeros 4 impares son 2 * i - 1, con i = 1, 2, 3, 4.\n\n# PROGRAMA: \"Producto de los n primeros números naturales impares\" ----------\nn &lt;- 10\nproducto &lt;- 1\nfor (i in 1:n) {\n    producto &lt;- producto * (2 * i - 1)\n}\ncat(\"El producto de los primeros\", n, \"números naturales impares es\", producto)\n\nEl producto de los primeros 10 números naturales impares es 654729075\n\n\nOtra forma:\n\n# PROGRAMA: \"Producto de los n primeros números naturales impares\" ----------\nn &lt;- 10\nproducto &lt;- 1\nfor (i in seq(1, 2 * n - 1, 2)) {\n    producto &lt;- producto * i\n}\ncat(\"El producto de los primeros\", n, \"números naturales impares es\", producto)\n\nEl producto de los primeros 10 números naturales impares es 654729075\n\n\nLa función seq crea un vector con una secuencia numérica. El formato con el que está utilizada aquí es seq(valor_inicial, valor_final, intervalo), por lo que creará un vector con los números impares (dado que el intervalo es 2, y comienza con un número impar) empezando desde 1 hasta 2 * n - 1.\nd.\n\n# PROGRAMA: \"Suma de los cubos de los n primeros números naturales pares\"\nn &lt;- 5\nsuma &lt;- 0\nfor (i in 1:n) {\n    suma &lt;- suma + (2 * i)^3\n}\ncat(\"La suma de los cubos de los primeros\", n, \"números naturales pares es\", suma)\n\nLa suma de los cubos de los primeros 5 números naturales pares es 1800",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-6",
    "href": "capitulos/90_soluciones_02.html#ejercicio-6",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\nUtilizando estructura de control “PARA”\n\n# PROGRAMA: \"Calcular el factorial de n\"\nn &lt;- 0\nfactorial &lt;- 1\nfor (i in 1:n) {\n    factorial &lt;- factorial * i\n}\ncat(\"El factorial de\", n, \"es\", factorial)\n\nEl factorial de 0 es 0\n\n\nUtilizando estructura de control “MIENTRAS QUE”\n\n# PROGRAMA: \"Calcular el factorial de n\"\nn &lt;- 0\nfactorial &lt;- 1\ni &lt;- 0\nwhile(i &lt; n) {\n    i &lt;- i + 1\n  factorial &lt;- factorial * i\n}\ncat(\"El factorial de\", n, \"es\", factorial)\n\nEl factorial de 0 es 1\n\n\nIMPORTANTE. Notar que la primera opción no arroja de forma correcta el factorial de 0, que por definición es igual a 1. Se podría agregar alguna estructura condicional para esta situación. La segunda opción, en cambio, funciona también para n &lt;- 0.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-7",
    "href": "capitulos/90_soluciones_02.html#ejercicio-7",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\n\n# PROGRAMA: \"Secuencia de Fibonacci\"\ntermino1 &lt;- 0\ntermino2 &lt;- 1\nwhile (termino1 &lt; 10000) {\n  print(termino1)\n  termino3 &lt;- termino1 + termino2\n  termino1 &lt;- termino2\n  termino2 &lt;- termino3\n}\n\n[1] 0\n[1] 1\n[1] 1\n[1] 2\n[1] 3\n[1] 5\n[1] 8\n[1] 13\n[1] 21\n[1] 34\n[1] 55\n[1] 89\n[1] 144\n[1] 233\n[1] 377\n[1] 610\n[1] 987\n[1] 1597\n[1] 2584\n[1] 4181\n[1] 6765",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-8",
    "href": "capitulos/90_soluciones_02.html#ejercicio-8",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 8",
    "text": "Ejercicio 8\nObservar que:\n\nel valor inicial es el 100 ya que la combinación no comienza por 0.\nel while se detiene cuando la combinación es mayor a 800.\nse verifican las condiciones de multiplicidad, y si no se cumplen, se pasa directamente a la siguiente iteración.\nen caso de que se cumplan las condiciones, se imprime la combinación, y se pasa a la siguiente iteración.\n\n\n# PROGRAMA: \"Lista de posibles combinaciones\"\ncombinacion &lt;- 100\n\nwhile (combinacion &lt;= 800) {\n  if (combinacion %% 11 == 0 && combinacion %% 8 != 0) {\n    print(combinacion)\n  }\n  combinacion &lt;- combinacion + 1\n}\n\n[1] 110\n[1] 121\n[1] 132\n[1] 143\n[1] 154\n[1] 165\n[1] 187\n[1] 198\n[1] 209\n[1] 220\n[1] 231\n[1] 242\n[1] 253\n[1] 275\n[1] 286\n[1] 297\n[1] 308\n[1] 319\n[1] 330\n[1] 341\n[1] 363\n[1] 374\n[1] 385\n[1] 396\n[1] 407\n[1] 418\n[1] 429\n[1] 451\n[1] 462\n[1] 473\n[1] 484\n[1] 495\n[1] 506\n[1] 517\n[1] 539\n[1] 550\n[1] 561\n[1] 572\n[1] 583\n[1] 594\n[1] 605\n[1] 627\n[1] 638\n[1] 649\n[1] 660\n[1] 671\n[1] 682\n[1] 693\n[1] 715\n[1] 726\n[1] 737\n[1] 748\n[1] 759\n[1] 770\n[1] 781",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_02.html#ejercicio-9",
    "href": "capitulos/90_soluciones_02.html#ejercicio-9",
    "title": "Soluciones de la Práctica de la Unidad 2",
    "section": "Ejercicio 9",
    "text": "Ejercicio 9\n\nAl final del primer año, la población será igual a:\n\\[\np0 + p0 \\times \\frac{tasa}{100} + inmigrantes = 1000 + 1000 * 0.02 + 50 = 1070\n\\]\nAl final del 2º año, la población será:\n\\[\np0 + p0 \\times \\frac{tasa}{100} + inmigrantes = 1070 + 1070 * 0.02 + 50 = 1141.4 \\cong 1141\n\\] Recordar que el número de habitantes es un entero, por lo cual tomamos la parte entera.\nAl final del tercer año:\n\\[\np0 + p0 \\times \\frac{tasa}{100} + inmigrantes = 1141 + 1141 * 0.02 + 50 = 1213.82 \\cong 1213\n\\]\nSe necesitarán 3 años.\nHaciendo la solución para el problema de forma más general:\n\n\n# Parámetros a definir\np0 &lt;- 1000\np_objetivo &lt;- 1200\ntasa &lt;- 2 # La expresamos en porcentaje\ninmigrantes &lt;- 50\n\n# Programa\naño &lt;- 0\npoblacion &lt;- p0\nwhile (poblacion &lt; p_objetivo) {\n  # Aplicamos la fórmula y nos quedamos con la parte entera del resultado\n  poblacion &lt;- floor(poblacion + poblacion * tasa / 100 + inmigrantes)\n  # Contamos un año más\n  año &lt;- año + 1\n}\ncat(\n  \" Con una población inicial de\", p0, \n  \"habitantes, una tasa de crecimiento anual del\\n\",\n  tasa, \"% y\", inmigrantes, \"nuevos habitantes anuales, se necesitarán\",\n  año, \"años para alcanzar\\n una población de\", p_objetivo, \n  \"habitantes. Luego del año\", año, \"el pueblo contará con una\\n población de\", \n  poblacion, \"habitantes.\"\n)\n\n Con una población inicial de 1000 habitantes, una tasa de crecimiento anual del\n 2 % y 50 nuevos habitantes anuales, se necesitarán 3 años para alcanzar\n una población de 1200 habitantes. Luego del año 3 el pueblo contará con una\n población de 1213 habitantes.\n\n\n\nCambiamos los valores de las variables y realizamos el cálculo nuevamente:\n\n\n# Parámetros a definir\np0 &lt;- 10000\np_objetivo &lt;- 50000\ntasa &lt;- 3 # La expresamos en porcentaje\ninmigrantes &lt;- 100\n\n# Programa\naño &lt;- 0\npoblacion &lt;- p0\nwhile (poblacion &lt; p_objetivo) {\n  # Aplicamos la fórmula y nos quedamos con la parte entera del resultado\n  poblacion &lt;- floor(poblacion + poblacion * tasa / 100 + inmigrantes)\n  # Contamos un año más\n  año &lt;- año + 1\n}\ncat(\n  \" Con una población inicial de\", p0, \n  \"habitantes, una tasa de crecimiento anual del\\n\",\n  tasa, \"% y\", inmigrantes, \"nuevos habitantes anuales, se necesitarán\",\n  año, \"años para alcanzar\\n una población de\", p_objetivo, \n  \"habitantes. Luego del año\", año, \"el pueblo contará con una\\n población de\", \n  poblacion, \"habitantes.\"\n)\n\n Con una población inicial de 10000 habitantes, una tasa de crecimiento anual del\n 3 % y 100 nuevos habitantes anuales, se necesitarán 47 años para alcanzar\n una población de 50000 habitantes. Luego del año 47 el pueblo contará con una\n población de 50116 habitantes.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 2</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html",
    "href": "capitulos/90_soluciones_03.html",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "",
    "text": "Ejercicio 1",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-1",
    "href": "capitulos/90_soluciones_03.html#ejercicio-1",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "",
    "text": "Escribimos la función y la usamos:\n\n# Función f1\nf1 &lt;- function(x1, x2, x3) {\n  resultado &lt;- x1 / x2 + x3^2 + x2 * x3\n  return(resultado)\n}\n\n# Ejemplo de su uso\nf1(5, 2, 3)\n\n[1] 17.5\n\n\nEscribimos la función y la usamos:\n\n# Función f2\nf2 &lt;- function(x1, x2 = 1, x3 = 1) {\n  resultado &lt;- x1 / x2 + x3^2 + x2 * x3\n  return(resultado)\n}\n\n# Ejemplos de su uso\nf2(5, 2, 3)\n\n[1] 17.5\n\nf2(5)\n\n[1] 7\n\nf2(5, 2)\n\n[1] 5.5\n\nf2(5, x3 = 3)\n\n[1] 17\n\nf2(x2 = 2, x3 = 3)\n\nError in f2(x2 = 2, x3 = 3): argument \"x1\" is missing, with no default\n\n\nEscribimos la función y la usamos:\n\n# Función f3\nf3 &lt;- function(x1, x2 = 1, x3 = 1) {\n  if (x1 &lt; 0 || x2 &lt; 0 || x3 &lt; 0) {\n    return(-100)\n  } else {\n    resultado &lt;- x1 / x2 + x3^2 + x2 * x3\n    return(resultado)\n  }\n}\n\n# Ejemplos de su uso\nf3(5, 2, 3)\n\n[1] 17.5\n\nf3(-5, 2, 3)\n\n[1] -100\n\nf3(-5)\n\n[1] -100\n\nf3(5, x3 = -3)\n\n[1] -100",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-2",
    "href": "capitulos/90_soluciones_03.html#ejercicio-2",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nSin importar el signo de a y b ni cuál es mayor o menor, la secuencia de todos los enteros se puede generar fácilmente con la expresión a:b que usamos como parte de la estructura for:\n\n1:4\n\n[1] 1 2 3 4\n\n4:1\n\n[1] 4 3 2 1\n\n3:3\n\n[1] 3\n\n-2:4\n\n[1] -2 -1  0  1  2  3  4\n\n-2:-8\n\n[1] -2 -3 -4 -5 -6 -7 -8\n\n\nPor lo tanto, si iteramos con un for a través de la secuencia a:b, la función puede definirse así:\n\n#' Suma de una secuencia de números enteros\n#' \n#' @description\n#' Calcula la suma de un rango de números enteros, incluyendo los extremos. \n#' \n#' @param a,b números enteros\n#'\n#' @return suma de la secuencia\n#'\n#' @examples\n#' suma_secuencia(1, 3)\n#' suma_secuencia(-2, 3)\n#' suma_secuencia(-3, -5)\n#' suma_secuencia(3, 3)\n#' \nsuma_secuencia &lt;- function(a, b) {\n  suma &lt;- 0\n  for (i in a:b) {\n    suma &lt;- suma + i\n  }\n  return(suma)\n}\n\nEjemplos de su uso:\n\nsuma_secuencia(1, 3)\n\n[1] 6\n\nsuma_secuencia(30, 40)\n\n[1] 385\n\nsuma_secuencia(5, 2)\n\n[1] 14\n\nsuma_secuencia(-2, 3)\n\n[1] 3\n\nsuma_secuencia(-7, -5)\n\n[1] -18\n\nsuma_secuencia(-3, -5)\n\n[1] -12\n\nsuma_secuencia(-3, -3)\n\n[1] -3\n\nsuma_secuencia(3, 3)\n\n[1] 3",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-3",
    "href": "capitulos/90_soluciones_03.html#ejercicio-3",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\n\n#' Clasificación de un triángulo\n#' \n#' @description\n#' Clasifica a un triángulo según las longitudes de sus lados, en escaleno, isósceles \n#' o equilátero. \n#'\n#' @details \n#' Se evalúa la desigualdad triangular. Si las medidas de los lados no corresponden \n#' a un triángulo, la función devuelve \"no es un triángulo\". \n#' \n#' @param a,b,c números reales positivos\n#'\n#' @return valor carácter que indica el tipo de triángulo.\n#'\n#' @examples\n#' triangulos(2, 3, 4)\n#' triangulos(2, 3, 10)\n#' \ntriangulos &lt;- function(a, b, c) {\n    if (a &gt; b + c || b &gt; a + c || c &gt; a + b) {\n        return(\"no es triángulo\")\n    } else if (a == b & a == c) {\n        return(\"equilátero\")\n    } else if (a == b || a == c || b == c) {\n        return(\"isósceles\")\n    } else {\n        return(\"escaleno\")\n    }\n}\n\nAlternativamente, podemos prescindir de las estructuras anidadas, gracias a la existencia de las sentencias return en cada camino posible. Si alguna condición es TRUE, enseguida se devuelve el valor que corresponda y se detiene la ejecución de la función. El resto no se evalúa, lo cual hace innecesario usar else if o estructuras anidadas:\n\ntriangulos &lt;- function(a, b, c) {\n    if (a &gt; b + c || b &gt; a + c || c &gt; a + b) {\n      return(\"no es triángulo\")\n    }\n    if (a == b & a == c) {\n      return(\"equilátero\")\n    }\n    if (a == b || a == c || b == c) {\n      return(\"isósceles\")\n    }\n    return(\"escaleno\")\n}\n\nEjemplos de uso:\n\ntriangulos(2, 3, 4)\n\n[1] \"escaleno\"\n\ntriangulos(2, 3, 10)\n\n[1] \"no es triángulo\"",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-4",
    "href": "capitulos/90_soluciones_03.html#ejercicio-4",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\n\n#' Punto dentro de la elipse\n#' \n#' @description\n#' Determina si un punto está contenido dentro de la elipse definida por la fórmula \n#' (x - 6)^2 / 36 + (y + 4)^2 / 16 = 1\n#'\n#' @details \n#' Por defecto se evalúa al origen de coordenadas.\n#' \n#' @param x,y coordenadas, números reales. Por defecto valen 0. \n#'\n#' @return valor lógico indicando si el punto está dentro de la elipse descripta.\n#'\n#' @examples\n#' elipse(3, 7)\n#' elipse(6, -4)\n#' elipse()\n#' \nelipse &lt;- function(x = 0, y = 0) {\n  valor &lt;- (x - 6)^2 / 36 + (y + 4)^2 / 16\n    return(valor &lt;= 1)\n}\n\nEjemplos de uso:\n\nelipse(3, 7)\n\n[1] FALSE\n\nelipse(6, -4)\n\n[1] TRUE\n\nelipse()\n\n[1] FALSE",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-5",
    "href": "capitulos/90_soluciones_03.html#ejercicio-5",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nSi bien hay muchas formas de resolver este ejercicio, tal vez usando estructuras iterativas y condicionales, conviene pensarlo desde un punto de vista matemático. La suma de los números impares de la fila \\(n\\) resulta igual a \\(n^3\\). Para darse cuenta, conviene pensar en los siguientes puntos:\n\nLa suma de los primeros \\(n\\) números naturales es: \\(n(n+1)/2\\). Por ejemplo, si \\(n=3\\), \\(1+2+3=6=3*4/2\\).\nLa suma de los primeros \\(n\\) números naturales impares es: \\(n^2\\). Por ejemplo, si \\(n=3\\), \\(1+3+5=9=3^2\\).\nEn la fila \\(i\\), hay exactamente \\(i\\) números impares. Por ejemplo, en la fila \\(i=3\\), hay 3 números: 7, 9 y 11.\nDesde la fila 1 hasta la fila \\(n\\) inclusive, hay \\(n(n+1)/2\\) números impares. En la fila 1 hay 1, en la fila 2 hay 2, etc. Entonces hasta la fila \\(n\\) hay \\(1+2+3+...+n = n(n+1)/2\\) (suma de los primeros \\(n\\) naturales).\nLa suma de los números impares desde la fila 1 hasta la fila \\(n\\) inclusive entonces es igual a la suma de los primeros \\(n(n+1)/2\\) números impares: \\(\\Big(\\frac{n(n+1)}{2}\\Big)^2\\).\nDel mismo modo, la suma de los números impares desde la fila 1 hasta la fila \\(n-1\\) inclusive es igual a la suma de los primeros \\((n-1)n/2\\) números impares: \\(\\Big(\\frac{(n-1)n}{2}\\Big)^2\\).\nComo sólo queremos la suma de los impares que están en la fila \\(n\\), podemos calcular la suma desde la fila 1 hasta la \\(n\\) inclusive, y restarle la suma desde la fila 1 hasta la fila \\(n-1\\) inclusive. El número que buscamos entonces es:\n\n\\[\n\\Big(\\frac{n(n+1)}{2}\\Big)^2 - \\Big(\\frac{(n-1)n}{2}\\Big)^2 = n^3\n\\]\nEl código de la función puede ser sencilamente:\n\n#' Suma de fila de la pirámide\n#' \n#' @description\n#' La pirámide se arma con números impares, empezando con el 1 en la cima, el 3 y 5 \n#' en la segunda fila, y así sucesivamente. Devuelve la suma de los números ubicados \n#' en la fila ingresada.\n#'\n#' @details \n#' Se puede demostrar que la suma de los números en la n-ésima fila es igual a \n#' n al cubo.\n#' \n#' @param n Número natural\n#'\n#' @return suma de los números ubicados en la n-ésima fila de la pirámide.\n#'\n#' @examples\n#' suma_piramide(1)\n#' suma_piramide(2)\n#' suma_piramide(3)\n#' \nsuma_piramide &lt;- function(n) {\n  return(n^3)\n}\n\nEjemplos:\n\nsuma_piramide(1)\n\n[1] 1\n\nsuma_piramide(2)\n\n[1] 8\n\nsuma_piramide(3)\n\n[1] 27\n\n# Evaluamos la suma de cada una de las primeras 10 filas\nfor (n in 1:10) {\n  suma &lt;- suma_piramide(n)\n  cat(\"Los impares de la fila\", n, \"suman\", suma, \"\\n\")\n}\n\nLos impares de la fila 1 suman 1 \nLos impares de la fila 2 suman 8 \nLos impares de la fila 3 suman 27 \nLos impares de la fila 4 suman 64 \nLos impares de la fila 5 suman 125 \nLos impares de la fila 6 suman 216 \nLos impares de la fila 7 suman 343 \nLos impares de la fila 8 suman 512 \nLos impares de la fila 9 suman 729 \nLos impares de la fila 10 suman 1000",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-6",
    "href": "capitulos/90_soluciones_03.html#ejercicio-6",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\n\nPaso a paso:\n\nEn el ambiente global primero se definen las funciones f y g y las variables globales a y b, con los valores 6 y 1, respectivamente.\nSe invoca g(a, b), resultando en que en el ambiente local de g, x recibe el valor 6 e y el valor 1.\nEn el ambiente local de g se crea la variable local b, con valor 6 - 2 * 1 = 4.\nDesde el ambiente local de g se invoca f(b), donde b vale 4.\nEn el ambiente local de f, a recibe el valor 4, el cual es actualizado por (4-10)*(4+10)=-84 para finalmente devolver -84.\nDe regreso en el ambiente local de g, la variable c recibe el valor b*f(b)=4*f(4)=4*(-84)=-336 y se devuelve -336.\nPara definir la variable d se vuelve a invocar f esta vez sin argumentos explícitos, por lo que en el ambiente local de f, a recibe el valor 10 y f() = 0. El valor final de d es f() - c = 0 - (-336) = 336.\nEn el ambiente global entonces el resultado de g(a, b) es 336.\n\nEn este ejemplo, el identificador a representa dos variables distintas: una de ellas definida en el Global Environment y la otra en el ámbito local de la función f1. Lo mismo ocurre con x: representa a una variable en el ambiente global, a otra en el ambiente de la función f1 y a una tercera en el ambiente de la función f2. Al ejecutar el algoritmo se obtendrían los siguientes resultados:\n\nEn el ambiente global, se definen las funciones f1 y f2 y las variables x e y con valores: x = 3 e y = 5.\nDesde el ambiente global, se invoca a la función f1, donde el parámetro formal a recibe el valor del parámetro real x (a = 3), mientras que el parámetro formal b recibe el valor del parámetro real y (b = 5). Dentro de la función f1:\n\nSe crea una nueva variable x que recibe el valor x = a + b = 8. Esta x no tiene nada que ver con la del ambiente global.\nSe crea una nueva variable y que recibe el valor y = x + 2 = 8 + 2 = 10. Esta y no tiene nada que ver con la del ambiente global.\nLa función devuelve el valor y = 10.\n\nEn el ambiente global, se le asigna a la variable a el valor recién devuelto: a = 10. Esta a no tiene nada que ver con la variable local de la función f1.\nDesde el ambiente global, se llama a la función f2, donde el parámetro formal x recibe el valor del parámetro real a (x = 10). Esta x no tiene nada que ver con las anteriores. Dentro de la función f2:\n\nSe calcula el cuadrado de x: \\(10^2\\) = 100\nSe devuelve el valor 100.\n\nEn el ambiente global, se suma x + f2(a) = 3 + 100 = 103 y se asigna este valor a z.\nEl algoritmo escribe el valor de z, 103.\nEl algoritmo intenta escribir a + b = 10 + ?, pero produce error, puesto que b no está definida en el ambiente global, no tiene asignado ningún valor. La única variable b que existe está en el ámbito de la función f1, no en el Global Environment.\n\nPrimero, en el ambiente global se define la función f con tres argumentos: x (sin valor por defecto), y y z (opcionales). La función devuelve una combinación lineal de estas tres cantidades. En segundo lugar, se invoca sucesivamente la función f para definir cuatro variables globales en el siguiente orden:\n\na = f(10) = f(10, 5, 10 + 5) = (10+5) - 10 - 5 = 0\nb = f(10, 10) = f(10, 10, 10 + 10) = (10+10) - 10 - 10 = 0\nc = f(10, 10, 10) = 10 - 10 - 10 = -10\nd = f(10, z = 10) = f(10, 5, 10) = 10 - 10 - 5 = -5\n\nFinalmente, se imprime el resultado de sumar las cuatro cantidades: 0 + 0 - 10 - 5 = -15",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-7",
    "href": "capitulos/90_soluciones_03.html#ejercicio-7",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\nHemos definido a las funciones como subalgoritmos que devuelven un objeto. En este caso no nos interesa devolver nada, sino sólo escribir mensajes en la consola, por eso podemos omitir el uso de return():\n\n#' Resolviendo ecuaciones de segundo grado\n#' \n#' @description\n#' Encuentra las soluciones de una ecuación de segundo grado a partir del uso de\n#' la formula resolvente. Se deben ingresar los coeficientes del polinomio de \n#' segundo grado asociado. \n#'\n#' @details \n#' La función imprime un mensaje con el detalle de las soluciones, incluyendo si \n#' esta ecuación tiene dos soluciones distintas, una solución doble o ninguna \n#' solución dentro de los números reales. La función devuelve un mensaje de error \n#' si el coeficiente cuadrático es 0. \n#' \n#' @param a,b,c Números reales\n#'\n#' @return NULL, junto con un mensaje con el detalle de las soluciones.\n#'\n#' @examples\n#' resolvente(1, -1, -2)\n#' resolvente(1, 2, 1)\n#' resolvente(1, 1, 1)\n#' resolvente(0, 1, 1)\n#' \nresolvente &lt;- function(a, b, c) {\n  if (a == 0) {\n    stop(\"(a) debe ser distinto de cero\")\n  }\n  discriminante &lt;- b^2 - 4 * a * c\n  if (discriminante &gt; 0) {\n    x1 &lt;- (-b - sqrt(discriminante)) / (2 * a)\n    x2 &lt;- (-b + sqrt(discriminante)) / (2 * a)\n    cat(\"Hay dos soluciones reales\", x1, \"y\", x2, \"\\n\")\n  } else if (discriminante == 0) {\n    x1 &lt;- -b / (2 * a)\n    cat(\"Hay una solución real doble:\", x1, \"\\n\")\n  } else {\n    cat(\"Las soluciones son complejas.\\n\")\n  }\n}\n\nEjemplo de uso:\n\nresolvente(1, -1, -2)\n\nHay dos soluciones reales -1 y 2 \n\nresolvente(1, 2, 1)\n\nHay una solución real doble: -1 \n\nresolvente(1, 1, 1)\n\nLas soluciones son complejas.\n\nresolvente(0, 1, 1)\n\nError in resolvente(0, 1, 1): (a) debe ser distinto de cero\n\n\nComentarios adicionales. Como hemos mencionado, cuando no se incluye un return(), igualmente la función devuelve algo, que es el resultado de la última expresión ejecutada. En todas las situaciones, en esta función la última expresión ejecutada es un cat(). Además de escribir un texto, esta función devuelve un valor NULL invisible (no se imprime en la consola, pero está). Podemos corrobar este comportamiento si usamos la función de esta forma:\n\n# Imprime texto en la consola y devuelve un NULL, que se guarda enresultado\nresultado &lt;- resolvente(1, -1, -2)\n\nHay dos soluciones reales -1 y 2 \n\n# Imprimimos resultado y encontramos que tiene guardado un NULL\nresultado\n\nNULL\n\n\nSería interesante que esta función pueda devolver las soluciones. Hasta acá sabemos que las funciones pueden devolver un único objeto. Esto puede ser un inconveniente para este problema, ya que nos interesa devolver dos valores (dos soluciones reales), un valor (una solución real doble) o ningún valor (ninguna solución real). Más adelante veremos cómo hacer para poder devolver distinta cantidad de objetos, agrupándolos en otra estructura de datos.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-8",
    "href": "capitulos/90_soluciones_03.html#ejercicio-8",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 8",
    "text": "Ejercicio 8\nLa solución propone chequear primeramente que el número de entrada sea entero y positivo. Si detecta que una de estos requisitos no se cumple, emite un warning y devuelve FALSE.\nEn caso de que se cumplan estos requisitos, el programa directamente devuelve TRUE si el número analizado es 2 o 3, ya que sabemos que estos primeros naturales son primos. Para el resto de los números, divide a n por todos los naturales desde el 2 hasta n - 1. Si al hacer esta división, encuentra un resto igual a cero, significa que n es compuesto. Si ninguna división produce resto cero, entonces n es primo.\nPor ejemplo, para n = 7, se hace:\n\n7 %% 2 = 1, sigue.\n7 %% 3 = 1, sigue.\n7 %% 4 = 3, sigue.\n7 %% 5 = 2, sigue.\n7 %% 6 = 1, termina la iteración.\nDado que no se encontraron divisores para 7, es un número primo, se devuelve TRUE\n\nPara n = 9, se hace:\n\n9 %% 2 = 1, sigue.\n9 %% 3 = 0, devuelve FALSO.\nDado que se encontró que 9 es múltiplo de 3, no es un número primo y se devolvió FALSE.\n\n\n#' Evaluación de números primos\n#' \n#' @description\n#' Determina si un número entero es primo o no. \n#'\n#' @details \n#' La función devuelve un mensaje de advertencia si no se ingresa un número natural \n#' mayor que 1. El resultado en este caso será FALSO.\n#' \n#' @param n Número natural\n#'\n#' @return Un valor lógico, TRUE si el número es primo, FALSE si no lo es.\n#'\n#' @examples\n#' es_primo(47)\n#' es_primo(253)\n#' es_primo(2)\n#' \nes_primo &lt;- function(n) {\n  if (n %% 1 != 0) {\n    warning(\"(n) no es entero\")\n    return(FALSE)\n  }\n  \n  if (n &lt;= 1) {\n    warning(\"(n) no es mayor a 1\")\n    return(FALSE)\n  }\n  \n    if (n &gt; 3) {\n        for (i in 2:(n - 1)) {\n            if (n %% i == 0) {\n                return(FALSE)\n            }\n        }\n    }\n  \n  # solo se llega acá si no se devolvió FALSE antes, es decir, si n es primo\n    return(TRUE)\n}\n\nEjemplos de uso:\n\nes_primo(47)\n\n[1] TRUE\n\nes_primo(253)\n\n[1] FALSE\n\nes_primo(2)\n\n[1] TRUE\n\nes_primo(7.18)\n\nWarning in es_primo(7.18): (n) no es entero\n\n\n[1] FALSE\n\nes_primo(0)\n\nWarning in es_primo(0): (n) no es mayor a 1\n\n\n[1] FALSE\n\n\nObservación: se puede plantear un algoritmo más eficiente, que realice menos iteraciones. No es necesario iterar hasta n - 1, si no hasta el entero inmediato menor a \\(\\sqrt{n}\\). Si no se encontró que n sea múltiplo de ningún valor menor a \\(\\sqrt{n}\\), tampoco lo será con los que siguen. Por otro lado, sería suficiente hacer las divisiones con respecto a los números primos menores \\(\\sqrt{n}\\). Se deja propuesto elaborar esta solución alternativa.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-9",
    "href": "capitulos/90_soluciones_03.html#ejercicio-9",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 9",
    "text": "Ejercicio 9\nPara poder resolver una división usando solamente sumas y restas, tenemos que pensar que, por ejemplo, hacer 14 dividido 3 nos da cociente 4 y resto 2, porque el 3 “entra” 4 veces en el 14 y todavía sobran 2. Es decir, a 14 le podemos restar el 3 cuatro veces hasta que ya no se lo podamos restar más, quedando un resto de 2. Entonces la idea es empezar diciendo que el resto es el dividendo (al principio, nos resta todo el dividendo) y restarle iterativamente el valor del divisor hasta que el resto se haga menor que el divisor. Mientras tanto, tenemos que ir contando cuántas restas se hacen, puesto que eso será el valor del cociente. Ejemplo:\n\ndividendo = 14, divisor = 3, resto = 14.\n14 - 3 = 11, digo que el resto es 11 y cuento que ya hice una resta con cociente = 1.\n11 - 3 = 8, digo que el resto es 8 y cuento que ya hice dos restas con cociente = 2.\n8 - 3 = 5, digo que el resto es 5 y cuento que ya hice tres restas con cociente = 3.\n5 - 3 = 2, digo que el resto es 2, cuento que ya hice cuatro restas con cociente = 4.\nComo ya obtuve un resto menor que el divisor, me detengo, con este resultado: cociente = 4 y resto = 2.\n\nComo a priori no sabemos cuántas iteraciones de este proceso tenemos que hacer, empleamos un while.\n\n#' Cociente de la división de números naturales\n#' \n#' @description\n#' Obtiene el cociente entero y el resto en la división de dos números naturales\n#'\n#' @details \n#' La función imprime un mensaje con todos los detalles de la división, con el \n#' dividendo, divisor, cociente y resto. Sin embargo, la función devuelve solo el \n#' cociente entero. \n#' \n#' @param dividendo,divisor Números naturales.\n#'\n#' @return El cociente entero de la división de ambos números.\n#'\n#' @examples\n#' cociente(1253, 4)\n#' cociente(3, 4)\n#' \ncociente &lt;- function(dividendo, divisor) {\n    resto &lt;- dividendo\n    cociente &lt;- 0\n    while (resto &gt;= divisor) {\n        cociente &lt;- cociente + 1\n        resto &lt;- resto - divisor\n    }\n    cat(\"Dividendo:\", dividendo, \"\\n\")\n    cat(\"Divisor:\", divisor, \"\\n\")\n    cat(\"Cociente:\", cociente, \"\\n\")\n    cat(\"Resto:\", resto, \"\\n\")\n    return(cociente)\n}\n\nEjemplos de uso:\n\ncociente(1253, 4)\n\nDividendo: 1253 \nDivisor: 4 \nCociente: 313 \nResto: 1 \n\n\n[1] 313\n\ncociente(3, 4)\n\nDividendo: 3 \nDivisor: 4 \nCociente: 0 \nResto: 3 \n\n\n[1] 0",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-10",
    "href": "capitulos/90_soluciones_03.html#ejercicio-10",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 10",
    "text": "Ejercicio 10\n\n#' Cálculo del máximo común divisor\n#' \n#' @description\n#' Calcula el máximo común divisor entre dos números naturales\n#'\n#' @details \n#' Aplica el algoritmo de Euclides para encontrar el MCD. Dividir al mayor por el \n#' menor y registrar el resto. Si el resto es cero, el divisor es el MCD. Si el \n#' resto no es cero, hay que dividir el divisor por el resto y hacer la misma \n#' evaluación. Es decir, el divisor pasa a ser el nuevo dividendo y el resto, el \n#' nuevo divisor. Así hasta obtener el resto cero y tener el MCD. \n#' \n#' @param a,b Números naturales.\n#'\n#' @return El máximo común divisor de ambos números.\n#'\n#' @examples\n#' max_com_div(100, 24)\n#' max_com_div(25, 100)\n#' max_com_div(24, 24)\n#' \nmax_com_div &lt;- function(a, b) {\n  \n    # Establecer como dividendo al mayor y como divisor al menor\n    if (a &gt; b) {\n        dividendo &lt;- a\n        divisor &lt;- b\n    } else {\n        dividendo &lt;- b\n        divisor &lt;- a\n    }\n  \n    # Iniciar al resto como igual al dividendo\n    resto &lt;- dividendo\n    \n    # Aplicar algortimo de Euclides\n    while (resto != 0) {\n      \n      # Dividir al mayor por el menor y registrar el resto\n        resto &lt;- dividendo %% divisor\n        \n        # Si el resto es cero (lo chequearemos en la condición del while), el \n        # divisor es el mcd, por las dudas nos preparamos para entregarlo.\n        mcd &lt;- divisor\n        \n        # Si el resto no es cero (lo chequearemos en la condición del while), hay\n        # que dividir el divisor por el resto y hacer la misma evaluación. Es decir,\n        # el divisor pasa a ser el nuevo dividendo y el resto, el nuevo divisor\n        dividendo &lt;- divisor\n        divisor &lt;- resto\n    }\n    \n    # Devolver mcd\n    return(mcd)\n}\n\nEjemplos de uso:\n\nmax_com_div(100, 24)\n\n[1] 4\n\nmax_com_div(25, 100)\n\n[1] 25\n\nmax_com_div(24, 24)\n\n[1] 24\n\n\nOtra forma:\n\nmax_com_div &lt;- function(a, b) {\n    # Establecer como dividendo al mayor y como divisor al menor\n    if (a &gt; b) {\n        dividendo &lt;- a\n        divisor &lt;- b\n    } else {\n        dividendo &lt;- b\n        divisor &lt;- a\n    }\n    # Iniciar al resto como igual al dividendo\n    resto &lt;- dividendo\n    # Aplicar algortimo de Euclides\n    while (resto &gt; 0) {\n        resto &lt;- dividendo %% divisor\n        if (resto == 0) return(divisor)\n        dividendo &lt;- divisor\n        divisor &lt;- resto\n    }\n}",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-11",
    "href": "capitulos/90_soluciones_03.html#ejercicio-11",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 11",
    "text": "Ejercicio 11\n\nEn el script funciones_unidad3.R se implementa la función combinatorio(m,n) y se guarda junto con fact(). Su contenido debe ser:\n\n# ---------------------------------------------------------------\n# DEFINICIÓN DE FUNCIONES (funciones.R)\n# ---------------------------------------------------------------\n\n#' Cálculo de factoriales\n#' \n#' @description\n#' Calcula el factorial de números enteros no negativos.\n#'\n#' @details \n#' Produce un error si se quiere calcular el factorial de un número negativo.\n#' \n#' @param n Número entero no negativo para el cual se calcula el factorial.\n#'\n#' @return El factorial de n.\n#'\n#' @examples\n#' fact(5)\n#' fact(0)\n#' \nfact &lt;- function(n) {\n  if (n &lt; 0 || n != floor(n)) {\n    stop(\"n debe ser entero no negativo.\")\n  }\n  resultado &lt;- 1\n  if (n &gt; 0) {\n      for (i in 1:n) {\n          resultado &lt;- resultado * i\n      }\n  }\n  return(resultado)\n}\n\n#' Cálculo de números combinatorios\n#' \n#' @description\n#' Calcula números combinatorios invocando a la función fact()\n#'\n#' @param m,n números naturales\n#'\n#' @return El número combinatorio m en n\n#'\n#' @examples\n#' combinatorio(3, 1)\n#' \ncombinatorio &lt;- function(m, n) {\n    return(fact(m) / (fact(m - n) * fact(n)))\n}\n\nEl contenido del script ejercicio11.R puede ser:\n\n# ---------------------------------------------------------------\n# PROGRAMA: \"Ejemplificar propiedades de los nros combinatorios\"\n# ---------------------------------------------------------------\n\n# Cargar funciones\nsource(\"funciones_unidad3.R\")\n\n\ncat(\"Propiedad 1: C(m, 0) = 1. Ejemplo:\\n\")\nres1 &lt;- combinatorio(5, 0)\ncat(\"C(5, 0) =\", res1, \"\\n\\n\")\n\ncat(\"Propiedad 2: C(m, m) = 1. Ejemplo:\\n\")\nres1 &lt;- combinatorio(5, 5)\ncat(\"C(5, 5) =\", res1, \"\\n\\n\")\n\ncat(\"Propiedad 3: C(m, 1) = m. Ejemplo:\\n\")\nres1 &lt;- combinatorio(5, 1)\ncat(\"C(5, 1) =\", res1, \"\\n\\n\")\n\ncat(\"Propiedad 4: C(m, n) = C(m, m-n). Ejemplo:\\n\")\nres1 &lt;- combinatorio(5, 2)\nres2 &lt;- combinatorio(5, 3)\ncat(\"C(5, 2) =\", res1, \"\\n\")\ncat(\"C(5, 3) =\", res2, \"\\n\\n\")\n\ncat(\"Propiedad 5: C(m, n) = C(m-1, n-1) + C(m-1, n). Ejemplo:\\n\")\nres1 &lt;- combinatorio(5, 2)\nres2 &lt;- combinatorio(4, 1) + combinatorio(4, 2)\ncat(\"C(5, 2) =\", res1, \"\\n\")\ncat(\"C(4, 1) + C(4, 2) =\", res2)\n\nPropiedad 1: C(m, 0) = 1. Ejemplo:\nC(5, 0) = 1 \n\nPropiedad 2: C(m, m) = 1. Ejemplo:\nC(5, 5) = 1 \n\nPropiedad 3: C(m, 1) = m. Ejemplo:\nC(5, 1) = 5 \n\nPropiedad 4: C(m, n) = C(m, m-n). Ejemplo:\nC(5, 2) = 10 \nC(5, 3) = 10 \n\nPropiedad 5: C(m, n) = C(m-1, n-1) + C(m-1, n). Ejemplo:\nC(5, 2) = 10 \nC(4, 1) + C(4, 2) = 10\n\n\nA continuación, se prueba pasando un valor de n mayor que m:\n\ncombinatorio(4, 5)\n\nError in fact(m - n): n debe ser entero no negativo.\n\n\nComo se observa, la función falla porque internamente se invoca a la función fact() con un número negativo, y la misma fue programada para disparar un error en ese caso. El mensaje n debe ser entero no negativo no es demasiado claro, dado que es emitido por la función fact() y se refiere a su argumento n, no al n de combinatorio(). Podríamos mejorar esta situación de varias formas. Una de ellas podría ser disparar un error antes, dentro de la función combinatorio(), para evitar cualquier procesamiento si \\(n&gt;m\\):\n\ncombinatorio &lt;- function(m, n) {\n  if (n &gt; m) {\n    stop(\"m debe ser menor o igual que n \")\n  }\n    return(fact(m) / (fact(m - n) * fact(n)))\n}\n\nSe generaliza la función combinatorio(m, n) para calcular números combinatorios con y sin reposición. Para esto se incluye el argumento r, que toma el valor lógico TRUE si el cálculo es con reposición o FALSE en caso contrario.\nAgregamos lo siguiente al archivo unidad3_funciones.R. Notar que esta vez no usamos return(), pero igualmetne se devuelve el resultado deseado por ser lo último que se evalúa:\n\n#' Cálculo de números combinatorios \n#' \n#' @description\n#' Calcula el número combinatorio m en n, con o sin reposición según r\n#'\n#' @param m,n números naturales\n#' @param r valor lógico, sobre si el cálculo es con o sin repetición, F por defecto\n#'\n#' @return El número combinatorio m en n, con o sin reposición\n#'\n#' @examples\n#' combinatorio2(10, 2, TRUE)\n#' combinatorio2(10, 2)\n#' \ncombinatorio2 &lt;- function(m, n, r = FALSE) {\n  if (r) {\n    combinatorio(m + n - 1, n)\n  } else {\n    combinatorio(m, n)\n  }\n}\n\nEn el script ejercicio_11.R probamos la nueva función:\n\n# Números combinatorios con y sin reposición\n\nm &lt;- 5\nn &lt;- 2\ncat(m, \"tomados de a\", n, \"sin resposición:\", combinatorio2(m, n), \"\\n\")\ncat(m, \"tomados de a\", n, \"con resposición:\", combinatorio2(m, n, TRUE))\n\n5 tomados de a 2 sin resposición: 10 \n5 tomados de a 2 con resposición: 15\n\n\nLa cantidad de combinaciones con reposición siempre es mayor, salvo para n = 1 donde ambas coinciden.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_03.html#ejercicio-12",
    "href": "capitulos/90_soluciones_03.html#ejercicio-12",
    "title": "Soluciones de la Práctica de la Unidad 3",
    "section": "Ejercicio 12",
    "text": "Ejercicio 12\nLa documentación se ha incluido en cada una de las respuestas anteriores.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 3</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html",
    "href": "capitulos/90_soluciones_04.html",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "",
    "text": "Ejercicio 1\nLos scripts propuestos como solución a los problemas de esta práctica pueden ser descargados desde este archivo comprimido.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html#ejercicio-1",
    "href": "capitulos/90_soluciones_04.html#ejercicio-1",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "",
    "text": "Dirigirse a la carpeta unidad_4\\, crear allí la carpeta principal organizacion_usuarios y entrar en ella:\ncd ~tu_ruta\\unidad_4\nmkdir organizacion_usuarios\ncd organizacion_usuarios\nCrear las tres subcarpetas:\nmkdir registrados temporales_abril historial\nPara crear usuarios registrados, primero moverse a la carpeta registrados usando cd y luego crear los archivos:\ncd registrados\n\necho IP: 192.168.1.1 &gt; ABC1234A_R.txt\necho Usuario: juanperez &gt;&gt; ABC1234A_R.txt\necho Email: juanperez@email.com &gt;&gt; ABC1234A_R.txt\n\necho IP: 192.168.1.2 &gt; DEF5678B_R.txt\necho Usuario: marialopez &gt;&gt; DEF5678B_R.txt\necho Email: marialopez@email.com &gt;&gt; DEF5678B_R.txt\n\necho IP: 192.168.1.3 &gt; GHI9012C_R.txt\necho Usuario: carlosgomez &gt;&gt; GHI9012C_R.txt\necho Email: carlosgomez@email.com &gt;&gt; GHI9012C_R.txt\nNotar el uso de &gt;&gt; para que el contenido a escribir se agregue como una línea nueva en el archivo, sin sobreescribir lo anterior.\nPara crear usuarios temporales primero usar cd .. para volver a la carpeta organizacion_usuarios y de allí meterse a temporales_abril, para crear los archivos correspondientes:\ncd ..\\temporales_abril\n\necho IP: 192.168.2.1 &gt; JKL3456D_T.txt\necho Nombre: invitado01 &gt;&gt; JKL3456D_T.txt\n\necho IP: 192.168.2.2 &gt; MNO7890E_T.txt\necho Nombre: invitado02 &gt;&gt; MNO7890E_T.txt\n\necho IP: 192.168.2.3 &gt; PQR1234F_T.txt\necho Nombre: invitado03 &gt;&gt; PQR1234F_T.txt\nSupongamos que el usuario temporal MN34OP56_T.txt se ha registrado, debemos copiar el archivo del usuario a la carpeta registrados. Para eso primero volvemos a la carpeta principal organizacion_usuarios con cd .. y luego copiamos el archivo del usuario desde la carpeta temporales_abril hacia la carpeta registrados:\ncd ..\ncopy temporales_abril\\MN34OP56_T.txt registrados\nEliminar el archivo original de la carpetatemporales_abril:\ndel temporales_abril\\MN34OP56_T.txt\nEditar el archivo copiado en registrados para agregar datos (nombre de usuario e email):\necho Usuario: federicoruiz &gt;&gt; registrados/MN34OP56_T.txt\necho Email: federico@email.com &gt;&gt; registrados/MN34OP56_T.txt\nRenombrar el archivo con sufijo _R:\nrename registrados\\MN34OP56_T.txt MN34OP56_R.txt\nMostrar contenido actualizado:\ntype registrados\\MN34OP56_R.txt\nCopiar a la carpeta historial historial cada uno de los archivos de la carpeta temporales_abril. Usamos * para copiar todos los archivos que existen (otra ocpión es hacerlo uno por uno, escribiendo su nombre y usando el comando copy varias veces):\ncopy temporales_abril\\* historial\nEliminar la carpeta temporales_abril y crear temporales_mayo:\nrmdir /s /q temporales\\temporales_abril\nmkdir temporales\\temporales_mayo\nNota: en el comando rmdir la opción /s elimina la carpeta y todos sus contenidos (subcarpetas y archivos), mientras que /q omite la confirmación de eliminación, lo que hace que el comando se ejecute sin preguntarle al usuario si está seguro de eliminar.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html#ejercicio-2",
    "href": "capitulos/90_soluciones_04.html#ejercicio-2",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nUna posible solución para este problema es incuir el siguiente contenido en el archivo menu.R:\n\nopcion &lt;- 0\n\nwhile (opcion != 3) {\n  cat(\"\\n=== MENÚ PRINCIPAL ===\\n\\n\")\n  cat(\"1. Saludar\\n\")\n  cat(\"2. Mostrar hora actual\\n\")\n  cat(\"3. Salir\\n\\n\")\n  cat(\"Elegí una opción: \")\n  \n  opcion &lt;- scan(file = \"stdin\", what = integer(), n = 1, quiet = TRUE)\n  \n  if (opcion == 1) {\n    cat(\"\\nIngresá tu nombre: \")\n    nombre &lt;- scan(file = \"stdin\", what = character(), n = 1, quiet = TRUE)\n    cat(\"¡Hola, \", nombre, \"!\\n\", sep = \"\")\n    \n  } else if (opcion == 2) {\n    hora &lt;- format(Sys.time(), \"%H:%M:%S\")\n    cat(\"\\nLa hora actual es:\", hora, \"\\n\")\n    \n  } else if (opcion == 3) {\n    cat(\"\\nIngresá tu nombre para despedirte: \")\n    nombre &lt;- scan(file = \"stdin\", what = character(), n = 1, quiet = TRUE)\n    cat(\"¡Chau, \", nombre, \"!\\n\", sep = \"\")\n    \n  } else {\n    cat(\"\\nOpción inválida. Probá de nuevo.\\n\")\n  }\n}\n\ny ejecutarlo con:\nRscript menu.R",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html#ejercicio-3",
    "href": "capitulos/90_soluciones_04.html#ejercicio-3",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nEl contenido del script evaluar_pelicula.R puede ser:\n\ncat(\"\\n===============================================\\n\")\ncat(\"\\n      SISTEMA DE EVALUACIÓN DE PELÍCULAS\\n\")\ncat(\"\\n===============================================\\n\\n\")\n\ncat(\"Ingrese la cantidad de jueces en el grupo:\\n\")\nn &lt;- scan(file = \"stdin\", what = integer(), n = 1, quiet = TRUE)\n\nif (n &lt; 3 || n &gt; 6) {\n  cat(\"Cantidad inválida de jueces. Debe ser entre 3 y 6.\\n\")\n} else {\n  cat(\"\\nIngrese el nombre de la película:\\n\")\n  nombre &lt;- scan(file = \"stdin\", what = character(), n = 1, quiet = TRUE, sep = \"*+-\")\n  # Nota: scan separa el input donde ve espacios en blanco, para que no lo haga\n  # cambiamos el valor que tiene en su argumento sep, poniendo cualquier cosa\n  # que esperamos que nunca aparezca en un nombre de película, para que ningún\n  # nombre sea nunca separado.\n  suma &lt;- 0\n  for (i in 1:n) {\n    cat(\"\\nIngrese la calificación del juez \", i, \":\\n\", sep = \"\")\n    nota &lt;- scan(file = \"stdin\", what = numeric(), n = 1, quiet = TRUE)\n    while (nota &lt; 0 || nota &gt; 10) {\n      cat(\"Calificación inválida. Las calificaciones deben ser entre 1 y 10.\\nIngrésela nuevamente:\\n\")\n      nota &lt;- scan(file = \"stdin\", what = numeric(), n = 1, quiet = TRUE)\n    }\n    suma &lt;- suma + nota\n  }\n  promedio &lt;- suma / n\n  cat(\n    \"\\nLa clasificación promedio para la película &lt;\", nombre, \"&gt; es \",\n    round(promedio, 2), \" puntos.\\n\\n\", sep = \"\"\n  )\n}\n\nDebe ser ejecutado con:\nRscript evaluar_pelicula.R",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html#ejercicio-4",
    "href": "capitulos/90_soluciones_04.html#ejercicio-4",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\n\nVersión con intentos ilimitados. El contenido del script puede ser:\n\ncat(\"\\n==================================================\\n\")\ncat(\"\\n  BIENVENIDO/A AL AULA VIRTUAL DE PROGRAMACIÓN 1  \\n\")\ncat(\"\\n==================================================\\n\\n\")\n\ncontrasenia_correcta &lt;- \"amoprogramar\"\ningresada &lt;- \"\"\n\nwhile (ingresada != contrasenia_correcta) {\n  cat(\"\\nIngrese la contraseña:\\n\")\n  ingresada &lt;- scan(file = \"stdin\", what = character(), n = 1, quiet = TRUE)\n  if (ingresada != contrasenia_correcta) {\n    cat(\"Contraseña incorrecta. Ingrésela nuevamente.\\n\")\n  }\n}\n\ncat(\"\\n¡Contraseña correcta! Puede ingresar y continuar con sus estudios.\\n\\n\")\n\nVersión con intentos limitados (5 intentos). El contenido del script puede ser:\n\ncat(\"\\n==================================================\\n\")\ncat(\"\\n  BIENVENIDO/A AL AULA VIRTUAL DE PROGRAMACIÓN 1  \\n\")\ncat(\"\\n==================================================\\n\\n\")\n\ncontrasenia_correcta &lt;- \"amoprogramar\"\ningresada &lt;- \"\"\nintentos_restantes &lt;- 5\n\nwhile (intentos_restantes &gt; 0 && ingresada != contrasenia_correcta) {\n  cat(\"\\nIngrese la contraseña:\\n\")\n  ingresada &lt;- scan(file = \"stdin\", what = character(), nmax = 1, quiet = TRUE)\n\n  if (ingresada != contrasenia_correcta) {\n    intentos_restantes &lt;- intentos_restantes - 1\n    if (intentos_restantes &gt; 0) {\n      cat(\"Contraseña incorrecta. Intentos restantes:\", intentos_restantes, \"\\n\")\n    } else {\n      cat(\"\\nDemasiados intentos fallidos. Su cuenta ha sido bloqueada.\\n\\n\")\n    }\n  }\n}\n\nif (ingresada == contrasenia_correcta) {\n  cat(\"\\n¡Contraseña correcta! Puede ingresar y continuar con sus estudios.\\n\\n\")\n}",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html#ejercicio-5",
    "href": "capitulos/90_soluciones_04.html#ejercicio-5",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nEl contenido del script resolvente.R puede ser:\n\n# Mensaje de bienvenida\ncat(\"=========================================\\n\")\ncat(\"  Calculadora de ecuaciones cuadráticas\\n\")\ncat(\"=========================================\\n\\n\")\n\n# Leer coeficientes desde la terminal\ncat(\"Ingrese el valor del coeficiente 'a':\\n\")\na &lt;- scan(file = \"stdin\", n = 1, quiet = TRUE)\nif (a == 0) {\n  stop(\"El coeficiente 'a' debe ser distinto de cero. Fin del programa.\\n\")\n}\ncat(\"Ingrese el valor del coeficiente 'b':\\n\")\nb &lt;- scan(file = \"stdin\", n = 1, quiet = TRUE)\ncat(\"Ingrese el valor del coeficiente 'c':\\n\")\nc &lt;- scan(file = \"stdin\", n = 1, quiet = TRUE)\n\n# Mostrar la ecuación de forma legible\necuacion &lt;- paste0(a, \"x²\", ifelse(b &lt; 0, \"\", \"+\"), b, \"x\", ifelse(c &lt; 0, \"\", \"+\"), c, \"=0\")\ncat(\"\\nEcuación ingresada: \", ecuacion, \"\\n\")\n\n# Calcular el discriminante\nD &lt;- b^2 - 4 * a * c\ncat(\"Discriminante (D):\", round(D, 3), \"\\n\")\n\n# Calcular soluciones\nif (D &gt; 0) {\n  x1 &lt;- (-b - sqrt(D)) / (2 * a)\n  x2 &lt;- (-b + sqrt(D)) / (2 * a)\n  cat(\"Existen dos soluciones reales distintas:\\n\")\n  cat(\"x₁ =\", round(x1, 3), \", x₂ =\", round(x2, 3), \"\\n\")\n} else if (D == 0) {\n  x &lt;- -b / (2 * a)\n  cat(\"Existe una única solución real (raíz doble):\\n\")\n  cat(\"x =\", round(x, 3), \"\\n\")\n} else {\n  cat(\"Las soluciones son complejas (no reales).\\n\")\n}\n\n# Mensaje de despedida\ncat(\"\\nGracias por usar la calculadora de ecuaciones cuadráticas.\\n\")\n\nObservaciones:\n\nLa función ifelse() permite implementar en una sola línea una estructura if-else sencilla. El primer argumento es la condición lógica a evaluar, el segundo es el valor devuelto en caso de que la condición sea TRUE y el tercero, el valor devuelto en caso de que sea FALSE. Esta función se usó para agregar un signo + delante de los coeficientes b y c si son positivos.\nSe puede pensar en formas más elaboradas para escribir la expresión de la ecuación, que hagan un mejor manejo de espacios o que omitan los términos cuyos coeficientes son nulos.\nSe usó la función stop() para detener la ejecución del script si el coeficiente asociado al término de segundo grado es 0.",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_04.html#ejercicio-6-opcional",
    "href": "capitulos/90_soluciones_04.html#ejercicio-6-opcional",
    "title": "Soluciones de la Práctica de la Unidad 4",
    "section": "Ejercicio 6 (opcional)",
    "text": "Ejercicio 6 (opcional)\nEl contenido del script resolvente_args.R puede ser:\n\n# Mensaje de bienvenida\ncat(\"=========================================\\n\")\ncat(\"  Calculadora de ecuaciones cuadráticas\\n\")\ncat(\"=========================================\\n\")\n\n# Capturar los argumentos pasados desde la terminal en un vector\nargs &lt;- commandArgs(trailingOnly = TRUE)\n\n# Si no proveyó suficientes argumentos, generar un error y que se detenga el programa\nif (length(args) &lt; 3) {\n  stop(\"Debe proveer tres valores para los coeficientes de la ecuación.\")\n}\n\n# Convertir a numérico todos los argumentos\na &lt;- as.numeric(args[1])\nb &lt;- as.numeric(args[2])\nc &lt;- as.numeric(args[3])\n\n# Si alguno no era numérico, no se pudo convertir y es NA\nif (is.na(a) || is.na(b) || is.na(c)) {\n  stop(\"Los argumentos ingresados no son valores numéricos.\")\n}\n\n# Si a = 0, genera un error y se detiene\nif (a == 0) {\n  stop(\"Error: el coeficiente 'a' debe ser distinto de cero. Fin del programa.\\n\")\n}\n\n# Mostrar la ecuación de forma legible\necuacion &lt;- paste0(a, \"x²\", ifelse(b &lt; 0, \"\", \"+\"), b, \"x\", ifelse(c &lt; 0, \"\", \"+\"), c, \"=0\")\ncat(\"\\nEcuación ingresada: \", ecuacion, \"\\n\")\n\n# Calcular el discriminante\nD &lt;- b^2 - 4 * a * c\ncat(\"Discriminante (D):\", round(D, 3), \"\\n\")\n\n# Calcular soluciones\nif (D &gt; 0) {\n  x1 &lt;- (-b - sqrt(D)) / (2 * a)\n  x2 &lt;- (-b + sqrt(D)) / (2 * a)\n  cat(\"Existen dos soluciones reales distintas:\\n\")\n  cat(\"x₁ =\", round(x1, 3), \", x₂ =\", round(x2, 3), \"\\n\")\n} else if (D == 0) {\n  x &lt;- -b / (2 * a)\n  cat(\"Existe una única solución real (raíz doble):\\n\")\n  cat(\"x =\", round(x, 3), \"\\n\")\n} else {\n  cat(\"Las soluciones son complejas (no reales).\\n\")\n}\n\n# Mensaje de despedida\ncat(\"\\nGracias por usar la calculadora de ecuaciones cuadráticas.\\n\")",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 4</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_05.html",
    "href": "capitulos/90_soluciones_05.html",
    "title": "Soluciones de la Práctica de la Unidad 5",
    "section": "",
    "text": "Vectores",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_05.html#vectores",
    "href": "capitulos/90_soluciones_05.html#vectores",
    "title": "Soluciones de la Práctica de la Unidad 5",
    "section": "",
    "text": "Ejercicio 1\n\n#' Suma de los elementos de un vector\n#'\n#' Calcula la suma de todos los elementos de un vector numérico.\n#'\n#' @param v Un vector numérico.\n#' @return La suma de los elementos del vector.\n#' @examples\n#' suma(c(1, 2, 3))  # Devuelve 6\nsuma &lt;- function(v) {\n  resultado &lt;- 0\n  for (i in 1:length(v)) {\n    resultado &lt;- resultado + v[i]\n  }\n  return(resultado)\n}\n\n\n\nEjercicio 2\n\n#' Suma componente a componente de dos vectores\n#'\n#' Suma dos vectores numéricos de igual longitud, elemento a elemento.\n#' Si las longitudes no coinciden, se detiene con error.\n#'\n#' @param u Un vector numérico.\n#' @param v Un vector numérico.\n#'\n#' @return Un vector numérico con la suma componente a componente.\n#'\n#' @examples\n#' sumar_vectores(c(1, 2, 3), c(4, 5, 6))  # Devuelve c(5, 7, 9)\nsumar_vectores &lt;- function(u, v) {\n  nu &lt;- length(u)\n  nv &lt;- length(v)\n  if (nu != nv) {\n    stop(\"Las dimensiones de los vectores no coinciden.\")\n  }\n  suma &lt;- numeric(nu)\n  for (i in 1:nu) { \n    suma[i] &lt;- u[i] + v[i]\n  }\n  return(suma)\n}\n\n\n\nEjercicio 3\n\n#' Ordenar un vector numérico de forma ascendente\n#'\n#' Ordena los elementos de un vector numérico en orden ascendente usando un \n#' algoritmo de comparación simple.\n#'\n#' @param v Un vector numérico.\n#'\n#' @return Un vector numérico con los elementos ordenados de menor a mayor.\n#'\n#' @examples\n#' ordenar_asc(c(3, 1, 4, 2))  # Devuelve c(1, 2, 3, 4)\nordenar_asc &lt;- function(v) {\n  n &lt;- length(v)\n  for (i in 1:n) {\n    for (j in i:n) {\n      if (v[i] &gt; v[j]) {\n        tmp &lt;- v[i]\n        v[i] &lt;- v[j]\n        v[j] &lt;- tmp \n      }\n    }\n  }\n  return(v)\n}\n\n\n\nEjercicio 4\n\n#' Máximo de un vector numérico\n#'\n#' Encuentra el valor máximo en un vector numérico y su posición.\n#'\n#' @param v Un vector numérico.\n#'\n#' @return Un vector numérico de longitud 2. El primer elemento es el valor \n#' máximo, y el segundo, la posición donde se encuentra (primera aparición).\n#'\n#' @examples\n#' maximo(c(4, 2, 7, 1))  # Devuelve c(7, 3)\n#' maximo(c(10))          # Devuelve c(10, 1)\nmaximo &lt;- function(v) {\n  n &lt;- length(v)\n  mayor &lt;- v[1]\n  posicion &lt;- 1\n  for (i in 1:n) {\n    # Desde i = 1 para que también funcione si n = 1\n    if (v[i] &gt; mayor) {\n      mayor &lt;- v[i]\n      posicion &lt;- i\n    }\n  }\n  resultado &lt;- c(\"mayor\" = mayor, \"posicion\" = posicion)\n  return(resultado)\n}\n\n\n\nEjercicio 5\n\nProducto escalar de dos vectores.\n\n#' Producto escalar de dos vectores\n#'\n#' Calcula el producto escalar entre dos vectores numéricos de igual \n#' longitud.\n#'\n#' @param u Un vector numérico.\n#' @param v Un vector numérico.\n#'\n#' @return Un número que representa el producto escalar entre u y v.\n#' @details Se detiene con error si las longitudes no coinciden.\n#'\n#' @examples\n#' prod_escalar(c(1, 2, 3), c(4, 5, 6))  # Devuelve 32\n#' prod_escalar(c(1, 2), c(1, 2, 3))     # Error\nprod_escalar &lt;- function(u, v) {\n  nu &lt;- length(u)\n  nv &lt;- length(v)\n  if (nu != nv) {\n    stop(\"Las dimensiones de los vectores no coinciden.\")\n  }\n  suma &lt;- 0\n  for (i in 1:nu) {\n    suma &lt;- suma + u[i] * v[i]\n  }\n  return(suma)\n}\n\nProducto vectorial de dos vectores de dimensión 3\n\n#' Producto vectorial de dos vectores de dimensión 3\n#'\n#' Calcula el producto vectorial entre dos vectores numéricos de dimensión \n#' 3.\n#'\n#' @param u Un vector numérico de longitud 3.\n#' @param v Un vector numérico de longitud 3.\n#'\n#' @return Un vector numérico de longitud 3 que representa el producto \n#' vectorial u × v\n#' \n#' @details Se detiene con error si alguno de los vectores no tiene \n#' dimensión 3.\n#'\n#' @examples\n#' prod_vectorial(c(1, 0, 0), c(0, 1, 0))  # Devuelve c(0, 0, 1)\n#' prod_vectorial(c(1, 2), c(3, 4))        # Error\nprod_vectorial &lt;- function(u, v) {\n  nu &lt;- length(u)\n  nv &lt;- length(v)\n  if (nu != 3 || nv != 3) {\n    stop(\"Los vectores no son de dimensión 3.\")\n  }\n  resultado &lt;- c(u[2] * v[3] - u[3] * v[2], \n                 u[3] * v[1] - u[1] * v[3], \n                 u[1] * v[2] - u[2] * v[1])\n  return(resultado)\n}\n\nProducto mixto de tres vectores de dimensión 3\n\n#' Producto mixto de tres vectores de dimensión 3\n#'\n#' Calcula el producto mixto de tres vectores u, v y w  de dimensión 3,\n#' definido como el producto escalar de w con el producto vectorial de u y v\n#'\n#' @param u Un vector numérico de longitud 3.\n#' @param v Un vector numérico de longitud 3.\n#' @param w Un vector numérico de longitud 3.\n#'\n#' @return Un número que representa el producto mixto.\n#' @details Se detiene con error si alguno de los vectores no tiene \n#' dimensión 3.\n#'\n#' @examples\n#' prod_mixto(c(1, 0, 0), c(0, 1, 0), c(0, 0, 1)) # Devuelve 1\n#' prod_mixto(c(1, 2), c(3, 4, 5), c(6, 7, 8))    # Error\nprod_mixto &lt;- function(u, v, w) {\n  resultado1 &lt;- prod_vectorial(u, v)\n  resultado2 &lt;- prod_escalar(resultado1, w)\n  return(resultado2)\n}\n\nMostrar productos vectoriales y escalares entre tres vectores\n\n#' Mostrar productos vectoriales y escalares entre tres vectores\n#'\n#' Calcula y muestra por consola el producto escalar entre v y w, \n#' el producto vectorial entre u y w, y el producto mixto entre v, w y u.\n#'\n#' @param u Un vector numérico de longitud 3.\n#' @param v Un vector numérico de longitud 3.\n#' @param w Un vector numérico de longitud 3.\n#'\n#' @return No devuelve un valor, solo imprime los resultados por consola.\n#'\n#' @examples\n#' mostrar_productos(c(5, 8, 2), c(2, 3, -1), c(1, 2, 3))\nmostrar_productos &lt;- function(u, v, w) {\n  prod_esc &lt;- prod_escalar(v, w)\n  prod_mix &lt;- prod_mixto(v, w, u)\n  cat(\"El producto escalar entre v y w es:\", prod_esc, \"\\n\")\n  cat(\"El producto mixto entre v, w y u es:\", prod_mix, \"\\n\")\n  resultado &lt;- c(\"prod_escalar\" = prod_esc, \"prod_mixto\" = prod_mix)\n  return(resultado)\n}\n\n\n\n\nEjercicio 6\n\n#' Mostrar números primos hasta n usando distintos enfoques de la Criba de \n#' Eratóstenes\n#'\n#' Esta función muestra los números primos hasta n utilizando distintos enfoques\n#' de la criba de Eratóstenes.\n#' El argumento enfoque permite elegir entre varias implementaciones:\n#' \"asumir_primos\", \"tachar\", o \"encerrado\".\n#'\n#' @param n Un número entero positivo que indica el límite superior para \n#' la búsqueda de primos.\n#' @param enfoque Un string que indica el enfoque a usar: \"asumir_primos\",\n#' \"tachar\" o \"encerrado\".\n#'\n#' @details\n#' Los enfoques disponibles son:\n#' \n#' - \"asumir_primos\"\n#' Parte de un vector lógico donde todos los números son considerados primos \n#' inicialmente (excepto el 1). Luego, se descartan los múltiplos de cada \n#' número que aún es considerado primo.\n#'\n#' - \"tachar\"\n#' Utiliza un vector \"tachado\" para marcar con TRUE los números que no son \n#' primos (es decir, los tachados). Comienza tachando el 1, y luego los \n#' múltiplos de cada número no tachado. Los primos son los que quedan sin\n#' tachar al final.\n#'\n#' - \"encerrado\"\n#' Usa un vector lógico llamado \"encerrado\" donde todos los números empiezan \n#' como TRUE. Cada vez que se encuentra un primo, se marcan (ponen en FALSE) \n#' todos sus múltiplos, indicando que ya no están \"encerrados\".\n#' \n#' @return Ninguno. La función imprime en consola los números primos encontrados.\n#'\n#' @examples\n#' mostrar_primos(30, enfoque = \"asumir_primos\")\n#' mostrar_primos(30, enfoque = \"tachar\")\n#' mostrar_primos(30, enfoque = \"encerrado\")\nmostrar_primos &lt;- function(n, enfoque = c(\"asumir_primos\", \"tachar\", \"encerrado\")) {\n  if (enfoque == \"asumir_primos\") {\n    es_primo &lt;- rep(TRUE, n)\n    es_primo[1] &lt;- FALSE\n    for (i in 2:n) {\n      if (es_primo[i]) {\n        print(i)\n        j &lt;- 2 * i\n        while (j &lt;= n) {\n          es_primo[j] &lt;- FALSE\n          j &lt;- j + i\n        }\n      }\n    }\n  } else if (enfoque == \"tachar\") {\n    tachado &lt;- logical(n)\n    tachado[1] &lt;- TRUE\n    for (i in 2:n) {\n      if (!tachado[i]) {\n        print(i)\n        j &lt;- 2 * i\n        while (j &lt;= n) {\n          tachado[j] &lt;- TRUE\n          j &lt;- j + i\n        }\n      }\n    }\n  } else if (enfoque == \"encerrado\") {\n    encerrado &lt;- rep(TRUE, n)\n    for (i in 2:n) {\n      if (encerrado[i]) {\n        print(i)\n        for (j in seq(i, n, i)) {\n          encerrado[j] &lt;- FALSE\n        }\n      }\n    }\n  }\n}",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_05.html#matrices",
    "href": "capitulos/90_soluciones_05.html#matrices",
    "title": "Soluciones de la Práctica de la Unidad 5",
    "section": "Matrices",
    "text": "Matrices\n\nEjercicio 7\n\n#' Suma de dos matrices\n#'\n#' Esta función toma dos matrices del mismo tamaño y devuelve una nueva matriz \n#' que representa la suma elemento a elemento de ambas. Si las dimensiones \n#' no coinciden, imprime un mensaje de error y devuelve NULL\n#'\n#' @param A Una matriz numérica.\n#' @param B Una matriz numérica del mismo tamaño que A.\n#'\n#' @return Una matriz con la suma de A y B\n#' @details Produce error si las dimensiones no coinciden.\n#'\n#' @examples\n#' A &lt;- matrix(1:4, nrow = 2)\n#' B &lt;- matrix(5:8, nrow = 2)\n#' sumar_matrices(A, B)\nsumar_matrices &lt;- function(A, B) {\n  if (nrow(A) != nrow(B) || ncol(A) != ncol(B)) {\n    stop(\"Las dimensiones de las matrices no coinciden.\")\n  }\n  suma &lt;- matrix(NA, nrow(A), ncol(A))\n  for (i in 1:nrow(A)) {\n    for (j in 1:ncol(A)) {\n      suma[i, j] &lt;- A[i, j] + B[i, j]\n    }\n  }\n  return(suma)\n}\n\n\n\nEjercicio 8\n\nMínimo de una matriz y su posición.\n\n#' Mínimo de una matriz y su posición\n#'\n#' Esta función recorre una matriz y devuelve un vector con el valor mínimo \n#' y su posición (fila y columna) dentro de la matriz.\n#'\n#' @param m Una matriz numérica.\n#'\n#' @return Un vector numérico de longitud 3 con los siguientes valores: \n#' - Posición 1: El valor mínimo encontrado en la matriz.\n#' - Posición 2: La fila donde se encuentra el valor mínimo.\n#' - Posición 3: La columna donde se encuentra el valor mínimo.\n#'\n#' @examples\n#' matriz &lt;- matrix(c(3, 2, 5, 1, 4, 6), nrow = 2)\n#' minimo_matriz(matriz)\nminimo_matriz &lt;- function(m) {\n  min &lt;- m[1, 1]\n  fila &lt;- 1\n  col &lt;- 1\n  for (i in 1:nrow(m)) {\n    for (j in 1:ncol(m)) {\n      if (m[i, j] &lt; min) {\n        min &lt;- m[i, j]\n        fila &lt;- i\n        col &lt;- j\n      }\n    }\n  }\n  resultado &lt;- c(minimo = min, fila = fila, columna = col)\n  return(resultado)\n}\n\nEncontrar el valor mínimo en una fila específica de una matriz.\n\n#' Encontrar el valor mínimo en una fila específica de una matriz\n#'\n#' Esta función busca el valor mínimo dentro de una fila específica de una \n#' matriz y devuelve el valor junto con el número de columna donde se \n#' encuentra.\n#'\n#' @param m Una matriz numérica.\n#' @param fila Un entero que indica el número de fila en la que se desea \n#' buscar el valor mínimo.\n#'\n#' @return Un vector numérico de longitud 2con los siguientes valores: \n#' - Posición 1: El valor mínimo en la fila especificada.\n#' - Posición 2: El número de columna donde se encuentra ese valor mínimo.\n#'\n#' @examples\n#' matriz &lt;- matrix(c(3, 2, 5, 1, 4, 6), nrow = 2)\n#' minimo_matriz_fila(matriz, 1)\nminimo_matriz_fila &lt;- function(m, fila = 1) {\n  min &lt;- m[fila, 1]\n  col &lt;- 1\n  for (j in 1:ncol(m)) {\n    if (m[fila, j] &lt; min) {\n      min &lt;- m[fila, j]\n      col &lt;- j\n    }\n  }\n  return(c(minimo = min, columna = col))\n}\n\n\n\n\nEjercicio 9\n\nOrdenar matriz por columna en orden descendente.\n\n#' Ordenar matriz por columna en orden descendente\n#'\n#' Esta función ordena las filas de una matriz numérica según los valores\n#' de una columna específica, en orden descendente.\n#'\n#' @param m Una matriz\n#' @param col Un entero que indica el índice de la columna por la que se \n#' desea ordenar.\n#'\n#' @return La matriz ordenada por la columna especificada en orden \n#' descendente.\n#' \n#' @examples\n#' m &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2, byrow = TRUE)\n#' ordenar_desc_col(m, 1)\nordenar_desc_col &lt;- function(m, col) {\n  if (nrow(m) &gt; 1) {\n    for (i in 1:(nrow(m)-1)) {\n      for (j in (i+1):nrow(m)) {\n        if (m[i, col] &lt; m[j, col]) {\n          for (k in 1:ncol(m)) {\n            tmp &lt;- m[i, k]\n            m[i, k] &lt;- m[j, k]\n            m[j, k] &lt;- tmp\n          }\n        }\n      }\n    }\n  }\n  return(m)\n}\n\nObservaciones\n\nEn lugar de chequear si tiene más de una fila, podríamos directamente poner for (i in 1:nrow(m)) y for (j in i:nrow(m)). Esto funciona también cuando la matriz provista tiene una sola fila, pero en cualquier otro caso implica a hacer comparaciones lógicas de más, tantas como número de filastenga la matriz.\nSe puede mejorar la función agregando un control para que el argumento col provisto por el usuario esté siempre entre 1 y ncol(m).\n\nOrdenar matriz por fila en orden ascendente.\n\n#' Ordenar matriz por fila en orden ascendente\n#'\n#' Esta función ordena las columnas de una matriz numérica según los valores\n#' de una fila específica, en orden ascendente.\n#'\n#' @param m Una matriz numérica.\n#' @param fila Un entero que indica el índice de la fila por la que se desea \n#' ordenar.\n#'\n#' @return La matriz ordenada por la fila especificada en orden ascendente.\n#' \n#' @examples\n#' m &lt;- matrix(c(3, 1, 4, 2, 6, 5), nrow = 2, byrow = TRUE)\n#' ordenar_asc_fila(m, 1)\nordenar_asc_fila &lt;- function(m, fila) {\n  if (ncol(m) &gt; 1) {\n    for (i in 1:(ncol(m) - 1)) {\n      for (j in (i + 1):ncol(m)) {\n        if (m[fila, i] &gt; m[fila, j]) { # Solo cambia el signo\n          for (k in 1:nrow(m)) {\n            tmp      &lt;- m[k, i]\n            m[k, i]  &lt;- m[k, j]\n            m[k, j]  &lt;- tmp\n          }\n        }\n      }\n    }\n  }\n  return(m)\n}\n\n\n\n\nEjercicio 10\n\n#' Verificar si una matriz es un cuadrado mágico\n#'\n#' Esta función verifica si una matriz cuadrada numérica es un cuadrado mágico.\n#' Un cuadrado mágico es una matriz en la que la suma de los elementos en cada \n#' fila, en cada columna y en las dos diagonales principales es igual.\n#'\n#' @param cuadrado Una matriz cuadrada numérica.\n#'\n#' @return `TRUE` si la matriz es un cuadrado mágico, `FALSE` en caso contrario.\n#' \n#' @examples\n#' m &lt;- matrix(c(2, 7, 6, 9, 5, 1, 4, 3, 8), nrow=3, byrow=TRUE)\n#' cuadrado_magico(m)\ncuadrado_magico &lt;- function(cuadrado) {\n  n &lt;- nrow(cuadrado)\n  \n  # Calcular el primer total fila para tener de control\n  control &lt;- 0\n  for (j in 1:n) {\n    control &lt;- control + cuadrado[1, j]\n  }\n  \n  # Calcular los restantes totales filas y chequearlos\n  for (i in 2:n) {\n    total &lt;- 0\n    for (j in 1:n) {\n      total &lt;- total + cuadrado[i, j]\n    }\n    if (total != control) {\n      return(FALSE)\n    }\n  }\n  \n  # Chequear totales columnas si lo anterior estuvo bien\n  for (j in 1:n) {\n    total &lt;- 0\n    for (i in 1:n) {\n      total &lt;- total + cuadrado[i, j]\n    }\n    if (total != control) {\n      return(FALSE)\n    }\n  }\n  \n  # Chequear diagonales si lo anterior estuvo bien\n  diag1 &lt;- 0\n  diag2 &lt;- 0\n  for (i in 1:n) {\n    diag1 &lt;- diag1 + cuadrado[i, i]\n    diag2 &lt;- diag2 + cuadrado[n - i + 1, i]\n  }\n  if (diag1 != control || diag2 != control) {\n    return(FALSE)\n  }\n  \n  # Si llegamos hasta acá es porque todos los controles dieron bien\n  return(TRUE)\n}",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/90_soluciones_05.html#operaciones-vectorizadas",
    "href": "capitulos/90_soluciones_05.html#operaciones-vectorizadas",
    "title": "Soluciones de la Práctica de la Unidad 5",
    "section": "Operaciones vectorizadas",
    "text": "Operaciones vectorizadas\n\nEjercicio 11\n\nx &lt;- c(2, 5, 8, 1, 9)\nx\n\n[1] 2 5 8 1 9\n\n# a)\nlog(x, base = 5)\n\n[1] 0.4306766 1.0000000 1.2920297 0.0000000 1.3652124\n\n# b)\nwhich(x &gt; 4)\n\n[1] 2 3 5\n\n# c)\nx[x&gt;4]\n\n[1] 5 8 9\n\n# d)\nlength(x[x&gt;4])\n\n[1] 3\n\nsum(x&gt;4)\n\n[1] 3\n\n# e)\nx[x %% 2 == 0]\n\n[1] 2 8\n\n# f)\nsum(x[x&gt;5])\n\n[1] 17\n\n\n\n\nEjercicio 12\n\nm &lt;- matrix(1:9, nrow = 3)\nm\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# a)\nm + 10\n\n     [,1] [,2] [,3]\n[1,]   11   14   17\n[2,]   12   15   18\n[3,]   13   16   19\n\n# b)\nm^(1/3)\n\n         [,1]     [,2]     [,3]\n[1,] 1.000000 1.587401 1.912931\n[2,] 1.259921 1.709976 2.000000\n[3,] 1.442250 1.817121 2.080084\n\n# c)\nm * 2\n\n     [,1] [,2] [,3]\n[1,]    2    8   14\n[2,]    4   10   16\n[3,]    6   12   18\n\n# d)\nn &lt;- matrix(9:1, nrow = 3)\nm - n\n\n     [,1] [,2] [,3]\n[1,]   -8   -2    4\n[2,]   -6    0    6\n[3,]   -4    2    8\n\n# e)\nsum(m &gt; 5)\n\n[1] 4\n\n# f)\nm[m &gt; 5]  # muestra los valores mayores que 5 como un vector\n\n[1] 6 7 8 9\n\n# g)\nwhich(m &gt; 5, arr.ind = TRUE)\n\n     row col\n[1,]   3   2\n[2,]   1   3\n[3,]   2   3\n[4,]   3   3\n\n# h)\nsum(m)\n\n[1] 45\n\nmean(m)\n\n[1] 5\n\nrowSums(m)\n\n[1] 12 15 18\n\ncolSums(m)\n\n[1]  6 15 24\n\nrowMeans(m)\n\n[1] 4 5 6\n\ncolMeans(m)\n\n[1] 2 5 8\n\n\n\n\nEjercicio 13\n\nx &lt;- 1:20\n# a)\nx[x &gt; 10 & x %% 3 == 0]\n\n[1] 12 15 18\n\n# b)\nx[!(x %% 2 == 0 | x %% 5 == 0)]\n\n[1]  1  3  7  9 11 13 17 19\n\nx[x %% 2 != 0 & x %% 5 != 0]\n\n[1]  1  3  7  9 11 13 17 19\n\n# c)\nlength(x[x %% 2 != 0 & x %% 5 != 0])\n\n[1] 8\n\nsum(x %% 2 != 0 & x %% 5 != 0)\n\n[1] 8\n\n\n\n\nEjercicio 14\n\nLa función es sum(). Se puede usar tanto con vectores como con matrices.\n\nmi_vector &lt;- c(60, -5, 0, 12, 1)\n# Nuestra función\nsuma(mi_vector)\n\n[1] 68\n\n# La función de R Base\nsum(mi_vector)\n\n[1] 68\n\n\nBasta con hacer:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nu + v\n\n[1]  7 11  1\n\nA &lt;- matrix(c(5, 8, 2, 2, 3, 1), nrow = 3)\nB &lt;- matrix(c(0, -1, 3, 1, 2, 4), nrow = 3)\nA + B\n\n     [,1] [,2]\n[1,]    5    3\n[2,]    7    5\n[3,]    5    5\n\n\nLa función es sort()\n\nmi_vector &lt;- c(60, -5, 0, 12, 1)\n# Por defecto, sort() ordena de forma ascendente\nsort(mi_vector)\n\n[1] -5  0  1 12 60\n\n# Podemos definir decreasing = TRUE para ordenar en forma descendente\nsort(mi_vector, decreasing = TRUE)\n\n[1] 60 12  1  0 -5\n\n\nSi se aplica en vectores de tipo carácter, ordena alfabéticamente:\n\nmi_vector &lt;- c(\"introducción\", \"a\", \"la\", \"programación\")\nsort(mi_vector)\n\n[1] \"a\"            \"introducción\" \"la\"           \"programación\"\n\nsort(mi_vector, decreasing = TRUE)\n\n[1] \"programación\" \"la\"           \"introducción\" \"a\"           \n\n\nUsamos min() y max():\n\n# Vectores\nmi_vector &lt;- c(60, -5, 0, -5, 12, 1)\nmin(mi_vector)\n\n[1] -5\n\nmax(mi_vector)\n\n[1] 60\n\n# Ubicación del mínimo o máximo (sólo primera ocurrencia)\nwhich.min(mi_vector)\n\n[1] 2\n\nwhich.max(mi_vector)\n\n[1] 1\n\n# Ubicación del mínimo o máximo (todas las ocurrencias)\nwhich(mi_vector == min(mi_vector))\n\n[1] 2 4\n\nwhich(mi_vector == max(mi_vector))\n\n[1] 1\n\n# También sirve para vectores de tipo carácter\nmi_vector &lt;- c(\"introducción\", \"a\", \"la\", \"programación\")\nmin(mi_vector)\n\n[1] \"a\"\n\n# Matrices\nA &lt;- matrix(c(5, 8, 2, 7, 3, 1), nrow = 3)\nA\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    8    3\n[3,]    2    1\n\nmin(A)\n\n[1] 1\n\nmax(A)\n\n[1] 8\n\n# Posición (arr.ind = TRUE para que nos indique fila y columna)\nwhich(A == min(A), arr.ind = TRUE)\n\n     row col\n[1,]   3   2\n\nwhich(A == max(A), arr.ind = TRUE)\n\n     row col\n[1,]   2   1\n\n\nSe puede hacer:\n\nu &lt;- c(5, 8, 2)\nv &lt;- c(2, 3, -1)\nsum(u * v)\n\n[1] 32\n\n# Usando la function del Ejercicio 5a:\nprod_escalar(u, v)\n\n[1] 32\n\n\nDe la siguiente forma:\n\nA\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    8    3\n[3,]    2    1\n\n# Evaluamos min() sólo en la fila 3\nmin(A[3, ])\n\n[1] 1\n\n# Para saber en qué columna de la fila 3 se encuentra su mínimo:\nwhich.min(A[3, ])\n\n[1] 2\n\n# Con la función del ejecicio 8b\nminimo_matriz_fila(A, 3)\n\n minimo columna \n      1       2 \n\n\nUna posibilidad es:\n\ncuadrado_magico &lt;- function(cuadrado) {\n\n  # Todos las sumas\n  sumas_filas &lt;- rowSums(cuadrado)\n  sumas_col &lt;- colSums(cuadrado)\n  suma_diag1 &lt;- sum(diag(cuadrado))\n  suma_diag2 &lt;- sum(diag(cuadrado[nrow(cuadrado):1, ]))\n\n  # Junto las sumas en un vector, deberían ser todoas iguales\n  # Arbitrariamente dejo afuera a suma_diag2, para comparar con ella\n  sumas &lt;- c(sumas_filas, sumas_col, suma_diag1)\n\n  # ¿Dieron igual todas las sumas?\n  return(all(sumas == suma_diag2))\n}\n\ncuadrado &lt;- matrix(c(16,  3,  2, 13,\n                      5, 10, 11,  8,\n                      9,  6,  7, 12,\n                      4, 15, 14,  1), nrow = 4, byrow = TRUE)\ncuadrado_magico(cuadrado)\n\n[1] TRUE\n\ncuadrado &lt;- matrix(c( 0,  3,  2, 13,\n                      5, 10, 11,  8,\n                      9,  6,  7, 12,\n                      4, 15, 14,  1), nrow = 4, byrow = TRUE)\ncuadrado_magico(cuadrado)\n\n[1] FALSE",
    "crumbs": [
      "Soluciones de la Práctica",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Soluciones de la Práctica de la Unidad 5</span>"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html",
    "href": "capitulos/98_tp.html",
    "title": "Trabajo Práctico",
    "section": "",
    "text": "Introducción\nEl “Juego de la Memoria”, también conocido como “Memotest”, es un clásico juego de mesa que pone a prueba la capacidad de atención y la memoria visual de los participantes. Su dinámica es simple pero atrapante: se colocan fichas o cartas boca abajo, con imágenes ocultas, y los jugadores deben voltearlas de a dos por turno, intentando encontrar pares coincidentes. Si las dos fichas tienen la misma imagen, el jugador las retira del tablero y puede seguir jugando. Si no coinciden, se vuelven a colocar boca abajo, y es turno del siguiente jugador.\nEste juego ha sido disfrutado por generaciones tanto en el ámbito familiar como en actividades educativas, ya que además de ser entretenido, fomenta habilidades cognitivas importantes. En este trabajo práctico, vamos a programar en R una versión digital y simplificada del juego, que se podrá jugar en solitario desde la terminal de la computadora.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#objetivo",
    "href": "capitulos/98_tp.html#objetivo",
    "title": "Trabajo Práctico",
    "section": "Objetivo",
    "text": "Objetivo\nEl objetivo de este trabajo práctico es desarrollar una versión interactiva del Juego de la Memoria en R, que funcione desde la terminal. El programa permitirá jugar con un tablero de fichas ocultas, revelarlas de a pares, y buscar coincidencias hasta completar todos los pares disponibles. El juego debe mostrar el estado del tablero en cada momento, registrar la cantidad de intentos realizados y permitir al jugador reiniciar la partida si lo desea.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#dinámica-del-juego",
    "href": "capitulos/98_tp.html#dinámica-del-juego",
    "title": "Trabajo Práctico",
    "section": "Dinámica del juego",
    "text": "Dinámica del juego\nPara comprender cómo debe funcionar el programa, deben mirar el video grabado con una demo. El tablero estará compuesto por una cantidad par de fichas organizadas en una grilla rectangular (por ejemplo, 4 filas por 5 columnas). Cada ficha tiene un símbolo, letra o texto oculto, y hay exactamente dos fichas con cada símbolo.\nEn cada turno, el jugador debe ingresar la posición de dos fichas para descubrir. El programa debe mostrar el tablero con las dos fichas seleccionadas visibles. Si las fichas coinciden, permanecen visibles. Si no coinciden, el jugador debe memorizar su ubicación y el programa espera hasta que el jugador le diga que está listo para continuar. El juego continúa hasta que el jugador haya encontrado todos los pares. Al finalizar, se muestra la cantidad de intentos realizados y se ofrece la posibilidad de jugar otra partida.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#la-terminal",
    "href": "capitulos/98_tp.html#la-terminal",
    "title": "Trabajo Práctico",
    "section": "La terminal",
    "text": "La terminal\nEl programa es interactivo y requiere que el usuario ingrese datos en tiempo real: configurar el tablero, elegir posiciones del tablero para descubrir, decidir si desea volver a jugar, etc. Por ello, el programa debe ejecutarse desde la terminal de la computadora, donde pueden escribirse comandos y visualizarse respuestas del sistema. Es importante familiarizarse con la Unidad 4 de la asignatura para lograr este funcionamiento del programa.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#materiales-provistos",
    "href": "capitulos/98_tp.html#materiales-provistos",
    "title": "Trabajo Práctico",
    "section": "Materiales provistos",
    "text": "Materiales provistos\nPara realizar este trabajo práctico cuentan con los siguientes archivos de apoyo:\n\nScript jugar.R: archivo principal donde deben escribir su programa. Contiene una plantilla con instrucciones y espacio para agregar los datos del equipo y el código del juego.\nPaquete memoria: este paquete creado por la cátedra ofrece funciones auxiliares que simplifican muchas partes de la solución de este trabajo y serán de extrema utilidad. Se recomienda leer la documentación del paquete con atención y correr los ejemplos. Las funciones disponibles son: nuevo_tablero, validar_fichas, mostrar_tablero, texto_lento, limpiar_consola, leer_eleccion, mostrar_info, posiciones_disponibles y mostrar_pares. En el script jugar.R se incluyen instrucciones de instalación.\n\nInformación importante para usuarios de Windows\nSi usas Windows, para instalar el paquete memoria es necesario tener instalado Rtools, un conjunto de herramientas que permite compilar paquetes de R que contienen código en C/C++ o Fortran. Instrucciones de instalación:\n\nVisitar la página https://cran.r-project.org/bin/windows/Rtools/\nElegir la versión correspondiente para la versión de R que tengan instalada. Por ejemplo, para la versión de R 4.4.1 es necesario descargar Rtools 4.4. Para descubrir la versión de R instalada en su computadora pueden ejecutar R.version.string en la consola.\nDescargar el instalador haciendo click en el link correspondiente. El link se encuentra en la sección Installing RtoolsNN y lleva el nombre RtoolsNN installer. NN hace referencia a la versión de Rtools. En nuestro ejemplo, NN sería 44.\nEjecutar el instalador y seguir las instrucciones. Pueden elegir valores por defecto.\nUna vez instalado, cerrar RStudio y volver a abrirlo para asegurarse que los cambios se apliquen correctamente.\n\nSiguiendo los pasos anteriores, la instalación de memoria debería poder continuar sin inconvenientes.\nInstalación alternativa del paquete memoria\n\nDescargar memoria_0.1.0.tar.gz. Una vez descargado, se recomienda mover el archivo a la misma carpeta donde está el archivo jugar.R.\nEjecutar install.packages(\"ruta/a/memoria_0.1.0.tar.gz\", repos = NULL, type = \"source\"), reemplazando \"ruta/a/memoria_0.1.0.tar.gz\" por la ruta correspondiente.\n\nSi memoria_0.1.0.tar.gz está en la carpeta de su proyecto de R pueden ejecutar install.packages(\"memoria_0.1.0.tar.gz\", repos = NULL, type = \"source\"). Recuerden que al trabajar en un proyecto de R pueden usar rutas relativas.\nCaso contrario, \"ruta/a/memoria_0.1.0.tar.gz\" deberá ser la ruta absoluta a la ubicación del archivo.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#descomposición-algorítmica",
    "href": "capitulos/98_tp.html#descomposición-algorítmica",
    "title": "Trabajo Práctico",
    "section": "Descomposición algorítmica",
    "text": "Descomposición algorítmica\nPara organizar el código de manera clara y modular, se recomienda aplicar el principio de descomposición algorítmica, creando funciones propias para distintas partes del juego. Estas funciones pueden definirse en jugar.R o, mejor aún, en scripts adicionales. El o los nuevos scripts deberán estar guardados en el mismo directorio que jugar.R, desde donde se los debe invocar con la función source(). Desde dicha carpeta, deben abrir la terminal y ejecutar el programa con Rscript jugar.R, sin que se produzcan errores.\nTodas las funciones creadas deben estar documentadas bajo el sistema Roxygen. Algunas podrán tomar argumentos, otras no, y algunas devolverán valores mientras que otras sólo imprimirán mensajes en pantalla. Lo importante es que cada función cumpla una tarea bien definida y facilite la lectura del programa principal.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#otras-indicaciones-y-sugerencias",
    "href": "capitulos/98_tp.html#otras-indicaciones-y-sugerencias",
    "title": "Trabajo Práctico",
    "section": "Otras indicaciones y sugerencias",
    "text": "Otras indicaciones y sugerencias\n\nEs conveniente diseñar el algoritmo antes de programar, es decir, tomarse tiempo para pensar cómo es la lógica de la estructura del juego, qué pequeñas partes se pueden ir programando y probando de a poco, etc.\nNo dejar para último momento. Empezar con inmediatez, ya que no se resuelve de un día para el otro y es posible que necesiten realizar consultas con los docentes. Si dejan para último momento ya no habrá tiempo de organizar consultas, no podrán entregar el trabajo práctico y quedarán libres en la asignatura.\nProbar el programa por partes, para asegurarse que cada cosa que van agregando funcione. Tratar de armar todo y luego evaluar puede hacer muy difícil a la tarea de detectar errores.\nUtilicen comentarios para identificar distintas partes de su programa y para describir qué se prentende realizar en cada sección.\nEl objetivo estará cumplido si logran un programa similar al presentado en la demo. Opcionalmente, pueden incluir otros agregados que les resulte de interés.\nSi no logran programar todo lo pedido, igualmente realicen la entrega de lo que hayan podido hacer y los docentes evaluarán si es suficiente o no para aprobar.\nNo intentar resolver todo de a una vez. Agregar pequeñas partes de a poco. Utilizar la emisión de mensajes temporarios para ir probando el código.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#equipos",
    "href": "capitulos/98_tp.html#equipos",
    "title": "Trabajo Práctico",
    "section": "Equipos",
    "text": "Equipos\nEl trabajo práctico se resuelve en grupos de exactamente CUATRO integrantes, de cualquier comisión. Hay tiempo hasta el lunes 19/5/25 para informar la composición de cada equipo en este foro de Comunidades. Asimismo, si no tenés equipo o faltan integrantes en tu grupo, hay tiempo hasta esa fecha para comentar la situación en ese mismo foro. El día martes 20/5 se tomarán del foro los nombres de aquellos que hayan manifestado interés de hacer el TP pero no pudieron formar equipo, y entre ellos se crearán al azar nuevos equipos y/o se completarán también al azar los grupos incompletos. El armado de estos equipos será inapelable.\nEl script jugar.R tiene un espacio destinado para escribir los nombres de los integrantes del equipo. Deben colocar allí los nombres de quienes hayan efectivamente participado del trabajo. Comunidades les permite a todos los integrantes de un equipo ver los archivos que se han entregado, de modo que cada estudiante sabe si su nombre figura o no en el script. Si en el mismo falta el nombre de un estudiante y los docentes no son contactados al respecto, se entenderá que dicha persona no realizó el trabajo y quedará libre.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#código-de-conducta",
    "href": "capitulos/98_tp.html#código-de-conducta",
    "title": "Trabajo Práctico",
    "section": "Código de conducta",
    "text": "Código de conducta\n\nLa discusión entre integrantes de distintos grupos está permitida, no así el intercambio de código. Se puede debatir en el foro de Comunidades o en otros medios, pero no publicar partes de código.\nLas entregas son sometidas a un software de detección de plagio, si se detectan similaridades sospechosas en el trabajo de distintos grupos, podrán quedar descalificados.\nCuando se detecta un uso llamativo de herramientas de Inteligencia Artificial o estructuras de programación que no se corresponde con los usos y funciones básicas vistas en este curso introductorio, los estudiantes son convocados por los docentes para defender y explicar su entrega de forma oral y responder preguntas sobre la resolución entregada.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#entrega",
    "href": "capitulos/98_tp.html#entrega",
    "title": "Trabajo Práctico",
    "section": "Entrega",
    "text": "Entrega\nDeben entregar el archivo jugar.R y cualquier otro script que generen, en la sección destinada para tal fin del aula virtual. Es suficiente con que un integrante del equipo adjunte los archivos. El resto de los integrantes podrá ver la entrega y, más adelante, la devolución y calificación por parte de los docentes.\nFecha límite de entrega: martes 10/06 a las 08:00 No se reciben trabajos fuera de este horario límite, sin ningún tipo de excepción.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/98_tp.html#evaluación",
    "href": "capitulos/98_tp.html#evaluación",
    "title": "Trabajo Práctico",
    "section": "Evaluación",
    "text": "Evaluación\nLa evaluación tendrá en cuenta:\n\nSi el programa funciona y permite jugar.\nSi el programa implementa el juego con el comportamiento presentado en la demo.\nSi hay prolijidad, claridad y buen uso de comentarios en el código.\nSi el trabajo muestra ser original y no copia de otros recursos.",
    "crumbs": [
      "Apéndices",
      "Trabajo Práctico"
    ]
  },
  {
    "objectID": "capitulos/99_bibliografia.html",
    "href": "capitulos/99_bibliografia.html",
    "title": "Bibliografía",
    "section": "",
    "text": "Grolemund, G. (2014). Hands-On Programming with R. O’Reilly. Disponible online: https://rstudio-education.github.io/hopr/.\nMoeller, J. (2013). The Windows Command Line Beginner’s Guide. Azure Flame Media. 2nd Ed.\nParadis, E. (2005). R para Principiantes. Universit´e Montpellier II. Disponible online: https://cran.r-project.org/doc/contrib/rdebuts_es.pdf.\nPeng, R.; Kross, S.; Anderson, B. (2020). Mastering Software Development in R. Leanpub. Disponible online: https://bookdown.org/rdpeng/RProgDA/.\nSantana, S.; Mateos Farfán, E. (2014). El arte de programar en R: un lenguaje para la estadística. Instituto Mexicano de Tecnología del Agua, UNESCO. Disponible online: https://cran.r-project.org/doc/contrib/Santana_El_arte_de_programar_en_R.pdf.\nShotts, W. (2024). The Linux Command Line: A Complete Introduction. No Starch Press. 6th Internet Edition. Disponible online: https://sourceforge.net/projects/linuxcommand/files/TLCL/24.11/TLCL-24.11.pdf/download.\nWickham, H. (2019). Advanced R. Chapman and Hall/CRC. 2nd Ed. Disponible online: https://adv-r.hadley.nz/.\nWickham, H.; Bryan, J. (2023). R Packages. O’Reilly. 2nd Ed. Disponible online: https://r-pkgs.org/.\nWickham, H.; Cetinkaya-Rundel, M.; Grolemund, G. (2023). R para Ciencia de Datos. O’Reilly. 2da Ed. Disponible online: https://es.r4ds.hadley.nz/.\n\nÍconos creados por Smashicons and by juicy_fish y tomados de Flaticon.",
    "crumbs": [
      "Apéndices",
      "Bibliografía"
    ]
  }
]